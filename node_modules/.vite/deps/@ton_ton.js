import {
  require_dist
} from "./chunk-MFWUOUTL.js";
import "./chunk-MDKRAAK7.js";
import {
  __commonJS
} from "./chunk-AX6B7HUW.js";

// node_modules/symbol.inspect/index.js
var require_symbol = __commonJS({
  "node_modules/symbol.inspect/index.js"(exports, module) {
    "use strict";
    var SymbolInspect = Symbol.for("nodejs.util.inspect.custom");
    module.exports = SymbolInspect;
  }
});

// node_modules/@ton/core/dist/utils/crc16.js
var require_crc16 = __commonJS({
  "node_modules/@ton/core/dist/utils/crc16.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crc16 = void 0;
    function crc16(data) {
      const poly = 4129;
      let reg = 0;
      const message = Buffer.alloc(data.length + 2);
      message.set(data);
      for (let byte of message) {
        let mask = 128;
        while (mask > 0) {
          reg <<= 1;
          if (byte & mask) {
            reg += 1;
          }
          mask >>= 1;
          if (reg > 65535) {
            reg &= 65535;
            reg ^= poly;
          }
        }
      }
      return Buffer.from([Math.floor(reg / 256), reg % 256]);
    }
    exports.crc16 = crc16;
  }
});

// node_modules/@ton/core/dist/address/Address.js
var require_Address = __commonJS({
  "node_modules/@ton/core/dist/address/Address.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.address = exports.Address = void 0;
    var symbol_inspect_1 = __importDefault(require_symbol());
    var crc16_1 = require_crc16();
    var bounceable_tag = 17;
    var non_bounceable_tag = 81;
    var test_flag = 128;
    function parseFriendlyAddress(src) {
      if (typeof src === "string" && !Address.isFriendly(src)) {
        throw new Error("Unknown address type");
      }
      const data = Buffer.isBuffer(src) ? src : Buffer.from(src, "base64");
      if (data.length !== 36) {
        throw new Error("Unknown address type: byte length is not equal to 36");
      }
      const addr = data.subarray(0, 34);
      const crc = data.subarray(34, 36);
      const calcedCrc = (0, crc16_1.crc16)(addr);
      if (!(calcedCrc[0] === crc[0] && calcedCrc[1] === crc[1])) {
        throw new Error("Invalid checksum: " + src);
      }
      let tag = addr[0];
      let isTestOnly = false;
      let isBounceable = false;
      if (tag & test_flag) {
        isTestOnly = true;
        tag = tag ^ test_flag;
      }
      if (tag !== bounceable_tag && tag !== non_bounceable_tag)
        throw "Unknown address tag";
      isBounceable = tag === bounceable_tag;
      let workchain = null;
      if (addr[1] === 255) {
        workchain = -1;
      } else {
        workchain = addr[1];
      }
      const hashPart = addr.subarray(2, 34);
      return { isTestOnly, isBounceable, workchain, hashPart };
    }
    var Address = class _Address {
      static isAddress(src) {
        return src instanceof _Address;
      }
      static isFriendly(source) {
        if (source.length !== 48) {
          return false;
        }
        if (!/[A-Za-z0-9+/_-]+/.test(source)) {
          return false;
        }
        return true;
      }
      static isRaw(source) {
        if (source.indexOf(":") === -1) {
          return false;
        }
        let [wc, hash] = source.split(":");
        if (!Number.isInteger(parseFloat(wc))) {
          return false;
        }
        if (!/[a-f0-9]+/.test(hash.toLowerCase())) {
          return false;
        }
        if (hash.length !== 64) {
          return false;
        }
        return true;
      }
      static normalize(source) {
        if (typeof source === "string") {
          return _Address.parse(source).toString();
        } else {
          return source.toString();
        }
      }
      static parse(source) {
        if (_Address.isFriendly(source)) {
          return this.parseFriendly(source).address;
        } else if (_Address.isRaw(source)) {
          return this.parseRaw(source);
        } else {
          throw new Error("Unknown address type: " + source);
        }
      }
      static parseRaw(source) {
        let workChain = parseInt(source.split(":")[0]);
        let hash = Buffer.from(source.split(":")[1], "hex");
        return new _Address(workChain, hash);
      }
      static parseFriendly(source) {
        if (Buffer.isBuffer(source)) {
          let r = parseFriendlyAddress(source);
          return {
            isBounceable: r.isBounceable,
            isTestOnly: r.isTestOnly,
            address: new _Address(r.workchain, r.hashPart)
          };
        } else {
          let addr = source.replace(/\-/g, "+").replace(/_/g, "/");
          let r = parseFriendlyAddress(addr);
          return {
            isBounceable: r.isBounceable,
            isTestOnly: r.isTestOnly,
            address: new _Address(r.workchain, r.hashPart)
          };
        }
      }
      constructor(workChain, hash) {
        this.toRawString = () => {
          return this.workChain + ":" + this.hash.toString("hex");
        };
        this.toRaw = () => {
          const addressWithChecksum = Buffer.alloc(36);
          addressWithChecksum.set(this.hash);
          addressWithChecksum.set([this.workChain, this.workChain, this.workChain, this.workChain], 32);
          return addressWithChecksum;
        };
        this.toStringBuffer = (args) => {
          let testOnly = args && args.testOnly !== void 0 ? args.testOnly : false;
          let bounceable = args && args.bounceable !== void 0 ? args.bounceable : true;
          let tag = bounceable ? bounceable_tag : non_bounceable_tag;
          if (testOnly) {
            tag |= test_flag;
          }
          const addr = Buffer.alloc(34);
          addr[0] = tag;
          addr[1] = this.workChain;
          addr.set(this.hash, 2);
          const addressWithChecksum = Buffer.alloc(36);
          addressWithChecksum.set(addr);
          addressWithChecksum.set((0, crc16_1.crc16)(addr), 34);
          return addressWithChecksum;
        };
        this.toString = (args) => {
          let urlSafe = args && args.urlSafe !== void 0 ? args.urlSafe : true;
          let buffer = this.toStringBuffer(args);
          if (urlSafe) {
            return buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_");
          } else {
            return buffer.toString("base64");
          }
        };
        this[_a] = () => this.toString();
        if (hash.length !== 32) {
          throw new Error("Invalid address hash length: " + hash.length);
        }
        this.workChain = workChain;
        this.hash = hash;
        Object.freeze(this);
      }
      equals(src) {
        if (src.workChain !== this.workChain) {
          return false;
        }
        return src.hash.equals(this.hash);
      }
    };
    exports.Address = Address;
    _a = symbol_inspect_1.default;
    function address(src) {
      return Address.parse(src);
    }
    exports.address = address;
  }
});

// node_modules/@ton/core/dist/address/ExternalAddress.js
var require_ExternalAddress = __commonJS({
  "node_modules/@ton/core/dist/address/ExternalAddress.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExternalAddress = void 0;
    var symbol_inspect_1 = __importDefault(require_symbol());
    var ExternalAddress = class _ExternalAddress {
      static isAddress(src) {
        return src instanceof _ExternalAddress;
      }
      constructor(value, bits) {
        this[_a] = () => this.toString();
        this.value = value;
        this.bits = bits;
      }
      toString() {
        return `External<${this.bits}:${this.value}>`;
      }
    };
    exports.ExternalAddress = ExternalAddress;
    _a = symbol_inspect_1.default;
  }
});

// node_modules/@ton/core/dist/utils/base32.js
var require_base32 = __commonJS({
  "node_modules/@ton/core/dist/utils/base32.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.base32Decode = exports.base32Encode = void 0;
    var alphabet = "abcdefghijklmnopqrstuvwxyz234567";
    function base32Encode(buffer) {
      const length = buffer.byteLength;
      let bits = 0;
      let value = 0;
      let output = "";
      for (let i = 0; i < length; i++) {
        value = value << 8 | buffer[i];
        bits += 8;
        while (bits >= 5) {
          output += alphabet[value >>> bits - 5 & 31];
          bits -= 5;
        }
      }
      if (bits > 0) {
        output += alphabet[value << 5 - bits & 31];
      }
      return output;
    }
    exports.base32Encode = base32Encode;
    function readChar(alphabet2, char) {
      const idx = alphabet2.indexOf(char);
      if (idx === -1) {
        throw new Error("Invalid character found: " + char);
      }
      return idx;
    }
    function base32Decode(input) {
      let cleanedInput;
      cleanedInput = input.toLowerCase();
      const { length } = cleanedInput;
      let bits = 0;
      let value = 0;
      let index = 0;
      const output = Buffer.alloc(length * 5 / 8 | 0);
      for (let i = 0; i < length; i++) {
        value = value << 5 | readChar(alphabet, cleanedInput[i]);
        bits += 5;
        if (bits >= 8) {
          output[index++] = value >>> bits - 8 & 255;
          bits -= 8;
        }
      }
      return output;
    }
    exports.base32Decode = base32Decode;
  }
});

// node_modules/@ton/core/dist/address/ADNLAddress.js
var require_ADNLAddress = __commonJS({
  "node_modules/@ton/core/dist/address/ADNLAddress.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ADNLAddress = void 0;
    var symbol_inspect_1 = __importDefault(require_symbol());
    var base32_1 = require_base32();
    var crc16_1 = require_crc16();
    var ADNLAddress = class _ADNLAddress {
      static parseFriendly(src) {
        if (src.length !== 55) {
          throw Error("Invalid address");
        }
        src = "f" + src;
        let decoded = (0, base32_1.base32Decode)(src);
        if (decoded[0] !== 45) {
          throw Error("Invalid address");
        }
        let gotHash = decoded.slice(33);
        let hash = (0, crc16_1.crc16)(decoded.slice(0, 33));
        if (!hash.equals(gotHash)) {
          throw Error("Invalid address");
        }
        return new _ADNLAddress(decoded.slice(1, 33));
      }
      static parseRaw(src) {
        const data = Buffer.from(src, "base64");
        return new _ADNLAddress(data);
      }
      constructor(address) {
        this.toRaw = () => {
          return this.address.toString("hex").toUpperCase();
        };
        this.toString = () => {
          let data = Buffer.concat([Buffer.from([45]), this.address]);
          let hash = (0, crc16_1.crc16)(data);
          data = Buffer.concat([data, hash]);
          return (0, base32_1.base32Encode)(data).slice(1);
        };
        this[_a] = () => this.toString();
        if (address.length !== 32) {
          throw Error("Invalid address");
        }
        this.address = address;
      }
      equals(b) {
        return this.address.equals(b.address);
      }
    };
    exports.ADNLAddress = ADNLAddress;
    _a = symbol_inspect_1.default;
  }
});

// node_modules/@ton/core/dist/boc/utils/paddedBits.js
var require_paddedBits = __commonJS({
  "node_modules/@ton/core/dist/boc/utils/paddedBits.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.paddedBufferToBits = exports.bitsToPaddedBuffer = void 0;
    var BitBuilder_1 = require_BitBuilder();
    var BitString_1 = require_BitString();
    function bitsToPaddedBuffer(bits) {
      let builder = new BitBuilder_1.BitBuilder(Math.ceil(bits.length / 8) * 8);
      builder.writeBits(bits);
      let padding = Math.ceil(bits.length / 8) * 8 - bits.length;
      for (let i = 0; i < padding; i++) {
        if (i === 0) {
          builder.writeBit(1);
        } else {
          builder.writeBit(0);
        }
      }
      return builder.buffer();
    }
    exports.bitsToPaddedBuffer = bitsToPaddedBuffer;
    function paddedBufferToBits(buff) {
      let bitLen = 0;
      for (let i = buff.length - 1; i >= 0; i--) {
        if (buff[i] !== 0) {
          const testByte = buff[i];
          let bitPos = testByte & -testByte;
          if ((bitPos & 1) == 0) {
            bitPos = Math.log2(bitPos) + 1;
          }
          if (i > 0) {
            bitLen = i << 3;
          }
          bitLen += 8 - bitPos;
          break;
        }
      }
      return new BitString_1.BitString(buff, 0, bitLen);
    }
    exports.paddedBufferToBits = paddedBufferToBits;
  }
});

// node_modules/@ton/core/dist/boc/BitString.js
var require_BitString = __commonJS({
  "node_modules/@ton/core/dist/boc/BitString.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitString = void 0;
    var paddedBits_1 = require_paddedBits();
    var symbol_inspect_1 = __importDefault(require_symbol());
    var BitString = class _BitString {
      /**
       * Checks if supplied object is BitString
       * @param src is unknow object
       * @returns true if object is BitString and false otherwise
       **/
      static isBitString(src) {
        return src instanceof _BitString;
      }
      /**
       * Constructing BitString from a buffer
       * @param data data that contains the bitstring data. NOTE: We are expecting this buffer to be NOT modified
       * @param offset offset in bits from the start of the buffer
       * @param length length of the bitstring in bits
       */
      constructor(data, offset, length) {
        this[_a] = () => this.toString();
        if (length < 0) {
          throw new Error(`Length ${length} is out of bounds`);
        }
        this._length = length;
        this._data = data;
        this._offset = offset;
      }
      /**
       * Returns the length of the bitstring
       */
      get length() {
        return this._length;
      }
      /**
       * Returns the bit at the specified index
       * @param index index of the bit
       * @throws Error if index is out of bounds
       * @returns true if the bit is set, false otherwise
       */
      at(index) {
        if (index >= this._length) {
          throw new Error(`Index ${index} > ${this._length} is out of bounds`);
        }
        if (index < 0) {
          throw new Error(`Index ${index} < 0 is out of bounds`);
        }
        let byteIndex = this._offset + index >> 3;
        let bitIndex = 7 - (this._offset + index) % 8;
        return (this._data[byteIndex] & 1 << bitIndex) !== 0;
      }
      /**
       * Get a subscring of the bitstring
       * @param offset
       * @param length
       * @returns
       */
      substring(offset, length) {
        if (offset > this._length) {
          throw new Error(`Offset(${offset}) > ${this._length} is out of bounds`);
        }
        if (offset < 0) {
          throw new Error(`Offset(${offset}) < 0 is out of bounds`);
        }
        if (length === 0) {
          return _BitString.EMPTY;
        }
        if (offset + length > this._length) {
          throw new Error(`Offset ${offset} + Length ${length} > ${this._length} is out of bounds`);
        }
        return new _BitString(this._data, this._offset + offset, length);
      }
      /**
       * Try to get a buffer from the bitstring without allocations
       * @param offset offset in bits
       * @param length length in bits
       * @returns buffer if the bitstring is aligned to bytes, null otherwise
       */
      subbuffer(offset, length) {
        if (offset > this._length) {
          throw new Error(`Offset ${offset} is out of bounds`);
        }
        if (offset < 0) {
          throw new Error(`Offset ${offset} is out of bounds`);
        }
        if (offset + length > this._length) {
          throw new Error(`Offset + Lenght = ${offset + length} is out of bounds`);
        }
        if (length % 8 !== 0) {
          return null;
        }
        if ((this._offset + offset) % 8 !== 0) {
          return null;
        }
        let start = this._offset + offset >> 3;
        let end = start + (length >> 3);
        return this._data.subarray(start, end);
      }
      /**
       * Checks for equality
       * @param b other bitstring
       * @returns true if the bitstrings are equal, false otherwise
       */
      equals(b) {
        if (this._length !== b._length) {
          return false;
        }
        for (let i = 0; i < this._length; i++) {
          if (this.at(i) !== b.at(i)) {
            return false;
          }
        }
        return true;
      }
      /**
       * Format to canonical string
       * @returns formatted bits as a string
       */
      toString() {
        const padded = (0, paddedBits_1.bitsToPaddedBuffer)(this);
        if (this._length % 4 === 0) {
          const s = padded.subarray(0, Math.ceil(this._length / 8)).toString("hex").toUpperCase();
          if (this._length % 8 === 0) {
            return s;
          } else {
            return s.substring(0, s.length - 1);
          }
        } else {
          const hex = padded.toString("hex").toUpperCase();
          if (this._length % 8 <= 4) {
            return hex.substring(0, hex.length - 1) + "_";
          } else {
            return hex + "_";
          }
        }
      }
    };
    exports.BitString = BitString;
    _a = symbol_inspect_1.default;
    BitString.EMPTY = new BitString(Buffer.alloc(0), 0, 0);
  }
});

// node_modules/@ton/core/dist/boc/BitBuilder.js
var require_BitBuilder = __commonJS({
  "node_modules/@ton/core/dist/boc/BitBuilder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitBuilder = void 0;
    var Address_1 = require_Address();
    var ExternalAddress_1 = require_ExternalAddress();
    var BitString_1 = require_BitString();
    var BitBuilder = class {
      constructor(size = 1023) {
        this._buffer = Buffer.alloc(Math.ceil(size / 8));
        this._length = 0;
      }
      /**
       * Current number of bits written
       */
      get length() {
        return this._length;
      }
      /**
       * Write a single bit
       * @param value bit to write, true or positive number for 1, false or zero or negative for 0
       */
      writeBit(value) {
        let n = this._length;
        if (n > this._buffer.length * 8) {
          throw new Error("BitBuilder overflow");
        }
        if (typeof value === "boolean" && value === true || typeof value === "number" && value > 0) {
          this._buffer[n / 8 | 0] |= 1 << 7 - n % 8;
        }
        this._length++;
      }
      /**
       * Copy bits from BitString
       * @param src source bits
       */
      writeBits(src) {
        for (let i = 0; i < src.length; i++) {
          this.writeBit(src.at(i));
        }
      }
      /**
       * Write bits from buffer
       * @param src source buffer
       */
      writeBuffer(src) {
        if (this._length % 8 === 0) {
          if (this._length + src.length * 8 > this._buffer.length * 8) {
            throw new Error("BitBuilder overflow");
          }
          src.copy(this._buffer, this._length / 8);
          this._length += src.length * 8;
        } else {
          for (let i = 0; i < src.length; i++) {
            this.writeUint(src[i], 8);
          }
        }
      }
      /**
       * Write uint value
       * @param value value as bigint or number
       * @param bits number of bits to write
       */
      writeUint(value, bits) {
        if (bits < 0 || !Number.isSafeInteger(bits)) {
          throw Error(`invalid bit length. Got ${bits}`);
        }
        const v = BigInt(value);
        if (bits === 0) {
          if (v !== 0n) {
            throw Error(`value is not zero for ${bits} bits. Got ${value}`);
          } else {
            return;
          }
        }
        const vBits = 1n << BigInt(bits);
        if (v < 0 || v >= vBits) {
          throw Error(`bitLength is too small for a value ${value}. Got ${bits}`);
        }
        if (this._length + bits > this._buffer.length * 8) {
          throw new Error("BitBuilder overflow");
        }
        const tillByte = 8 - this._length % 8;
        if (tillByte > 0) {
          const bidx = Math.floor(this._length / 8);
          if (bits < tillByte) {
            const wb = Number(v);
            this._buffer[bidx] |= wb << tillByte - bits;
            this._length += bits;
          } else {
            const wb = Number(v >> BigInt(bits - tillByte));
            this._buffer[bidx] |= wb;
            this._length += tillByte;
          }
        }
        bits -= tillByte;
        while (bits > 0) {
          if (bits >= 8) {
            this._buffer[this._length / 8] = Number(v >> BigInt(bits - 8) & 0xffn);
            this._length += 8;
            bits -= 8;
          } else {
            this._buffer[this._length / 8] = Number(v << BigInt(8 - bits) & 0xffn);
            this._length += bits;
            bits = 0;
          }
        }
      }
      /**
       * Write int value
       * @param value value as bigint or number
       * @param bits number of bits to write
       */
      writeInt(value, bits) {
        let v = BigInt(value);
        if (bits < 0 || !Number.isSafeInteger(bits)) {
          throw Error(`invalid bit length. Got ${bits}`);
        }
        if (bits === 0) {
          if (value !== 0n) {
            throw Error(`value is not zero for ${bits} bits. Got ${value}`);
          } else {
            return;
          }
        }
        if (bits === 1) {
          if (value !== -1n && value !== 0n) {
            throw Error(`value is not zero or -1 for ${bits} bits. Got ${value}`);
          } else {
            this.writeBit(value === -1n);
            return;
          }
        }
        let vBits = 1n << BigInt(bits) - 1n;
        if (v < -vBits || v >= vBits) {
          throw Error(`value is out of range for ${bits} bits. Got ${value}`);
        }
        if (v < 0) {
          this.writeBit(true);
          v = vBits + v;
        } else {
          this.writeBit(false);
        }
        this.writeUint(v, bits - 1);
      }
      /**
       * Wrtie var uint value, used for serializing coins
       * @param value value to write as bigint or number
       * @param bits header bits to write size
       */
      writeVarUint(value, bits) {
        let v = BigInt(value);
        if (bits < 0 || !Number.isSafeInteger(bits)) {
          throw Error(`invalid bit length. Got ${bits}`);
        }
        if (v < 0) {
          throw Error(`value is negative. Got ${value}`);
        }
        if (v === 0n) {
          this.writeUint(0, bits);
          return;
        }
        const sizeBytes = Math.ceil(v.toString(2).length / 8);
        const sizeBits = sizeBytes * 8;
        this.writeUint(sizeBytes, bits);
        this.writeUint(v, sizeBits);
      }
      /**
       * Wrtie var int value, used for serializing coins
       * @param value value to write as bigint or number
       * @param bits header bits to write size
       */
      writeVarInt(value, bits) {
        let v = BigInt(value);
        if (bits < 0 || !Number.isSafeInteger(bits)) {
          throw Error(`invalid bit length. Got ${bits}`);
        }
        if (v === 0n) {
          this.writeUint(0, bits);
          return;
        }
        let v2 = v > 0 ? v : -v;
        const sizeBytes = 1 + Math.ceil(v2.toString(2).length / 8);
        const sizeBits = sizeBytes * 8;
        this.writeUint(sizeBytes, bits);
        this.writeInt(v, sizeBits);
      }
      /**
       * Write coins in var uint format
       * @param amount amount to write
       */
      writeCoins(amount) {
        this.writeVarUint(amount, 4);
      }
      /**
       * Write address
       * @param address write address or address external
       */
      writeAddress(address) {
        if (address === null || address === void 0) {
          this.writeUint(0, 2);
          return;
        }
        if (Address_1.Address.isAddress(address)) {
          this.writeUint(2, 2);
          this.writeUint(0, 1);
          this.writeInt(address.workChain, 8);
          this.writeBuffer(address.hash);
          return;
        }
        if (ExternalAddress_1.ExternalAddress.isAddress(address)) {
          this.writeUint(1, 2);
          this.writeUint(address.bits, 9);
          this.writeUint(address.value, address.bits);
          return;
        }
        throw Error(`Invalid address. Got ${address}`);
      }
      /**
       * Build BitString
       * @returns result bit string
       */
      build() {
        return new BitString_1.BitString(this._buffer, 0, this._length);
      }
      /**
       * Build into Buffer
       * @returns result buffer
       */
      buffer() {
        if (this._length % 8 !== 0) {
          throw new Error("BitBuilder buffer is not byte aligned");
        }
        return this._buffer.subarray(0, this._length / 8);
      }
    };
    exports.BitBuilder = BitBuilder;
  }
});

// node_modules/@ton/core/dist/boc/CellType.js
var require_CellType = __commonJS({
  "node_modules/@ton/core/dist/boc/CellType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CellType = void 0;
    var CellType;
    (function(CellType2) {
      CellType2[CellType2["Ordinary"] = -1] = "Ordinary";
      CellType2[CellType2["PrunedBranch"] = 1] = "PrunedBranch";
      CellType2[CellType2["Library"] = 2] = "Library";
      CellType2[CellType2["MerkleProof"] = 3] = "MerkleProof";
      CellType2[CellType2["MerkleUpdate"] = 4] = "MerkleUpdate";
    })(CellType || (exports.CellType = CellType = {}));
  }
});

// node_modules/@ton/core/dist/dict/utils/readUnaryLength.js
var require_readUnaryLength = __commonJS({
  "node_modules/@ton/core/dist/dict/utils/readUnaryLength.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readUnaryLength = void 0;
    function readUnaryLength(slice) {
      let res = 0;
      while (slice.loadBit()) {
        res++;
      }
      return res;
    }
    exports.readUnaryLength = readUnaryLength;
  }
});

// node_modules/@ton/core/dist/dict/generateMerkleProof.js
var require_generateMerkleProof = __commonJS({
  "node_modules/@ton/core/dist/dict/generateMerkleProof.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateMerkleProof = void 0;
    var Builder_1 = require_Builder();
    var readUnaryLength_1 = require_readUnaryLength();
    function convertToPrunedBranch(c) {
      return (0, Builder_1.beginCell)().storeUint(1, 8).storeUint(1, 8).storeBuffer(c.hash(0)).storeUint(c.depth(0), 16).endCell({ exotic: true });
    }
    function convertToMerkleProof(c) {
      return (0, Builder_1.beginCell)().storeUint(3, 8).storeBuffer(c.hash(0)).storeUint(c.depth(0), 16).storeRef(c).endCell({ exotic: true });
    }
    function doGenerateMerkleProof(prefix, slice, n, key) {
      const originalCell = slice.asCell();
      let lb0 = slice.loadBit() ? 1 : 0;
      let prefixLength = 0;
      let pp = prefix;
      if (lb0 === 0) {
        prefixLength = (0, readUnaryLength_1.readUnaryLength)(slice);
        for (let i = 0; i < prefixLength; i++) {
          pp += slice.loadBit() ? "1" : "0";
        }
      } else {
        let lb1 = slice.loadBit() ? 1 : 0;
        if (lb1 === 0) {
          prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
          for (let i = 0; i < prefixLength; i++) {
            pp += slice.loadBit() ? "1" : "0";
          }
        } else {
          let bit = slice.loadBit() ? "1" : "0";
          prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
          for (let i = 0; i < prefixLength; i++) {
            pp += bit;
          }
        }
      }
      if (n - prefixLength === 0) {
        return originalCell;
      } else {
        let sl = originalCell.beginParse();
        let left = sl.loadRef();
        let right = sl.loadRef();
        if (!left.isExotic) {
          if (pp + "0" === key.slice(0, pp.length + 1)) {
            left = doGenerateMerkleProof(pp + "0", left.beginParse(), n - prefixLength - 1, key);
          } else {
            left = convertToPrunedBranch(left);
          }
        }
        if (!right.isExotic) {
          if (pp + "1" === key.slice(0, pp.length + 1)) {
            right = doGenerateMerkleProof(pp + "1", right.beginParse(), n - prefixLength - 1, key);
          } else {
            right = convertToPrunedBranch(right);
          }
        }
        return (0, Builder_1.beginCell)().storeSlice(sl).storeRef(left).storeRef(right).endCell();
      }
    }
    function generateMerkleProof(dict, key, keyObject) {
      const s = (0, Builder_1.beginCell)().storeDictDirect(dict).endCell().beginParse();
      return convertToMerkleProof(doGenerateMerkleProof("", s, keyObject.bits, keyObject.serialize(key).toString(2).padStart(keyObject.bits, "0")));
    }
    exports.generateMerkleProof = generateMerkleProof;
  }
});

// node_modules/@ton/core/dist/dict/generateMerkleUpdate.js
var require_generateMerkleUpdate = __commonJS({
  "node_modules/@ton/core/dist/dict/generateMerkleUpdate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateMerkleUpdate = void 0;
    var Builder_1 = require_Builder();
    var generateMerkleProof_1 = require_generateMerkleProof();
    function convertToMerkleUpdate(c1, c2) {
      return (0, Builder_1.beginCell)().storeUint(4, 8).storeBuffer(c1.hash(0)).storeBuffer(c2.hash(0)).storeUint(c1.depth(0), 16).storeUint(c2.depth(0), 16).storeRef(c1).storeRef(c2).endCell({ exotic: true });
    }
    function generateMerkleUpdate(dict, key, keyObject, newValue) {
      const oldProof = (0, generateMerkleProof_1.generateMerkleProof)(dict, key, keyObject).refs[0];
      dict.set(key, newValue);
      const newProof = (0, generateMerkleProof_1.generateMerkleProof)(dict, key, keyObject).refs[0];
      return convertToMerkleUpdate(oldProof, newProof);
    }
    exports.generateMerkleUpdate = generateMerkleUpdate;
  }
});

// node_modules/@ton/core/dist/dict/parseDict.js
var require_parseDict = __commonJS({
  "node_modules/@ton/core/dist/dict/parseDict.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseDict = void 0;
    function readUnaryLength(slice) {
      let res = 0;
      while (slice.loadBit()) {
        res++;
      }
      return res;
    }
    function doParse(prefix, slice, n, res, extractor) {
      let lb0 = slice.loadBit() ? 1 : 0;
      let prefixLength = 0;
      let pp = prefix;
      if (lb0 === 0) {
        prefixLength = readUnaryLength(slice);
        for (let i = 0; i < prefixLength; i++) {
          pp += slice.loadBit() ? "1" : "0";
        }
      } else {
        let lb1 = slice.loadBit() ? 1 : 0;
        if (lb1 === 0) {
          prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
          for (let i = 0; i < prefixLength; i++) {
            pp += slice.loadBit() ? "1" : "0";
          }
        } else {
          let bit = slice.loadBit() ? "1" : "0";
          prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
          for (let i = 0; i < prefixLength; i++) {
            pp += bit;
          }
        }
      }
      if (n - prefixLength === 0) {
        res.set(BigInt("0b" + pp), extractor(slice));
      } else {
        let left = slice.loadRef();
        let right = slice.loadRef();
        if (!left.isExotic) {
          doParse(pp + "0", left.beginParse(), n - prefixLength - 1, res, extractor);
        }
        if (!right.isExotic) {
          doParse(pp + "1", right.beginParse(), n - prefixLength - 1, res, extractor);
        }
      }
    }
    function parseDict(sc, keySize, extractor) {
      let res = /* @__PURE__ */ new Map();
      if (sc) {
        doParse("", sc, keySize, res, extractor);
      }
      return res;
    }
    exports.parseDict = parseDict;
  }
});

// node_modules/@ton/core/dist/dict/utils/findCommonPrefix.js
var require_findCommonPrefix = __commonJS({
  "node_modules/@ton/core/dist/dict/utils/findCommonPrefix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findCommonPrefix = void 0;
    function findCommonPrefix(src, startPos = 0) {
      if (src.length === 0) {
        return "";
      }
      let r = src[0].slice(startPos);
      for (let i = 1; i < src.length; i++) {
        const s = src[i];
        while (s.indexOf(r, startPos) !== startPos) {
          r = r.substring(0, r.length - 1);
          if (r === "") {
            return r;
          }
        }
      }
      return r;
    }
    exports.findCommonPrefix = findCommonPrefix;
  }
});

// node_modules/@ton/core/dist/dict/serializeDict.js
var require_serializeDict = __commonJS({
  "node_modules/@ton/core/dist/dict/serializeDict.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeDict = exports.detectLabelType = exports.writeLabelSame = exports.writeLabelLong = exports.writeLabelShort = exports.buildTree = void 0;
    var Builder_1 = require_Builder();
    var findCommonPrefix_1 = require_findCommonPrefix();
    function pad(src, size) {
      while (src.length < size) {
        src = "0" + src;
      }
      return src;
    }
    function forkMap(src, prefixLen) {
      if (src.size === 0) {
        throw Error("Internal inconsistency");
      }
      let left = /* @__PURE__ */ new Map();
      let right = /* @__PURE__ */ new Map();
      for (let [k, d] of src.entries()) {
        if (k[prefixLen] === "0") {
          left.set(k, d);
        } else {
          right.set(k, d);
        }
      }
      if (left.size === 0) {
        throw Error("Internal inconsistency. Left emtpy.");
      }
      if (right.size === 0) {
        throw Error("Internal inconsistency. Right emtpy.");
      }
      return { left, right };
    }
    function buildNode(src, prefixLen) {
      if (src.size === 0) {
        throw Error("Internal inconsistency");
      }
      if (src.size === 1) {
        return { type: "leaf", value: Array.from(src.values())[0] };
      }
      let { left, right } = forkMap(src, prefixLen);
      return {
        type: "fork",
        left: buildEdge(left, prefixLen + 1),
        right: buildEdge(right, prefixLen + 1)
      };
    }
    function buildEdge(src, prefixLen = 0) {
      if (src.size === 0) {
        throw Error("Internal inconsistency");
      }
      const label = (0, findCommonPrefix_1.findCommonPrefix)(Array.from(src.keys()), prefixLen);
      return { label, node: buildNode(src, label.length + prefixLen) };
    }
    function buildTree(src, keyLength) {
      let converted = /* @__PURE__ */ new Map();
      for (let k of Array.from(src.keys())) {
        const padded = pad(k.toString(2), keyLength);
        converted.set(padded, src.get(k));
      }
      return buildEdge(converted);
    }
    exports.buildTree = buildTree;
    function writeLabelShort(src, to) {
      to.storeBit(0);
      for (let i = 0; i < src.length; i++) {
        to.storeBit(1);
      }
      to.storeBit(0);
      if (src.length > 0) {
        to.storeUint(BigInt("0b" + src), src.length);
      }
      return to;
    }
    exports.writeLabelShort = writeLabelShort;
    function labelShortLength(src) {
      return 1 + src.length + 1 + src.length;
    }
    function writeLabelLong(src, keyLength, to) {
      to.storeBit(1);
      to.storeBit(0);
      let length = Math.ceil(Math.log2(keyLength + 1));
      to.storeUint(src.length, length);
      if (src.length > 0) {
        to.storeUint(BigInt("0b" + src), src.length);
      }
      return to;
    }
    exports.writeLabelLong = writeLabelLong;
    function labelLongLength(src, keyLength) {
      return 1 + 1 + Math.ceil(Math.log2(keyLength + 1)) + src.length;
    }
    function writeLabelSame(value, length, keyLength, to) {
      to.storeBit(1);
      to.storeBit(1);
      to.storeBit(value);
      let lenLen = Math.ceil(Math.log2(keyLength + 1));
      to.storeUint(length, lenLen);
    }
    exports.writeLabelSame = writeLabelSame;
    function labelSameLength(keyLength) {
      return 1 + 1 + 1 + Math.ceil(Math.log2(keyLength + 1));
    }
    function isSame(src) {
      if (src.length === 0 || src.length === 1) {
        return true;
      }
      for (let i = 1; i < src.length; i++) {
        if (src[i] !== src[0]) {
          return false;
        }
      }
      return true;
    }
    function detectLabelType(src, keyLength) {
      let kind = "short";
      let kindLength = labelShortLength(src);
      let longLength = labelLongLength(src, keyLength);
      if (longLength < kindLength) {
        kindLength = longLength;
        kind = "long";
      }
      if (isSame(src)) {
        let sameLength = labelSameLength(keyLength);
        if (sameLength < kindLength) {
          kindLength = sameLength;
          kind = "same";
        }
      }
      return kind;
    }
    exports.detectLabelType = detectLabelType;
    function writeLabel(src, keyLength, to) {
      let type = detectLabelType(src, keyLength);
      if (type === "short") {
        writeLabelShort(src, to);
      } else if (type === "long") {
        writeLabelLong(src, keyLength, to);
      } else if (type === "same") {
        writeLabelSame(src[0] === "1", src.length, keyLength, to);
      }
    }
    function writeNode(src, keyLength, serializer, to) {
      if (src.type === "leaf") {
        serializer(src.value, to);
      }
      if (src.type === "fork") {
        const leftCell = (0, Builder_1.beginCell)();
        const rightCell = (0, Builder_1.beginCell)();
        writeEdge(src.left, keyLength - 1, serializer, leftCell);
        writeEdge(src.right, keyLength - 1, serializer, rightCell);
        to.storeRef(leftCell);
        to.storeRef(rightCell);
      }
    }
    function writeEdge(src, keyLength, serializer, to) {
      writeLabel(src.label, keyLength, to);
      writeNode(src.node, keyLength - src.label.length, serializer, to);
    }
    function serializeDict(src, keyLength, serializer, to) {
      const tree = buildTree(src, keyLength);
      writeEdge(tree, keyLength, serializer, to);
    }
    exports.serializeDict = serializeDict;
  }
});

// node_modules/@ton/core/dist/dict/utils/internalKeySerializer.js
var require_internalKeySerializer = __commonJS({
  "node_modules/@ton/core/dist/dict/utils/internalKeySerializer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserializeInternalKey = exports.serializeInternalKey = void 0;
    var Address_1 = require_Address();
    var BitString_1 = require_BitString();
    var paddedBits_1 = require_paddedBits();
    function serializeInternalKey(value) {
      if (typeof value === "number") {
        if (!Number.isSafeInteger(value)) {
          throw Error("Invalid key type: not a safe integer: " + value);
        }
        return "n:" + value.toString(10);
      } else if (typeof value === "bigint") {
        return "b:" + value.toString(10);
      } else if (Address_1.Address.isAddress(value)) {
        return "a:" + value.toString();
      } else if (Buffer.isBuffer(value)) {
        return "f:" + value.toString("hex");
      } else if (BitString_1.BitString.isBitString(value)) {
        return "B:" + value.toString();
      } else {
        throw Error("Invalid key type");
      }
    }
    exports.serializeInternalKey = serializeInternalKey;
    function deserializeInternalKey(value) {
      let k = value.slice(0, 2);
      let v = value.slice(2);
      if (k === "n:") {
        return parseInt(v, 10);
      } else if (k === "b:") {
        return BigInt(v);
      } else if (k === "a:") {
        return Address_1.Address.parse(v);
      } else if (k === "f:") {
        return Buffer.from(v, "hex");
      } else if (k === "B:") {
        const lastDash = v.slice(-1) == "_";
        const isPadded = lastDash || v.length % 2 != 0;
        if (isPadded) {
          let charLen = lastDash ? v.length - 1 : v.length;
          const padded = v.substr(0, charLen) + "0";
          if (!lastDash && (charLen & 1) !== 0) {
            return new BitString_1.BitString(Buffer.from(padded, "hex"), 0, charLen << 2);
          } else {
            return (0, paddedBits_1.paddedBufferToBits)(Buffer.from(padded, "hex"));
          }
        } else {
          return new BitString_1.BitString(Buffer.from(v, "hex"), 0, v.length << 2);
        }
      }
      throw Error("Invalid key type: " + k);
    }
    exports.deserializeInternalKey = deserializeInternalKey;
  }
});

// node_modules/@ton/core/dist/dict/Dictionary.js
var require_Dictionary = __commonJS({
  "node_modules/@ton/core/dist/dict/Dictionary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Dictionary = void 0;
    var Address_1 = require_Address();
    var Builder_1 = require_Builder();
    var Cell_1 = require_Cell();
    var BitString_1 = require_BitString();
    var generateMerkleProof_1 = require_generateMerkleProof();
    var generateMerkleUpdate_1 = require_generateMerkleUpdate();
    var parseDict_1 = require_parseDict();
    var serializeDict_1 = require_serializeDict();
    var internalKeySerializer_1 = require_internalKeySerializer();
    var Dictionary = class _Dictionary {
      /**
       * Create an empty map
       * @param key key type
       * @param value value type
       * @returns Dictionary<K, V>
       */
      static empty(key, value) {
        if (key && value) {
          return new _Dictionary(/* @__PURE__ */ new Map(), key, value);
        } else {
          return new _Dictionary(/* @__PURE__ */ new Map(), null, null);
        }
      }
      /**
       * Load dictionary from slice
       * @param key key description
       * @param value value description
       * @param src slice
       * @returns Dictionary<K, V>
       */
      static load(key, value, sc) {
        let slice;
        if (sc instanceof Cell_1.Cell) {
          if (sc.isExotic) {
            return _Dictionary.empty(key, value);
          }
          slice = sc.beginParse();
        } else {
          slice = sc;
        }
        let cell = slice.loadMaybeRef();
        if (cell && !cell.isExotic) {
          return _Dictionary.loadDirect(key, value, cell.beginParse());
        } else {
          return _Dictionary.empty(key, value);
        }
      }
      /**
       * Low level method for rare dictionaries from system contracts.
       * Loads dictionary from slice directly without going to the ref.
       *
       * @param key key description
       * @param value value description
       * @param sc slice
       * @returns Dictionary<K, V>
       */
      static loadDirect(key, value, sc) {
        if (!sc) {
          return _Dictionary.empty(key, value);
        }
        let slice;
        if (sc instanceof Cell_1.Cell) {
          slice = sc.beginParse();
        } else {
          slice = sc;
        }
        let values = (0, parseDict_1.parseDict)(slice, key.bits, value.parse);
        let prepare = /* @__PURE__ */ new Map();
        for (let [k, v] of values) {
          prepare.set((0, internalKeySerializer_1.serializeInternalKey)(key.parse(k)), v);
        }
        return new _Dictionary(prepare, key, value);
      }
      constructor(values, key, value) {
        this._key = key;
        this._value = value;
        this._map = values;
      }
      get size() {
        return this._map.size;
      }
      get(key) {
        return this._map.get((0, internalKeySerializer_1.serializeInternalKey)(key));
      }
      has(key) {
        return this._map.has((0, internalKeySerializer_1.serializeInternalKey)(key));
      }
      set(key, value) {
        this._map.set((0, internalKeySerializer_1.serializeInternalKey)(key), value);
        return this;
      }
      delete(key) {
        const k = (0, internalKeySerializer_1.serializeInternalKey)(key);
        return this._map.delete(k);
      }
      clear() {
        this._map.clear();
      }
      *[Symbol.iterator]() {
        for (const [k, v] of this._map) {
          const key = (0, internalKeySerializer_1.deserializeInternalKey)(k);
          yield [key, v];
        }
      }
      keys() {
        return Array.from(this._map.keys()).map((v) => (0, internalKeySerializer_1.deserializeInternalKey)(v));
      }
      values() {
        return Array.from(this._map.values());
      }
      store(builder, key, value) {
        if (this._map.size === 0) {
          builder.storeBit(0);
        } else {
          let resolvedKey = this._key;
          if (key !== null && key !== void 0) {
            resolvedKey = key;
          }
          let resolvedValue = this._value;
          if (value !== null && value !== void 0) {
            resolvedValue = value;
          }
          if (!resolvedKey) {
            throw Error("Key serializer is not defined");
          }
          if (!resolvedValue) {
            throw Error("Value serializer is not defined");
          }
          let prepared = /* @__PURE__ */ new Map();
          for (const [k, v] of this._map) {
            prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v);
          }
          builder.storeBit(1);
          let dd = (0, Builder_1.beginCell)();
          (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, dd);
          builder.storeRef(dd.endCell());
        }
      }
      storeDirect(builder, key, value) {
        if (this._map.size === 0) {
          throw Error("Cannot store empty dictionary directly");
        }
        let resolvedKey = this._key;
        if (key !== null && key !== void 0) {
          resolvedKey = key;
        }
        let resolvedValue = this._value;
        if (value !== null && value !== void 0) {
          resolvedValue = value;
        }
        if (!resolvedKey) {
          throw Error("Key serializer is not defined");
        }
        if (!resolvedValue) {
          throw Error("Value serializer is not defined");
        }
        let prepared = /* @__PURE__ */ new Map();
        for (const [k, v] of this._map) {
          prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v);
        }
        (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, builder);
      }
      generateMerkleProof(key) {
        return (0, generateMerkleProof_1.generateMerkleProof)(this, key, this._key);
      }
      generateMerkleUpdate(key, newValue) {
        return (0, generateMerkleUpdate_1.generateMerkleUpdate)(this, key, this._key, newValue);
      }
    };
    exports.Dictionary = Dictionary;
    Dictionary.Keys = {
      /**
       * Standard address key
       * @returns DictionaryKey<Address>
       */
      Address: () => {
        return createAddressKey();
      },
      /**
       * Create standard big integer key
       * @param bits number of bits
       * @returns DictionaryKey<bigint>
       */
      BigInt: (bits) => {
        return createBigIntKey(bits);
      },
      /**
       * Create integer key
       * @param bits bits of integer
       * @returns DictionaryKey<number>
       */
      Int: (bits) => {
        return createIntKey(bits);
      },
      /**
       * Create standard unsigned big integer key
       * @param bits number of bits
       * @returns DictionaryKey<bigint>
       */
      BigUint: (bits) => {
        return createBigUintKey(bits);
      },
      /**
       * Create standard unsigned integer key
       * @param bits number of bits
       * @returns DictionaryKey<number>
       */
      Uint: (bits) => {
        return createUintKey(bits);
      },
      /**
       * Create standard buffer key
       * @param bytes number of bytes of a buffer
       * @returns DictionaryKey<Buffer>
       */
      Buffer: (bytes) => {
        return createBufferKey(bytes);
      },
      /**
       * Create BitString key
       * @param bits key length
       * @returns DictionaryKey<BitString>
       * Point is that Buffer has to be 8 bit aligned,
       * while key is TVM dictionary doesn't have to be
       * aligned at all.
       */
      BitString: (bits) => {
        return createBitStringKey(bits);
      }
    };
    Dictionary.Values = {
      /**
       * Create standard integer value
       * @returns DictionaryValue<bigint>
       */
      BigInt: (bits) => {
        return createBigIntValue(bits);
      },
      /**
       * Create standard integer value
       * @returns DictionaryValue<number>
       */
      Int: (bits) => {
        return createIntValue(bits);
      },
      /**
       * Create big var int
       * @param bits nubmer of header bits
       * @returns DictionaryValue<bigint>
       */
      BigVarInt: (bits) => {
        return createBigVarIntValue(bits);
      },
      /**
       * Create standard unsigned integer value
       * @param bits number of bits
       * @returns DictionaryValue<bigint>
       */
      BigUint: (bits) => {
        return createBigUintValue(bits);
      },
      /**
       * Create standard unsigned integer value
       * @param bits number of bits
       * @returns DictionaryValue<bigint>
       */
      Uint: (bits) => {
        return createUintValue(bits);
      },
      /**
       * Create big var int
       * @param bits nubmer of header bits
       * @returns DictionaryValue<bigint>
       */
      BigVarUint: (bits) => {
        return createBigVarUintValue(bits);
      },
      /**
       * Create standard boolean value
       * @returns DictionaryValue<boolean>
       */
      Bool: () => {
        return createBooleanValue();
      },
      /**
       * Create standard address value
       * @returns DictionaryValue<Address>
       */
      Address: () => {
        return createAddressValue();
      },
      /**
       * Create standard cell value
       * @returns DictionaryValue<Cell>
       */
      Cell: () => {
        return createCellValue();
      },
      /**
       * Create Builder value
       * @param bytes number of bytes of a buffer
       * @returns DictionaryValue<Builder>
       */
      Buffer: (bytes) => {
        return createBufferValue(bytes);
      },
      /**
       * Create BitString value
       * @param requested bit length
       * @returns DictionaryValue<BitString>
       * Point is that Buffer is not applicable
       * when length is not 8 bit alligned.
       */
      BitString: (bits) => {
        return createBitStringValue(bits);
      },
      /**
       * Create dictionary value
       * @param key
       * @param value
       */
      Dictionary: (key, value) => {
        return createDictionaryValue(key, value);
      }
    };
    function createAddressKey() {
      return {
        bits: 267,
        serialize: (src) => {
          if (!Address_1.Address.isAddress(src)) {
            throw Error("Key is not an address");
          }
          return (0, Builder_1.beginCell)().storeAddress(src).endCell().beginParse().preloadUintBig(267);
        },
        parse: (src) => {
          return (0, Builder_1.beginCell)().storeUint(src, 267).endCell().beginParse().loadAddress();
        }
      };
    }
    function createBigIntKey(bits) {
      return {
        bits,
        serialize: (src) => {
          if (typeof src !== "bigint") {
            throw Error("Key is not a bigint");
          }
          return (0, Builder_1.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src) => {
          return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadIntBig(bits);
        }
      };
    }
    function createIntKey(bits) {
      return {
        bits,
        serialize: (src) => {
          if (typeof src !== "number") {
            throw Error("Key is not a number");
          }
          if (!Number.isSafeInteger(src)) {
            throw Error("Key is not a safe integer: " + src);
          }
          return (0, Builder_1.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src) => {
          return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadInt(bits);
        }
      };
    }
    function createBigUintKey(bits) {
      return {
        bits,
        serialize: (src) => {
          if (typeof src !== "bigint") {
            throw Error("Key is not a bigint");
          }
          if (src < 0) {
            throw Error("Key is negative: " + src);
          }
          return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src) => {
          return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
        }
      };
    }
    function createUintKey(bits) {
      return {
        bits,
        serialize: (src) => {
          if (typeof src !== "number") {
            throw Error("Key is not a number");
          }
          if (!Number.isSafeInteger(src)) {
            throw Error("Key is not a safe integer: " + src);
          }
          if (src < 0) {
            throw Error("Key is negative: " + src);
          }
          return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src) => {
          return Number((0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUint(bits));
        }
      };
    }
    function createBufferKey(bytes) {
      return {
        bits: bytes * 8,
        serialize: (src) => {
          if (!Buffer.isBuffer(src)) {
            throw Error("Key is not a buffer");
          }
          return (0, Builder_1.beginCell)().storeBuffer(src).endCell().beginParse().loadUintBig(bytes * 8);
        },
        parse: (src) => {
          return (0, Builder_1.beginCell)().storeUint(src, bytes * 8).endCell().beginParse().loadBuffer(bytes);
        }
      };
    }
    function createBitStringKey(bits) {
      return {
        bits,
        serialize: (src) => {
          if (!BitString_1.BitString.isBitString(src))
            throw Error("Key is not a BitString");
          return (0, Builder_1.beginCell)().storeBits(src).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src) => {
          return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadBits(bits);
        }
      };
    }
    function createIntValue(bits) {
      return {
        serialize: (src, buidler) => {
          buidler.storeInt(src, bits);
        },
        parse: (src) => {
          return src.loadInt(bits);
        }
      };
    }
    function createBigIntValue(bits) {
      return {
        serialize: (src, buidler) => {
          buidler.storeInt(src, bits);
        },
        parse: (src) => {
          return src.loadIntBig(bits);
        }
      };
    }
    function createBigVarIntValue(bits) {
      return {
        serialize: (src, buidler) => {
          buidler.storeVarInt(src, bits);
        },
        parse: (src) => {
          return src.loadVarIntBig(bits);
        }
      };
    }
    function createBigVarUintValue(bits) {
      return {
        serialize: (src, buidler) => {
          buidler.storeVarUint(src, bits);
        },
        parse: (src) => {
          return src.loadVarUintBig(bits);
        }
      };
    }
    function createUintValue(bits) {
      return {
        serialize: (src, buidler) => {
          buidler.storeUint(src, bits);
        },
        parse: (src) => {
          return src.loadUint(bits);
        }
      };
    }
    function createBigUintValue(bits) {
      return {
        serialize: (src, buidler) => {
          buidler.storeUint(src, bits);
        },
        parse: (src) => {
          return src.loadUintBig(bits);
        }
      };
    }
    function createBooleanValue() {
      return {
        serialize: (src, buidler) => {
          buidler.storeBit(src);
        },
        parse: (src) => {
          return src.loadBit();
        }
      };
    }
    function createAddressValue() {
      return {
        serialize: (src, buidler) => {
          buidler.storeAddress(src);
        },
        parse: (src) => {
          return src.loadAddress();
        }
      };
    }
    function createCellValue() {
      return {
        serialize: (src, buidler) => {
          buidler.storeRef(src);
        },
        parse: (src) => {
          return src.loadRef();
        }
      };
    }
    function createDictionaryValue(key, value) {
      return {
        serialize: (src, buidler) => {
          src.store(buidler);
        },
        parse: (src) => {
          return Dictionary.load(key, value, src);
        }
      };
    }
    function createBufferValue(size) {
      return {
        serialize: (src, buidler) => {
          if (src.length !== size) {
            throw Error("Invalid buffer size");
          }
          buidler.storeBuffer(src);
        },
        parse: (src) => {
          return src.loadBuffer(size);
        }
      };
    }
    function createBitStringValue(bits) {
      return {
        serialize: (src, builder) => {
          if (src.length !== bits) {
            throw Error("Invalid BitString size");
          }
          builder.storeBits(src);
        },
        parse: (src) => {
          return src.loadBits(bits);
        }
      };
    }
  }
});

// node_modules/@ton/core/dist/boc/utils/strings.js
var require_strings = __commonJS({
  "node_modules/@ton/core/dist/boc/utils/strings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.writeString = exports.stringToCell = exports.readString = void 0;
    var Builder_1 = require_Builder();
    function readBuffer(slice) {
      if (slice.remainingBits % 8 !== 0) {
        throw new Error(`Invalid string length: ${slice.remainingBits}`);
      }
      if (slice.remainingRefs !== 0 && slice.remainingRefs !== 1) {
        throw new Error(`invalid number of refs: ${slice.remainingRefs}`);
      }
      let res;
      if (slice.remainingBits === 0) {
        res = Buffer.alloc(0);
      } else {
        res = slice.loadBuffer(slice.remainingBits / 8);
      }
      if (slice.remainingRefs === 1) {
        res = Buffer.concat([res, readBuffer(slice.loadRef().beginParse())]);
      }
      return res;
    }
    function readString(slice) {
      return readBuffer(slice).toString();
    }
    exports.readString = readString;
    function writeBuffer(src, builder) {
      if (src.length > 0) {
        let bytes = Math.floor(builder.availableBits / 8);
        if (src.length > bytes) {
          let a = src.subarray(0, bytes);
          let t = src.subarray(bytes);
          builder = builder.storeBuffer(a);
          let bb = (0, Builder_1.beginCell)();
          writeBuffer(t, bb);
          builder = builder.storeRef(bb.endCell());
        } else {
          builder = builder.storeBuffer(src);
        }
      }
    }
    function stringToCell(src) {
      let builder = (0, Builder_1.beginCell)();
      writeBuffer(Buffer.from(src), builder);
      return builder.endCell();
    }
    exports.stringToCell = stringToCell;
    function writeString(src, builder) {
      writeBuffer(Buffer.from(src), builder);
    }
    exports.writeString = writeString;
  }
});

// node_modules/@ton/core/dist/boc/Slice.js
var require_Slice = __commonJS({
  "node_modules/@ton/core/dist/boc/Slice.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Slice = void 0;
    var symbol_inspect_1 = __importDefault(require_symbol());
    var Dictionary_1 = require_Dictionary();
    var Builder_1 = require_Builder();
    var strings_1 = require_strings();
    var Slice = class _Slice {
      constructor(reader, refs) {
        this[_a] = () => this.toString();
        this._reader = reader.clone();
        this._refs = [...refs];
        this._refsOffset = 0;
      }
      /**
       * Get remaining bits
       */
      get remainingBits() {
        return this._reader.remaining;
      }
      /**
       * Get offset bits
       */
      get offsetBits() {
        return this._reader.offset;
      }
      /**
       * Get remaining refs
       */
      get remainingRefs() {
        return this._refs.length - this._refsOffset;
      }
      /**
       * Get offset refs
       */
      get offsetRefs() {
        return this._refsOffset;
      }
      /**
       * Skip bits
       * @param bits
       */
      skip(bits) {
        this._reader.skip(bits);
        return this;
      }
      /**
       * Load a single bit
       * @returns true or false depending on the bit value
       */
      loadBit() {
        return this._reader.loadBit();
      }
      /**
       * Preload a signle bit
       * @returns true or false depending on the bit value
       */
      preloadBit() {
        return this._reader.preloadBit();
      }
      /**
       * Load a boolean
       * @returns true or false depending on the bit value
       */
      loadBoolean() {
        return this.loadBit();
      }
      /**
       * Load maybe boolean
       * @returns true or false depending on the bit value or null
       */
      loadMaybeBoolean() {
        if (this.loadBit()) {
          return this.loadBoolean();
        } else {
          return null;
        }
      }
      /**
       * Load bits as a new BitString
       * @param bits number of bits to read
       * @returns new BitString
       */
      loadBits(bits) {
        return this._reader.loadBits(bits);
      }
      /**
       * Preload bits as a new BitString
       * @param bits number of bits to read
       * @returns new BitString
       */
      preloadBits(bits) {
        return this._reader.preloadBits(bits);
      }
      /**
       * Load uint
       * @param bits number of bits to read
       * @returns uint value
       */
      loadUint(bits) {
        return this._reader.loadUint(bits);
      }
      /**
       * Load uint
       * @param bits number of bits to read
       * @returns uint value
       */
      loadUintBig(bits) {
        return this._reader.loadUintBig(bits);
      }
      /**
       * Preload uint
       * @param bits number of bits to read
       * @returns uint value
       */
      preloadUint(bits) {
        return this._reader.preloadUint(bits);
      }
      /**
       * Preload uint
       * @param bits number of bits to read
       * @returns uint value
       */
      preloadUintBig(bits) {
        return this._reader.preloadUintBig(bits);
      }
      /**
       * Load maybe uint
       * @param bits number of bits to read
       * @returns uint value or null
       */
      loadMaybeUint(bits) {
        if (this.loadBit()) {
          return this.loadUint(bits);
        } else {
          return null;
        }
      }
      /**
       * Load maybe uint
       * @param bits number of bits to read
       * @returns uint value or null
       */
      loadMaybeUintBig(bits) {
        if (this.loadBit()) {
          return this.loadUintBig(bits);
        } else {
          return null;
        }
      }
      /**
       * Load int
       * @param bits number of bits to read
       * @returns int value
       */
      loadInt(bits) {
        return this._reader.loadInt(bits);
      }
      /**
       * Load int
       * @param bits number of bits to read
       * @returns int value
       */
      loadIntBig(bits) {
        return this._reader.loadIntBig(bits);
      }
      /**
       * Preload int
       * @param bits number of bits to read
       * @returns int value
       */
      preloadInt(bits) {
        return this._reader.preloadInt(bits);
      }
      /**
       * Preload int
       * @param bits number of bits to read
       * @returns int value
       */
      preloadIntBig(bits) {
        return this._reader.preloadIntBig(bits);
      }
      /**
       * Load maybe uint
       * @param bits number of bits to read
       * @returns uint value or null
       */
      loadMaybeInt(bits) {
        if (this.loadBit()) {
          return this.loadInt(bits);
        } else {
          return null;
        }
      }
      /**
       * Load maybe uint
       * @param bits number of bits to read
       * @returns uint value or null
       */
      loadMaybeIntBig(bits) {
        if (this.loadBit()) {
          return this.loadIntBig(bits);
        } else {
          return null;
        }
      }
      /**
       * Load varuint
       * @param bits number of bits to read in header
       * @returns varuint value
       */
      loadVarUint(bits) {
        return this._reader.loadVarUint(bits);
      }
      /**
       * Load varuint
       * @param bits number of bits to read in header
       * @returns varuint value
       */
      loadVarUintBig(bits) {
        return this._reader.loadVarUintBig(bits);
      }
      /**
       * Preload varuint
       * @param bits number of bits to read in header
       * @returns varuint value
       */
      preloadVarUint(bits) {
        return this._reader.preloadVarUint(bits);
      }
      /**
       * Preload varuint
       * @param bits number of bits to read in header
       * @returns varuint value
       */
      preloadVarUintBig(bits) {
        return this._reader.preloadVarUintBig(bits);
      }
      /**
       * Load varint
       * @param bits number of bits to read in header
       * @returns varint value
       */
      loadVarInt(bits) {
        return this._reader.loadVarInt(bits);
      }
      /**
       * Load varint
       * @param bits number of bits to read in header
       * @returns varint value
       */
      loadVarIntBig(bits) {
        return this._reader.loadVarIntBig(bits);
      }
      /**
       * Preload varint
       * @param bits number of bits to read in header
       * @returns varint value
       */
      preloadVarInt(bits) {
        return this._reader.preloadVarInt(bits);
      }
      /**
       * Preload varint
       * @param bits number of bits to read in header
       * @returns varint value
       */
      preloadVarIntBig(bits) {
        return this._reader.preloadVarIntBig(bits);
      }
      /**
       * Load coins
       * @returns coins value
       */
      loadCoins() {
        return this._reader.loadCoins();
      }
      /**
       * Preload coins
       * @returns coins value
       */
      preloadCoins() {
        return this._reader.preloadCoins();
      }
      /**
       * Load maybe coins
       * @returns coins value or null
       */
      loadMaybeCoins() {
        if (this._reader.loadBit()) {
          return this._reader.loadCoins();
        } else {
          return null;
        }
      }
      /**
       * Load internal Address
       * @returns Address
       */
      loadAddress() {
        return this._reader.loadAddress();
      }
      /**
       * Load optional internal Address
       * @returns Address or null
       */
      loadMaybeAddress() {
        return this._reader.loadMaybeAddress();
      }
      /**
       * Load external address
       * @returns ExternalAddress
       */
      loadExternalAddress() {
        return this._reader.loadExternalAddress();
      }
      /**
       * Load optional external address
       * @returns ExternalAddress or null
       */
      loadMaybeExternalAddress() {
        return this._reader.loadMaybeExternalAddress();
      }
      /**
       * Load address
       * @returns Address, ExternalAddress or null
       */
      loadAddressAny() {
        return this._reader.loadAddressAny();
      }
      /**
       * Load reference
       * @returns Cell
       */
      loadRef() {
        if (this._refsOffset >= this._refs.length) {
          throw new Error("No more references");
        }
        return this._refs[this._refsOffset++];
      }
      /**
       * Preload reference
       * @returns Cell
       */
      preloadRef() {
        if (this._refsOffset >= this._refs.length) {
          throw new Error("No more references");
        }
        return this._refs[this._refsOffset];
      }
      /**
       * Load optional reference
       * @returns Cell or null
       */
      loadMaybeRef() {
        if (this.loadBit()) {
          return this.loadRef();
        } else {
          return null;
        }
      }
      /**
       * Preload optional reference
       * @returns Cell or null
       */
      preloadMaybeRef() {
        if (this.preloadBit()) {
          return this.preloadRef();
        } else {
          return null;
        }
      }
      /**
       * Load byte buffer
       * @param bytes number of bytes to load
       * @returns Buffer
       */
      loadBuffer(bytes) {
        return this._reader.loadBuffer(bytes);
      }
      /**
       * Load byte buffer
       * @param bytes number of bytes to load
       * @returns Buffer
       */
      preloadBuffer(bytes) {
        return this._reader.preloadBuffer(bytes);
      }
      /**
       * Load string tail
       */
      loadStringTail() {
        return (0, strings_1.readString)(this);
      }
      /**
       * Load maybe string tail
       * @returns string or null
       */
      loadMaybeStringTail() {
        if (this.loadBit()) {
          return (0, strings_1.readString)(this);
        } else {
          return null;
        }
      }
      /**
       * Load string tail from ref
       * @returns string
       */
      loadStringRefTail() {
        return (0, strings_1.readString)(this.loadRef().beginParse());
      }
      /**
       * Load maybe string tail from ref
       * @returns string or null
       */
      loadMaybeStringRefTail() {
        const ref = this.loadMaybeRef();
        if (ref) {
          return (0, strings_1.readString)(ref.beginParse());
        } else {
          return null;
        }
      }
      /**
       * Loads dictionary
       * @param key key description
       * @param value value description
       * @returns Dictionary<K, V>
       */
      loadDict(key, value) {
        return Dictionary_1.Dictionary.load(key, value, this);
      }
      /**
       * Loads dictionary directly from current slice
       * @param key key description
       * @param value value description
       * @returns Dictionary<K, V>
       */
      loadDictDirect(key, value) {
        return Dictionary_1.Dictionary.loadDirect(key, value, this);
      }
      /**
       * Checks if slice is empty
       */
      endParse() {
        if (this.remainingBits > 0 || this.remainingRefs > 0) {
          throw new Error("Slice is not empty");
        }
      }
      /**
       * Convert slice to cell
       */
      asCell() {
        return (0, Builder_1.beginCell)().storeSlice(this).endCell();
      }
      /**
       *
       * @returns
       */
      asBuilder() {
        return (0, Builder_1.beginCell)().storeSlice(this);
      }
      /**
       * Clone slice
       * @returns cloned slice
       */
      clone(fromStart = false) {
        if (fromStart) {
          let reader = this._reader.clone();
          reader.reset();
          return new _Slice(reader, this._refs);
        } else {
          let res = new _Slice(this._reader, this._refs);
          res._refsOffset = this._refsOffset;
          return res;
        }
      }
      /**
       * Print slice as string by converting it to cell
       * @returns string
       */
      toString() {
        return this.asCell().toString();
      }
    };
    exports.Slice = Slice;
    _a = symbol_inspect_1.default;
  }
});

// node_modules/@ton/core/dist/boc/BitReader.js
var require_BitReader = __commonJS({
  "node_modules/@ton/core/dist/boc/BitReader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitReader = void 0;
    var Address_1 = require_Address();
    var ExternalAddress_1 = require_ExternalAddress();
    var BitReader = class _BitReader {
      constructor(bits, offset = 0) {
        this._checkpoints = [];
        this._bits = bits;
        this._offset = offset;
      }
      /**
       * Offset in source bit string
       */
      get offset() {
        return this._offset;
      }
      /**
       * Number of bits remaining
       */
      get remaining() {
        return this._bits.length - this._offset;
      }
      /**
       * Skip bits
       * @param bits number of bits to skip
       */
      skip(bits) {
        if (bits < 0 || this._offset + bits > this._bits.length) {
          throw new Error(`Index ${this._offset + bits} is out of bounds`);
        }
        this._offset += bits;
      }
      /**
       * Reset to the beginning or latest checkpoint
       */
      reset() {
        if (this._checkpoints.length > 0) {
          this._offset = this._checkpoints.pop();
        } else {
          this._offset = 0;
        }
      }
      /**
       * Save checkpoint
       */
      save() {
        this._checkpoints.push(this._offset);
      }
      /**
       * Load a single bit
       * @returns true if the bit is set, false otherwise
       */
      loadBit() {
        let r = this._bits.at(this._offset);
        this._offset++;
        return r;
      }
      /**
       * Preload bit
       * @returns true if the bit is set, false otherwise
       */
      preloadBit() {
        return this._bits.at(this._offset);
      }
      /**
       * Load bit string
       * @param bits number of bits to read
       * @returns new bitstring
       */
      loadBits(bits) {
        let r = this._bits.substring(this._offset, bits);
        this._offset += bits;
        return r;
      }
      /**
       * Preload bit string
       * @param bits number of bits to read
       * @returns new bitstring
       */
      preloadBits(bits) {
        return this._bits.substring(this._offset, bits);
      }
      /**
       * Load buffer
       * @param bytes number of bytes
       * @returns new buffer
       */
      loadBuffer(bytes) {
        let buf = this._preloadBuffer(bytes, this._offset);
        this._offset += bytes * 8;
        return buf;
      }
      /**
       * Preload buffer
       * @param bytes number of bytes
       * @returns new buffer
       */
      preloadBuffer(bytes) {
        return this._preloadBuffer(bytes, this._offset);
      }
      /**
       * Load uint value
       * @param bits uint bits
       * @returns read value as number
       */
      loadUint(bits) {
        return Number(this.loadUintBig(bits));
      }
      /**
       * Load uint value as bigint
       * @param bits uint bits
       * @returns read value as bigint
       */
      loadUintBig(bits) {
        let loaded = this.preloadUintBig(bits);
        this._offset += bits;
        return loaded;
      }
      /**
       * Preload uint value
       * @param bits uint bits
       * @returns read value as number
       */
      preloadUint(bits) {
        return Number(this._preloadUint(bits, this._offset));
      }
      /**
       * Preload uint value as bigint
       * @param bits uint bits
       * @returns read value as bigint
       */
      preloadUintBig(bits) {
        return this._preloadUint(bits, this._offset);
      }
      /**
       * Load int value
       * @param bits int bits
       * @returns read value as bigint
       */
      loadInt(bits) {
        let res = this._preloadInt(bits, this._offset);
        this._offset += bits;
        return Number(res);
      }
      /**
       * Load int value as bigint
       * @param bits int bits
       * @returns read value as bigint
       */
      loadIntBig(bits) {
        let res = this._preloadInt(bits, this._offset);
        this._offset += bits;
        return res;
      }
      /**
       * Preload int value
       * @param bits int bits
       * @returns read value as bigint
       */
      preloadInt(bits) {
        return Number(this._preloadInt(bits, this._offset));
      }
      /**
       * Preload int value
       * @param bits int bits
       * @returns read value as bigint
       */
      preloadIntBig(bits) {
        return this._preloadInt(bits, this._offset);
      }
      /**
       * Load varuint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      loadVarUint(bits) {
        let size = Number(this.loadUint(bits));
        return Number(this.loadUintBig(size * 8));
      }
      /**
       * Load varuint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      loadVarUintBig(bits) {
        let size = Number(this.loadUint(bits));
        return this.loadUintBig(size * 8);
      }
      /**
       * Preload varuint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      preloadVarUint(bits) {
        let size = Number(this._preloadUint(bits, this._offset));
        return Number(this._preloadUint(size * 8, this._offset + bits));
      }
      /**
       * Preload varuint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      preloadVarUintBig(bits) {
        let size = Number(this._preloadUint(bits, this._offset));
        return this._preloadUint(size * 8, this._offset + bits);
      }
      /**
       * Load varint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      loadVarInt(bits) {
        let size = Number(this.loadUint(bits));
        return Number(this.loadIntBig(size * 8));
      }
      /**
       * Load varint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      loadVarIntBig(bits) {
        let size = Number(this.loadUint(bits));
        return this.loadIntBig(size * 8);
      }
      /**
       * Preload varint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      preloadVarInt(bits) {
        let size = Number(this._preloadUint(bits, this._offset));
        return Number(this._preloadInt(size * 8, this._offset + bits));
      }
      /**
       * Preload varint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      preloadVarIntBig(bits) {
        let size = Number(this._preloadUint(bits, this._offset));
        return this._preloadInt(size * 8, this._offset + bits);
      }
      /**
       * Load coins value
       * @returns read value as bigint
       */
      loadCoins() {
        return this.loadVarUintBig(4);
      }
      /**
       * Preload coins value
       * @returns read value as bigint
       */
      preloadCoins() {
        return this.preloadVarUintBig(4);
      }
      /**
       * Load Address
       * @returns Address
       */
      loadAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type === 2) {
          return this._loadInternalAddress();
        } else {
          throw new Error("Invalid address: " + type);
        }
      }
      /**
       * Load internal address
       * @returns Address or null
       */
      loadMaybeAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type === 0) {
          this._offset += 2;
          return null;
        } else if (type === 2) {
          return this._loadInternalAddress();
        } else {
          throw new Error("Invalid address");
        }
      }
      /**
       * Load external address
       * @returns ExternalAddress
       */
      loadExternalAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type === 1) {
          return this._loadExternalAddress();
        } else {
          throw new Error("Invalid address");
        }
      }
      /**
       * Load external address
       * @returns ExternalAddress or null
       */
      loadMaybeExternalAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type === 0) {
          this._offset += 2;
          return null;
        } else if (type === 1) {
          return this._loadExternalAddress();
        } else {
          throw new Error("Invalid address");
        }
      }
      /**
       * Read address of any type
       * @returns Address or ExternalAddress or null
       */
      loadAddressAny() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type === 0) {
          this._offset += 2;
          return null;
        } else if (type === 2) {
          return this._loadInternalAddress();
        } else if (type === 1) {
          return this._loadExternalAddress();
        } else if (type === 3) {
          throw Error("Unsupported");
        } else {
          throw Error("Unreachable");
        }
      }
      /**
       * Load bit string that was padded to make it byte alligned. Used in BOC serialization
       * @param bytes number of bytes to read
       */
      loadPaddedBits(bits) {
        if (bits % 8 !== 0) {
          throw new Error("Invalid number of bits");
        }
        let length = bits;
        while (true) {
          if (this._bits.at(this._offset + length - 1)) {
            length--;
            break;
          } else {
            length--;
          }
        }
        let r = this._bits.substring(this._offset, length);
        this._offset += bits;
        return r;
      }
      /**
       * Clone BitReader
       */
      clone() {
        return new _BitReader(this._bits, this._offset);
      }
      /**
       * Preload int from specific offset
       * @param bits bits to preload
       * @param offset offset to start from
       * @returns read value as bigint
       */
      _preloadInt(bits, offset) {
        if (bits == 0) {
          return 0n;
        }
        let sign = this._bits.at(offset);
        let res = 0n;
        for (let i = 0; i < bits - 1; i++) {
          if (this._bits.at(offset + 1 + i)) {
            res += 1n << BigInt(bits - i - 1 - 1);
          }
        }
        if (sign) {
          res = res - (1n << BigInt(bits - 1));
        }
        return res;
      }
      /**
       * Preload uint from specific offset
       * @param bits bits to preload
       * @param offset offset to start from
       * @returns read value as bigint
       */
      _preloadUint(bits, offset) {
        if (bits == 0) {
          return 0n;
        }
        let res = 0n;
        for (let i = 0; i < bits; i++) {
          if (this._bits.at(offset + i)) {
            res += 1n << BigInt(bits - i - 1);
          }
        }
        return res;
      }
      _preloadBuffer(bytes, offset) {
        let fastBuffer = this._bits.subbuffer(offset, bytes * 8);
        if (fastBuffer) {
          return fastBuffer;
        }
        let buf = Buffer.alloc(bytes);
        for (let i = 0; i < bytes; i++) {
          buf[i] = Number(this._preloadUint(8, offset + i * 8));
        }
        return buf;
      }
      _loadInternalAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type !== 2) {
          throw Error("Invalid address");
        }
        if (this._preloadUint(1, this._offset + 2) !== 0n) {
          throw Error("Invalid address");
        }
        let wc = Number(this._preloadInt(8, this._offset + 3));
        let hash = this._preloadBuffer(32, this._offset + 11);
        this._offset += 267;
        return new Address_1.Address(wc, hash);
      }
      _loadExternalAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type !== 1) {
          throw Error("Invalid address");
        }
        let bits = Number(this._preloadUint(9, this._offset + 2));
        let value = this._preloadUint(bits, this._offset + 11);
        this._offset += 11 + bits;
        return new ExternalAddress_1.ExternalAddress(value, bits);
      }
    };
    exports.BitReader = BitReader;
  }
});

// node_modules/@ton/core/dist/boc/cell/exoticLibrary.js
var require_exoticLibrary = __commonJS({
  "node_modules/@ton/core/dist/boc/cell/exoticLibrary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exoticLibrary = void 0;
    var BitReader_1 = require_BitReader();
    function exoticLibrary(bits, refs) {
      const reader = new BitReader_1.BitReader(bits);
      const size = 8 + 256;
      if (bits.length !== size) {
        throw new Error(`Library cell must have exactly (8 + 256) bits, got "${bits.length}"`);
      }
      let type = reader.loadUint(8);
      if (type !== 2) {
        throw new Error(`Library cell must have type 2, got "${type}"`);
      }
      return {};
    }
    exports.exoticLibrary = exoticLibrary;
  }
});

// node_modules/@ton/core/dist/boc/cell/exoticMerkleProof.js
var require_exoticMerkleProof = __commonJS({
  "node_modules/@ton/core/dist/boc/cell/exoticMerkleProof.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exoticMerkleProof = void 0;
    var BitReader_1 = require_BitReader();
    function exoticMerkleProof(bits, refs) {
      const reader = new BitReader_1.BitReader(bits);
      const size = 8 + 256 + 16;
      if (bits.length !== size) {
        throw new Error(`Merkle Proof cell must have exactly (8 + 256 + 16) bits, got "${bits.length}"`);
      }
      if (refs.length !== 1) {
        throw new Error(`Merkle Proof cell must have exactly 1 ref, got "${refs.length}"`);
      }
      let type = reader.loadUint(8);
      if (type !== 3) {
        throw new Error(`Merkle Proof cell must have type 3, got "${type}"`);
      }
      const proofHash = reader.loadBuffer(32);
      const proofDepth = reader.loadUint(16);
      const refHash = refs[0].hash(0);
      const refDepth = refs[0].depth(0);
      if (proofDepth !== refDepth) {
        throw new Error(`Merkle Proof cell ref depth must be exactly "${proofDepth}", got "${refDepth}"`);
      }
      if (!proofHash.equals(refHash)) {
        throw new Error(`Merkle Proof cell ref hash must be exactly "${proofHash.toString("hex")}", got "${refHash.toString("hex")}"`);
      }
      return {
        proofDepth,
        proofHash
      };
    }
    exports.exoticMerkleProof = exoticMerkleProof;
  }
});

// node_modules/@ton/core/dist/boc/cell/exoticMerkleUpdate.js
var require_exoticMerkleUpdate = __commonJS({
  "node_modules/@ton/core/dist/boc/cell/exoticMerkleUpdate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exoticMerkleUpdate = void 0;
    var BitReader_1 = require_BitReader();
    function exoticMerkleUpdate(bits, refs) {
      const reader = new BitReader_1.BitReader(bits);
      const size = 8 + 2 * (256 + 16);
      if (bits.length !== size) {
        throw new Error(`Merkle Update cell must have exactly (8 + (2 * (256 + 16))) bits, got "${bits.length}"`);
      }
      if (refs.length !== 2) {
        throw new Error(`Merkle Update cell must have exactly 2 refs, got "${refs.length}"`);
      }
      let type = reader.loadUint(8);
      if (type !== 4) {
        throw new Error(`Merkle Update cell type must be exactly 4, got "${type}"`);
      }
      const proofHash1 = reader.loadBuffer(32);
      const proofHash2 = reader.loadBuffer(32);
      const proofDepth1 = reader.loadUint(16);
      const proofDepth2 = reader.loadUint(16);
      if (proofDepth1 !== refs[0].depth(0)) {
        throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth1}", got "${refs[0].depth(0)}"`);
      }
      if (!proofHash1.equals(refs[0].hash(0))) {
        throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash1.toString("hex")}", got "${refs[0].hash(0).toString("hex")}"`);
      }
      if (proofDepth2 !== refs[1].depth(0)) {
        throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth2}", got "${refs[1].depth(0)}"`);
      }
      if (!proofHash2.equals(refs[1].hash(0))) {
        throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash2.toString("hex")}", got "${refs[1].hash(0).toString("hex")}"`);
      }
      return {
        proofDepth1,
        proofDepth2,
        proofHash1,
        proofHash2
      };
    }
    exports.exoticMerkleUpdate = exoticMerkleUpdate;
  }
});

// node_modules/@ton/core/dist/boc/cell/LevelMask.js
var require_LevelMask = __commonJS({
  "node_modules/@ton/core/dist/boc/cell/LevelMask.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LevelMask = void 0;
    var LevelMask = class _LevelMask {
      constructor(mask = 0) {
        this._mask = 0;
        this._mask = mask;
        this._hashIndex = countSetBits(this._mask);
        this._hashCount = this._hashIndex + 1;
      }
      get value() {
        return this._mask;
      }
      get level() {
        return 32 - Math.clz32(this._mask);
      }
      get hashIndex() {
        return this._hashIndex;
      }
      get hashCount() {
        return this._hashCount;
      }
      apply(level) {
        return new _LevelMask(this._mask & (1 << level) - 1);
      }
      isSignificant(level) {
        let res = level === 0 || (this._mask >> level - 1) % 2 !== 0;
        return res;
      }
    };
    exports.LevelMask = LevelMask;
    function countSetBits(n) {
      n = n - (n >> 1 & 1431655765);
      n = (n & 858993459) + (n >> 2 & 858993459);
      return (n + (n >> 4) & 252645135) * 16843009 >> 24;
    }
  }
});

// node_modules/@ton/core/dist/boc/cell/exoticPruned.js
var require_exoticPruned = __commonJS({
  "node_modules/@ton/core/dist/boc/cell/exoticPruned.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exoticPruned = void 0;
    var BitReader_1 = require_BitReader();
    var LevelMask_1 = require_LevelMask();
    function exoticPruned(bits, refs) {
      let reader = new BitReader_1.BitReader(bits);
      let type = reader.loadUint(8);
      if (type !== 1) {
        throw new Error(`Pruned branch cell must have type 1, got "${type}"`);
      }
      if (refs.length !== 0) {
        throw new Error(`Pruned Branch cell can't has refs, got "${refs.length}"`);
      }
      let mask;
      if (bits.length === 280) {
        mask = new LevelMask_1.LevelMask(1);
      } else {
        mask = new LevelMask_1.LevelMask(reader.loadUint(8));
        if (mask.level < 1 || mask.level > 3) {
          throw new Error(`Pruned Branch cell level must be >= 1 and <= 3, got "${mask.level}/${mask.value}"`);
        }
        const size = 8 + 8 + mask.apply(mask.level - 1).hashCount * (256 + 16);
        if (bits.length !== size) {
          throw new Error(`Pruned branch cell must have exactly ${size} bits, got "${bits.length}"`);
        }
      }
      let pruned = [];
      let hashes = [];
      let depths = [];
      for (let i = 0; i < mask.level; i++) {
        hashes.push(reader.loadBuffer(32));
      }
      for (let i = 0; i < mask.level; i++) {
        depths.push(reader.loadUint(16));
      }
      for (let i = 0; i < mask.level; i++) {
        pruned.push({
          depth: depths[i],
          hash: hashes[i]
        });
      }
      return {
        mask: mask.value,
        pruned
      };
    }
    exports.exoticPruned = exoticPruned;
  }
});

// node_modules/@ton/core/dist/boc/cell/resolveExotic.js
var require_resolveExotic = __commonJS({
  "node_modules/@ton/core/dist/boc/cell/resolveExotic.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveExotic = void 0;
    var BitReader_1 = require_BitReader();
    var CellType_1 = require_CellType();
    var exoticLibrary_1 = require_exoticLibrary();
    var exoticMerkleProof_1 = require_exoticMerkleProof();
    var exoticMerkleUpdate_1 = require_exoticMerkleUpdate();
    var exoticPruned_1 = require_exoticPruned();
    var LevelMask_1 = require_LevelMask();
    function resolvePruned(bits, refs) {
      let pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
      let depths = [];
      let hashes = [];
      let mask = new LevelMask_1.LevelMask(pruned.mask);
      for (let i = 0; i < pruned.pruned.length; i++) {
        depths.push(pruned.pruned[i].depth);
        hashes.push(pruned.pruned[i].hash);
      }
      return {
        type: CellType_1.CellType.PrunedBranch,
        depths,
        hashes,
        mask
      };
    }
    function resolveLibrary(bits, refs) {
      let pruned = (0, exoticLibrary_1.exoticLibrary)(bits, refs);
      let depths = [];
      let hashes = [];
      let mask = new LevelMask_1.LevelMask();
      return {
        type: CellType_1.CellType.Library,
        depths,
        hashes,
        mask
      };
    }
    function resolveMerkleProof(bits, refs) {
      let merkleProof = (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
      let depths = [];
      let hashes = [];
      let mask = new LevelMask_1.LevelMask(refs[0].level() >> 1);
      return {
        type: CellType_1.CellType.MerkleProof,
        depths,
        hashes,
        mask
      };
    }
    function resolveMerkleUpdate(bits, refs) {
      let merkleUpdate = (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
      let depths = [];
      let hashes = [];
      let mask = new LevelMask_1.LevelMask((refs[0].level() | refs[1].level()) >> 1);
      return {
        type: CellType_1.CellType.MerkleUpdate,
        depths,
        hashes,
        mask
      };
    }
    function resolveExotic(bits, refs) {
      let reader = new BitReader_1.BitReader(bits);
      let type = reader.preloadUint(8);
      if (type === 1) {
        return resolvePruned(bits, refs);
      }
      if (type === 2) {
        return resolveLibrary(bits, refs);
      }
      if (type === 3) {
        return resolveMerkleProof(bits, refs);
      }
      if (type === 4) {
        return resolveMerkleUpdate(bits, refs);
      }
      throw Error("Invalid exotic cell type: " + type);
    }
    exports.resolveExotic = resolveExotic;
  }
});

// node_modules/@ton/core/dist/boc/cell/descriptor.js
var require_descriptor = __commonJS({
  "node_modules/@ton/core/dist/boc/cell/descriptor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRepr = exports.getBitsDescriptor = exports.getRefsDescriptor = void 0;
    var CellType_1 = require_CellType();
    var paddedBits_1 = require_paddedBits();
    function getRefsDescriptor(refs, levelMask, type) {
      return refs.length + (type !== CellType_1.CellType.Ordinary ? 1 : 0) * 8 + levelMask * 32;
    }
    exports.getRefsDescriptor = getRefsDescriptor;
    function getBitsDescriptor(bits) {
      let len = bits.length;
      return Math.ceil(len / 8) + Math.floor(len / 8);
    }
    exports.getBitsDescriptor = getBitsDescriptor;
    function getRepr(originalBits, bits, refs, level, levelMask, type) {
      const bitsLen = Math.ceil(bits.length / 8);
      const repr = Buffer.alloc(2 + bitsLen + (2 + 32) * refs.length);
      let reprCursor = 0;
      repr[reprCursor++] = getRefsDescriptor(refs, levelMask, type);
      repr[reprCursor++] = getBitsDescriptor(originalBits);
      (0, paddedBits_1.bitsToPaddedBuffer)(bits).copy(repr, reprCursor);
      reprCursor += bitsLen;
      for (const c of refs) {
        let childDepth;
        if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
          childDepth = c.depth(level + 1);
        } else {
          childDepth = c.depth(level);
        }
        repr[reprCursor++] = Math.floor(childDepth / 256);
        repr[reprCursor++] = childDepth % 256;
      }
      for (const c of refs) {
        let childHash;
        if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
          childHash = c.hash(level + 1);
        } else {
          childHash = c.hash(level);
        }
        childHash.copy(repr, reprCursor);
        reprCursor += 32;
      }
      return repr;
    }
    exports.getRepr = getRepr;
  }
});

// node_modules/@ton/core/dist/boc/cell/wonderCalculator.js
var require_wonderCalculator = __commonJS({
  "node_modules/@ton/core/dist/boc/cell/wonderCalculator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wonderCalculator = void 0;
    var BitString_1 = require_BitString();
    var CellType_1 = require_CellType();
    var LevelMask_1 = require_LevelMask();
    var exoticPruned_1 = require_exoticPruned();
    var exoticMerkleProof_1 = require_exoticMerkleProof();
    var descriptor_1 = require_descriptor();
    var crypto_1 = require_dist();
    var exoticMerkleUpdate_1 = require_exoticMerkleUpdate();
    var exoticLibrary_1 = require_exoticLibrary();
    function wonderCalculator(type, bits, refs) {
      let levelMask;
      let pruned = null;
      if (type === CellType_1.CellType.Ordinary) {
        let mask = 0;
        for (let r of refs) {
          mask = mask | r.mask.value;
        }
        levelMask = new LevelMask_1.LevelMask(mask);
      } else if (type === CellType_1.CellType.PrunedBranch) {
        pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
        levelMask = new LevelMask_1.LevelMask(pruned.mask);
      } else if (type === CellType_1.CellType.MerkleProof) {
        let loaded = (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
        levelMask = new LevelMask_1.LevelMask(refs[0].mask.value >> 1);
      } else if (type === CellType_1.CellType.MerkleUpdate) {
        let loaded = (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
        levelMask = new LevelMask_1.LevelMask((refs[0].mask.value | refs[1].mask.value) >> 1);
      } else if (type === CellType_1.CellType.Library) {
        let loaded = (0, exoticLibrary_1.exoticLibrary)(bits, refs);
        levelMask = new LevelMask_1.LevelMask();
      } else {
        throw new Error("Unsupported exotic type");
      }
      let depths = [];
      let hashes = [];
      let hashCount = type === CellType_1.CellType.PrunedBranch ? 1 : levelMask.hashCount;
      let totalHashCount = levelMask.hashCount;
      let hashIOffset = totalHashCount - hashCount;
      for (let levelI = 0, hashI = 0; levelI <= levelMask.level; levelI++) {
        if (!levelMask.isSignificant(levelI)) {
          continue;
        }
        if (hashI < hashIOffset) {
          hashI++;
          continue;
        }
        let currentBits;
        if (hashI === hashIOffset) {
          if (!(levelI === 0 || type === CellType_1.CellType.PrunedBranch)) {
            throw Error("Invalid");
          }
          currentBits = bits;
        } else {
          if (!(levelI !== 0 && type !== CellType_1.CellType.PrunedBranch)) {
            throw Error("Invalid: " + levelI + ", " + type);
          }
          currentBits = new BitString_1.BitString(hashes[hashI - hashIOffset - 1], 0, 256);
        }
        let currentDepth = 0;
        for (let c of refs) {
          let childDepth;
          if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
            childDepth = c.depth(levelI + 1);
          } else {
            childDepth = c.depth(levelI);
          }
          currentDepth = Math.max(currentDepth, childDepth);
        }
        if (refs.length > 0) {
          currentDepth++;
        }
        let repr = (0, descriptor_1.getRepr)(bits, currentBits, refs, levelI, levelMask.apply(levelI).value, type);
        let hash = (0, crypto_1.sha256_sync)(repr);
        let destI = hashI - hashIOffset;
        depths[destI] = currentDepth;
        hashes[destI] = hash;
        hashI++;
      }
      let resolvedHashes = [];
      let resolvedDepths = [];
      if (pruned) {
        for (let i = 0; i < 4; i++) {
          const { hashIndex } = levelMask.apply(i);
          const { hashIndex: thisHashIndex } = levelMask;
          if (hashIndex !== thisHashIndex) {
            resolvedHashes.push(pruned.pruned[hashIndex].hash);
            resolvedDepths.push(pruned.pruned[hashIndex].depth);
          } else {
            resolvedHashes.push(hashes[0]);
            resolvedDepths.push(depths[0]);
          }
        }
      } else {
        for (let i = 0; i < 4; i++) {
          resolvedHashes.push(hashes[levelMask.apply(i).hashIndex]);
          resolvedDepths.push(depths[levelMask.apply(i).hashIndex]);
        }
      }
      return {
        mask: levelMask,
        hashes: resolvedHashes,
        depths: resolvedDepths
      };
    }
    exports.wonderCalculator = wonderCalculator;
  }
});

// node_modules/@ton/core/dist/boc/cell/utils/topologicalSort.js
var require_topologicalSort = __commonJS({
  "node_modules/@ton/core/dist/boc/cell/utils/topologicalSort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.topologicalSort = void 0;
    function topologicalSort(src) {
      let pending = [src];
      let allCells = /* @__PURE__ */ new Map();
      let notPermCells = /* @__PURE__ */ new Set();
      let sorted = [];
      while (pending.length > 0) {
        const cells = [...pending];
        pending = [];
        for (let cell of cells) {
          const hash = cell.hash().toString("hex");
          if (allCells.has(hash)) {
            continue;
          }
          notPermCells.add(hash);
          allCells.set(hash, { cell, refs: cell.refs.map((v) => v.hash().toString("hex")) });
          for (let r of cell.refs) {
            pending.push(r);
          }
        }
      }
      let tempMark = /* @__PURE__ */ new Set();
      function visit(hash) {
        if (!notPermCells.has(hash)) {
          return;
        }
        if (tempMark.has(hash)) {
          throw Error("Not a DAG");
        }
        tempMark.add(hash);
        let refs = allCells.get(hash).refs;
        for (let ci = refs.length - 1; ci >= 0; ci--) {
          visit(refs[ci]);
        }
        sorted.push(hash);
        tempMark.delete(hash);
        notPermCells.delete(hash);
      }
      while (notPermCells.size > 0) {
        const id = Array.from(notPermCells)[0];
        visit(id);
      }
      let indexes = /* @__PURE__ */ new Map();
      for (let i = 0; i < sorted.length; i++) {
        indexes.set(sorted[sorted.length - i - 1], i);
      }
      let result = [];
      for (let i = sorted.length - 1; i >= 0; i--) {
        let ent = sorted[i];
        const rrr = allCells.get(ent);
        result.push({ cell: rrr.cell, refs: rrr.refs.map((v) => indexes.get(v)) });
      }
      return result;
    }
    exports.topologicalSort = topologicalSort;
  }
});

// node_modules/@ton/core/dist/utils/bitsForNumber.js
var require_bitsForNumber = __commonJS({
  "node_modules/@ton/core/dist/utils/bitsForNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bitsForNumber = void 0;
    function bitsForNumber(src, mode) {
      let v = BigInt(src);
      if (mode === "int") {
        if (v === 0n || v === -1n) {
          return 1;
        }
        let v2 = v > 0 ? v : -v;
        return v2.toString(2).length + 1;
      } else if (mode === "uint") {
        if (v < 0) {
          throw Error(`value is negative. Got ${src}`);
        }
        return v.toString(2).length;
      } else {
        throw Error(`invalid mode. Got ${mode}`);
      }
    }
    exports.bitsForNumber = bitsForNumber;
  }
});

// node_modules/@ton/core/dist/utils/crc32c.js
var require_crc32c = __commonJS({
  "node_modules/@ton/core/dist/utils/crc32c.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crc32c = void 0;
    var POLY = 2197175160;
    function crc32c(source) {
      let crc = 0 ^ 4294967295;
      for (let n = 0; n < source.length; n++) {
        crc ^= source[n];
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      }
      crc = crc ^ 4294967295;
      let res = Buffer.alloc(4);
      res.writeInt32LE(crc);
      return res;
    }
    exports.crc32c = crc32c;
  }
});

// node_modules/@ton/core/dist/boc/cell/serialization.js
var require_serialization = __commonJS({
  "node_modules/@ton/core/dist/boc/cell/serialization.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeBoc = exports.deserializeBoc = exports.parseBoc = void 0;
    var BitReader_1 = require_BitReader();
    var BitString_1 = require_BitString();
    var Cell_1 = require_Cell();
    var topologicalSort_1 = require_topologicalSort();
    var bitsForNumber_1 = require_bitsForNumber();
    var BitBuilder_1 = require_BitBuilder();
    var descriptor_1 = require_descriptor();
    var paddedBits_1 = require_paddedBits();
    var crc32c_1 = require_crc32c();
    function getHashesCount(levelMask) {
      return getHashesCountFromMask(levelMask & 7);
    }
    function getHashesCountFromMask(mask) {
      let n = 0;
      for (let i = 0; i < 3; i++) {
        n += mask & 1;
        mask = mask >> 1;
      }
      return n + 1;
    }
    function readCell(reader, sizeBytes) {
      const d1 = reader.loadUint(8);
      const refsCount = d1 % 8;
      const exotic = !!(d1 & 8);
      const d2 = reader.loadUint(8);
      const dataBytesize = Math.ceil(d2 / 2);
      const paddingAdded = !!(d2 % 2);
      const levelMask = d1 >> 5;
      const hasHashes = (d1 & 16) != 0;
      const hash_bytes = 32;
      const hashesSize = hasHashes ? getHashesCount(levelMask) * hash_bytes : 0;
      const depthSize = hasHashes ? getHashesCount(levelMask) * 2 : 0;
      reader.skip(hashesSize * 8);
      reader.skip(depthSize * 8);
      let bits = BitString_1.BitString.EMPTY;
      if (dataBytesize > 0) {
        if (paddingAdded) {
          bits = reader.loadPaddedBits(dataBytesize * 8);
        } else {
          bits = reader.loadBits(dataBytesize * 8);
        }
      }
      let refs = [];
      for (let i = 0; i < refsCount; i++) {
        refs.push(reader.loadUint(sizeBytes * 8));
      }
      return {
        bits,
        refs,
        exotic
      };
    }
    function calcCellSize(cell, sizeBytes) {
      return 2 + Math.ceil(cell.bits.length / 8) + cell.refs.length * sizeBytes;
    }
    function parseBoc(src) {
      let reader = new BitReader_1.BitReader(new BitString_1.BitString(src, 0, src.length * 8));
      let magic = reader.loadUint(32);
      if (magic === 1761568243) {
        let size = reader.loadUint(8);
        let offBytes = reader.loadUint(8);
        let cells = reader.loadUint(size * 8);
        let roots = reader.loadUint(size * 8);
        let absent = reader.loadUint(size * 8);
        let totalCellSize = reader.loadUint(offBytes * 8);
        let index = reader.loadBuffer(cells * offBytes);
        let cellData = reader.loadBuffer(totalCellSize);
        return {
          size,
          offBytes,
          cells,
          roots,
          absent,
          totalCellSize,
          index,
          cellData,
          root: [0]
        };
      } else if (magic === 2898503464) {
        let size = reader.loadUint(8);
        let offBytes = reader.loadUint(8);
        let cells = reader.loadUint(size * 8);
        let roots = reader.loadUint(size * 8);
        let absent = reader.loadUint(size * 8);
        let totalCellSize = reader.loadUint(offBytes * 8);
        let index = reader.loadBuffer(cells * offBytes);
        let cellData = reader.loadBuffer(totalCellSize);
        let crc32 = reader.loadBuffer(4);
        if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {
          throw Error("Invalid CRC32C");
        }
        return {
          size,
          offBytes,
          cells,
          roots,
          absent,
          totalCellSize,
          index,
          cellData,
          root: [0]
        };
      } else if (magic === 3052313714) {
        let hasIdx = reader.loadUint(1);
        let hasCrc32c = reader.loadUint(1);
        let hasCacheBits = reader.loadUint(1);
        let flags = reader.loadUint(2);
        let size = reader.loadUint(3);
        let offBytes = reader.loadUint(8);
        let cells = reader.loadUint(size * 8);
        let roots = reader.loadUint(size * 8);
        let absent = reader.loadUint(size * 8);
        let totalCellSize = reader.loadUint(offBytes * 8);
        let root = [];
        for (let i = 0; i < roots; i++) {
          root.push(reader.loadUint(size * 8));
        }
        let index = null;
        if (hasIdx) {
          index = reader.loadBuffer(cells * offBytes);
        }
        let cellData = reader.loadBuffer(totalCellSize);
        if (hasCrc32c) {
          let crc32 = reader.loadBuffer(4);
          if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {
            throw Error("Invalid CRC32C");
          }
        }
        return {
          size,
          offBytes,
          cells,
          roots,
          absent,
          totalCellSize,
          index,
          cellData,
          root
        };
      } else {
        throw Error("Invalid magic");
      }
    }
    exports.parseBoc = parseBoc;
    function deserializeBoc(src) {
      let boc = parseBoc(src);
      let reader = new BitReader_1.BitReader(new BitString_1.BitString(boc.cellData, 0, boc.cellData.length * 8));
      let cells = [];
      for (let i = 0; i < boc.cells; i++) {
        let cll = readCell(reader, boc.size);
        cells.push({ ...cll, result: null });
      }
      for (let i = cells.length - 1; i >= 0; i--) {
        if (cells[i].result) {
          throw Error("Impossible");
        }
        let refs = [];
        for (let r of cells[i].refs) {
          if (!cells[r].result) {
            throw Error("Invalid BOC file");
          }
          refs.push(cells[r].result);
        }
        cells[i].result = new Cell_1.Cell({ bits: cells[i].bits, refs, exotic: cells[i].exotic });
      }
      let roots = [];
      for (let i = 0; i < boc.root.length; i++) {
        roots.push(cells[boc.root[i]].result);
      }
      return roots;
    }
    exports.deserializeBoc = deserializeBoc;
    function writeCellToBuilder(cell, refs, sizeBytes, to) {
      let d1 = (0, descriptor_1.getRefsDescriptor)(cell.refs, cell.mask.value, cell.type);
      let d2 = (0, descriptor_1.getBitsDescriptor)(cell.bits);
      to.writeUint(d1, 8);
      to.writeUint(d2, 8);
      to.writeBuffer((0, paddedBits_1.bitsToPaddedBuffer)(cell.bits));
      for (let r of refs) {
        to.writeUint(r, sizeBytes * 8);
      }
    }
    function serializeBoc(root, opts) {
      let allCells = (0, topologicalSort_1.topologicalSort)(root);
      let cellsNum = allCells.length;
      let has_idx = opts.idx;
      let has_crc32c = opts.crc32;
      let has_cache_bits = false;
      let flags = 0;
      let sizeBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(cellsNum, "uint") / 8), 1);
      let totalCellSize = 0;
      let index = [];
      for (let c of allCells) {
        let sz = calcCellSize(c.cell, sizeBytes);
        totalCellSize += sz;
        index.push(totalCellSize);
      }
      let offsetBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(totalCellSize, "uint") / 8), 1);
      let totalSize = (4 + // magic
      1 + // flags and s_bytes
      1 + // offset_bytes
      3 * sizeBytes + // cells_num, roots, complete
      offsetBytes + // full_size
      1 * sizeBytes + // root_idx
      (has_idx ? cellsNum * offsetBytes : 0) + totalCellSize + (has_crc32c ? 4 : 0)) * 8;
      let builder = new BitBuilder_1.BitBuilder(totalSize);
      builder.writeUint(3052313714, 32);
      builder.writeBit(has_idx);
      builder.writeBit(has_crc32c);
      builder.writeBit(has_cache_bits);
      builder.writeUint(flags, 2);
      builder.writeUint(sizeBytes, 3);
      builder.writeUint(offsetBytes, 8);
      builder.writeUint(cellsNum, sizeBytes * 8);
      builder.writeUint(1, sizeBytes * 8);
      builder.writeUint(0, sizeBytes * 8);
      builder.writeUint(totalCellSize, offsetBytes * 8);
      builder.writeUint(0, sizeBytes * 8);
      if (has_idx) {
        for (let i = 0; i < cellsNum; i++) {
          builder.writeUint(index[i], offsetBytes * 8);
        }
      }
      for (let i = 0; i < cellsNum; i++) {
        writeCellToBuilder(allCells[i].cell, allCells[i].refs, sizeBytes, builder);
      }
      if (has_crc32c) {
        let crc32 = (0, crc32c_1.crc32c)(builder.buffer());
        builder.writeBuffer(crc32);
      }
      let res = builder.buffer();
      if (res.length !== totalSize / 8) {
        throw Error("Internal error");
      }
      return res;
    }
    exports.serializeBoc = serializeBoc;
  }
});

// node_modules/@ton/core/dist/boc/Cell.js
var require_Cell = __commonJS({
  "node_modules/@ton/core/dist/boc/Cell.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Cell = void 0;
    var symbol_inspect_1 = __importDefault(require_symbol());
    var BitString_1 = require_BitString();
    var CellType_1 = require_CellType();
    var Slice_1 = require_Slice();
    var resolveExotic_1 = require_resolveExotic();
    var wonderCalculator_1 = require_wonderCalculator();
    var serialization_1 = require_serialization();
    var BitReader_1 = require_BitReader();
    var Builder_1 = require_Builder();
    var Cell = class _Cell {
      /**
       * Deserialize cells from BOC
       * @param src source buffer
       * @returns array of cells
       */
      static fromBoc(src) {
        return (0, serialization_1.deserializeBoc)(src);
      }
      /**
       * Helper class that deserializes a single cell from BOC in base64
       * @param src source string
       */
      static fromBase64(src) {
        let parsed = _Cell.fromBoc(Buffer.from(src, "base64"));
        if (parsed.length !== 1) {
          throw new Error("Deserialized more than one cell");
        }
        return parsed[0];
      }
      constructor(opts) {
        this._hashes = [];
        this._depths = [];
        this.beginParse = (allowExotic = false) => {
          if (this.isExotic && !allowExotic) {
            throw new Error("Exotic cells cannot be parsed");
          }
          return new Slice_1.Slice(new BitReader_1.BitReader(this.bits), this.refs);
        };
        this.hash = (level = 3) => {
          return this._hashes[Math.min(this._hashes.length - 1, level)];
        };
        this.depth = (level = 3) => {
          return this._depths[Math.min(this._depths.length - 1, level)];
        };
        this.level = () => {
          return this.mask.level;
        };
        this.equals = (other) => {
          return this.hash().equals(other.hash());
        };
        this[_a] = () => this.toString();
        let bits = BitString_1.BitString.EMPTY;
        if (opts && opts.bits) {
          bits = opts.bits;
        }
        let refs = [];
        if (opts && opts.refs) {
          refs = [...opts.refs];
        }
        let hashes;
        let depths;
        let mask;
        let type = CellType_1.CellType.Ordinary;
        if (opts && opts.exotic) {
          let resolved = (0, resolveExotic_1.resolveExotic)(bits, refs);
          let wonders = (0, wonderCalculator_1.wonderCalculator)(resolved.type, bits, refs);
          mask = wonders.mask;
          depths = wonders.depths;
          hashes = wonders.hashes;
          type = resolved.type;
        } else {
          if (refs.length > 4) {
            throw new Error("Invalid number of references");
          }
          if (bits.length > 1023) {
            throw new Error(`Bits overflow: ${bits.length} > 1023`);
          }
          let wonders = (0, wonderCalculator_1.wonderCalculator)(CellType_1.CellType.Ordinary, bits, refs);
          mask = wonders.mask;
          depths = wonders.depths;
          hashes = wonders.hashes;
          type = CellType_1.CellType.Ordinary;
        }
        this.type = type;
        this.bits = bits;
        this.refs = refs;
        this.mask = mask;
        this._depths = depths;
        this._hashes = hashes;
        Object.freeze(this);
        Object.freeze(this.refs);
        Object.freeze(this.bits);
        Object.freeze(this.mask);
        Object.freeze(this._depths);
        Object.freeze(this._hashes);
      }
      /**
       * Check if cell is exotic
       */
      get isExotic() {
        return this.type !== CellType_1.CellType.Ordinary;
      }
      /**
       * Serializes cell to BOC
       * @param opts options
       */
      toBoc(opts) {
        let idx = opts && opts.idx !== null && opts.idx !== void 0 ? opts.idx : false;
        let crc32 = opts && opts.crc32 !== null && opts.crc32 !== void 0 ? opts.crc32 : true;
        return (0, serialization_1.serializeBoc)(this, { idx, crc32 });
      }
      /**
       * Format cell to string
       * @param indent indentation
       * @returns string representation
       */
      toString(indent) {
        let id = indent || "";
        let t = "x";
        if (this.isExotic) {
          if (this.type === CellType_1.CellType.MerkleProof) {
            t = "p";
          } else if (this.type === CellType_1.CellType.MerkleUpdate) {
            t = "u";
          } else if (this.type === CellType_1.CellType.PrunedBranch) {
            t = "p";
          }
        }
        let s = id + (this.isExotic ? t : "x") + "{" + this.bits.toString() + "}";
        for (let k in this.refs) {
          const i = this.refs[k];
          s += "\n" + i.toString(id + " ");
        }
        return s;
      }
      /**
       * Covnert cell to slice
       * @returns slice
       */
      asSlice() {
        return this.beginParse();
      }
      /**
       * Convert cell to a builder that has this cell stored
       * @returns builder
       */
      asBuilder() {
        return (0, Builder_1.beginCell)().storeSlice(this.asSlice());
      }
    };
    exports.Cell = Cell;
    _a = symbol_inspect_1.default;
    Cell.EMPTY = new Cell();
  }
});

// node_modules/@ton/core/dist/boc/Builder.js
var require_Builder = __commonJS({
  "node_modules/@ton/core/dist/boc/Builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Builder = exports.beginCell = void 0;
    var BitBuilder_1 = require_BitBuilder();
    var Cell_1 = require_Cell();
    var strings_1 = require_strings();
    function beginCell() {
      return new Builder();
    }
    exports.beginCell = beginCell;
    var Builder = class _Builder {
      constructor() {
        this._bits = new BitBuilder_1.BitBuilder();
        this._refs = [];
      }
      /**
       * Bits written so far
       */
      get bits() {
        return this._bits.length;
      }
      /**
       * References written so far
       */
      get refs() {
        return this._refs.length;
      }
      /**
       * Available bits
       */
      get availableBits() {
        return 1023 - this.bits;
      }
      /**
       * Available references
       */
      get availableRefs() {
        return 4 - this.refs;
      }
      /**
       * Write a single bit
       * @param value bit to write, true or positive number for 1, false or zero or negative for 0
       * @returns this builder
       */
      storeBit(value) {
        this._bits.writeBit(value);
        return this;
      }
      /**
       * Write bits from BitString
       * @param src source bits
       * @returns this builder
       */
      storeBits(src) {
        this._bits.writeBits(src);
        return this;
      }
      /**
       * Store Buffer
       * @param src source buffer
       * @param bytes optional number of bytes to write
       * @returns this builder
       */
      storeBuffer(src, bytes) {
        if (bytes !== void 0 && bytes !== null) {
          if (src.length !== bytes) {
            throw Error(`Buffer length ${src.length} is not equal to ${bytes}`);
          }
        }
        this._bits.writeBuffer(src);
        return this;
      }
      /**
       * Store Maybe Buffer
       * @param src source buffer or null
       * @param bytes optional number of bytes to write
       * @returns this builder
       */
      storeMaybeBuffer(src, bytes) {
        if (src !== null) {
          this.storeBit(1);
          this.storeBuffer(src, bytes);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store uint value
       * @param value value as bigint or number
       * @param bits number of bits to write
       * @returns this builder
       */
      storeUint(value, bits) {
        this._bits.writeUint(value, bits);
        return this;
      }
      /**
       * Store maybe uint value
       * @param value value as bigint or number, null or undefined
       * @param bits number of bits to write
       * @returns this builder
       */
      storeMaybeUint(value, bits) {
        if (value !== null && value !== void 0) {
          this.storeBit(1);
          this.storeUint(value, bits);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store int value
       * @param value value as bigint or number
       * @param bits number of bits to write
       * @returns this builder
       */
      storeInt(value, bits) {
        this._bits.writeInt(value, bits);
        return this;
      }
      /**
       * Store maybe int value
       * @param value value as bigint or number, null or undefined
       * @param bits number of bits to write
       * @returns this builder
       */
      storeMaybeInt(value, bits) {
        if (value !== null && value !== void 0) {
          this.storeBit(1);
          this.storeInt(value, bits);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store varuint value
       * @param value value as bigint or number
       * @param bits number of bits to write to header
       * @returns this builder
       */
      storeVarUint(value, bits) {
        this._bits.writeVarUint(value, bits);
        return this;
      }
      /**
       * Store maybe varuint value
       * @param value value as bigint or number, null or undefined
       * @param bits number of bits to write to header
       * @returns this builder
       */
      storeMaybeVarUint(value, bits) {
        if (value !== null && value !== void 0) {
          this.storeBit(1);
          this.storeVarUint(value, bits);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store varint value
       * @param value value as bigint or number
       * @param bits number of bits to write to header
       * @returns this builder
       */
      storeVarInt(value, bits) {
        this._bits.writeVarInt(value, bits);
        return this;
      }
      /**
       * Store maybe varint value
       * @param value value as bigint or number, null or undefined
       * @param bits number of bits to write to header
       * @returns this builder
       */
      storeMaybeVarInt(value, bits) {
        if (value !== null && value !== void 0) {
          this.storeBit(1);
          this.storeVarInt(value, bits);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store coins value
       * @param amount amount of coins
       * @returns this builder
       */
      storeCoins(amount) {
        this._bits.writeCoins(amount);
        return this;
      }
      /**
       * Store maybe coins value
       * @param amount amount of coins, null or undefined
       * @returns this builder
       */
      storeMaybeCoins(amount) {
        if (amount !== null && amount !== void 0) {
          this.storeBit(1);
          this.storeCoins(amount);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store address
       * @param addres address to store
       * @returns this builder
       */
      storeAddress(address) {
        this._bits.writeAddress(address);
        return this;
      }
      /**
       * Store reference
       * @param cell cell or builder to store
       * @returns this builder
       */
      storeRef(cell) {
        if (this._refs.length >= 4) {
          throw new Error("Too many references");
        }
        if (cell instanceof Cell_1.Cell) {
          this._refs.push(cell);
        } else if (cell instanceof _Builder) {
          this._refs.push(cell.endCell());
        } else {
          throw new Error("Invalid argument");
        }
        return this;
      }
      /**
       * Store reference if not null
       * @param cell cell or builder to store
       * @returns this builder
       */
      storeMaybeRef(cell) {
        if (cell) {
          this.storeBit(1);
          this.storeRef(cell);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store slice it in this builder
       * @param src source slice
       */
      storeSlice(src) {
        let c = src.clone();
        if (c.remainingBits > 0) {
          this.storeBits(c.loadBits(c.remainingBits));
        }
        while (c.remainingRefs > 0) {
          this.storeRef(c.loadRef());
        }
        return this;
      }
      /**
       * Store slice in this builder if not null
       * @param src source slice
       */
      storeMaybeSlice(src) {
        if (src) {
          this.storeBit(1);
          this.storeSlice(src);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store builder
       * @param src builder to store
       * @returns this builder
       */
      storeBuilder(src) {
        return this.storeSlice(src.endCell().beginParse());
      }
      /**
       * Store builder if not null
       * @param src builder to store
       * @returns this builder
       */
      storeMaybeBuilder(src) {
        if (src) {
          this.storeBit(1);
          this.storeBuilder(src);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store writer or builder
       * @param writer writer or builder to store
       * @returns this builder
       */
      storeWritable(writer) {
        if (typeof writer === "object") {
          writer.writeTo(this);
        } else {
          writer(this);
        }
        return this;
      }
      /**
       * Store writer or builder if not null
       * @param writer writer or builder to store
       * @returns this builder
       */
      storeMaybeWritable(writer) {
        if (writer) {
          this.storeBit(1);
          this.storeWritable(writer);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store object in this builder
       * @param writer Writable or writer functuin
       */
      store(writer) {
        this.storeWritable(writer);
        return this;
      }
      /**
       * Store string tail
       * @param src source string
       * @returns this builder
       */
      storeStringTail(src) {
        (0, strings_1.writeString)(src, this);
        return this;
      }
      /**
       * Store string tail
       * @param src source string
       * @returns this builder
       */
      storeMaybeStringTail(src) {
        if (src !== null && src !== void 0) {
          this.storeBit(1);
          (0, strings_1.writeString)(src, this);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store string tail in ref
       * @param src source string
       * @returns this builder
       */
      storeStringRefTail(src) {
        this.storeRef(beginCell().storeStringTail(src));
        return this;
      }
      /**
       * Store maybe string tail in ref
       * @param src source string
       * @returns this builder
       */
      storeMaybeStringRefTail(src) {
        if (src !== null && src !== void 0) {
          this.storeBit(1);
          this.storeStringRefTail(src);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store dictionary in this builder
       * @param dict dictionary to store
       * @returns this builder
       */
      storeDict(dict, key, value) {
        if (dict) {
          dict.store(this, key, value);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store dictionary in this builder directly
       * @param dict dictionary to store
       * @returns this builder
       */
      storeDictDirect(dict, key, value) {
        dict.storeDirect(this, key, value);
        return this;
      }
      /**
       * Complete cell
       * @param opts options
       * @returns cell
       */
      endCell(opts) {
        return new Cell_1.Cell({
          bits: this._bits.build(),
          refs: this._refs,
          exotic: opts == null ? void 0 : opts.exotic
        });
      }
      /**
       * Convert to cell
       * @returns cell
       */
      asCell() {
        return this.endCell();
      }
      /**
       * Convert to slice
       * @returns slice
       */
      asSlice() {
        return this.endCell().beginParse();
      }
    };
    exports.Builder = Builder;
  }
});

// node_modules/@ton/core/dist/types/SimpleLibrary.js
var require_SimpleLibrary = __commonJS({
  "node_modules/@ton/core/dist/types/SimpleLibrary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimpleLibraryValue = exports.storeSimpleLibrary = exports.loadSimpleLibrary = void 0;
    function loadSimpleLibrary(slice) {
      return {
        public: slice.loadBit(),
        root: slice.loadRef()
      };
    }
    exports.loadSimpleLibrary = loadSimpleLibrary;
    function storeSimpleLibrary(src) {
      return (builder) => {
        builder.storeBit(src.public);
        builder.storeRef(src.root);
      };
    }
    exports.storeSimpleLibrary = storeSimpleLibrary;
    exports.SimpleLibraryValue = {
      serialize(src, builder) {
        storeSimpleLibrary(src)(builder);
      },
      parse(src) {
        return loadSimpleLibrary(src);
      }
    };
  }
});

// node_modules/@ton/core/dist/types/TickTock.js
var require_TickTock = __commonJS({
  "node_modules/@ton/core/dist/types/TickTock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTickTock = exports.loadTickTock = void 0;
    function loadTickTock(slice) {
      return {
        tick: slice.loadBit(),
        tock: slice.loadBit()
      };
    }
    exports.loadTickTock = loadTickTock;
    function storeTickTock(src) {
      return (builder) => {
        builder.storeBit(src.tick);
        builder.storeBit(src.tock);
      };
    }
    exports.storeTickTock = storeTickTock;
  }
});

// node_modules/@ton/core/dist/types/StateInit.js
var require_StateInit = __commonJS({
  "node_modules/@ton/core/dist/types/StateInit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeStateInit = exports.loadStateInit = void 0;
    var Dictionary_1 = require_Dictionary();
    var SimpleLibrary_1 = require_SimpleLibrary();
    var TickTock_1 = require_TickTock();
    function loadStateInit(slice) {
      let splitDepth;
      if (slice.loadBit()) {
        splitDepth = slice.loadUint(5);
      }
      let special;
      if (slice.loadBit()) {
        special = (0, TickTock_1.loadTickTock)(slice);
      }
      let code = slice.loadMaybeRef();
      let data = slice.loadMaybeRef();
      let libraries = slice.loadDict(Dictionary_1.Dictionary.Keys.BigUint(256), SimpleLibrary_1.SimpleLibraryValue);
      if (libraries.size === 0) {
        libraries = void 0;
      }
      return {
        splitDepth,
        special,
        code,
        data,
        libraries
      };
    }
    exports.loadStateInit = loadStateInit;
    function storeStateInit(src) {
      return (builder) => {
        if (src.splitDepth !== null && src.splitDepth !== void 0) {
          builder.storeBit(true);
          builder.storeUint(src.splitDepth, 5);
        } else {
          builder.storeBit(false);
        }
        if (src.special !== null && src.special !== void 0) {
          builder.storeBit(true);
          builder.store((0, TickTock_1.storeTickTock)(src.special));
        } else {
          builder.storeBit(false);
        }
        builder.storeMaybeRef(src.code);
        builder.storeMaybeRef(src.data);
        builder.storeDict(src.libraries);
      };
    }
    exports.storeStateInit = storeStateInit;
  }
});

// node_modules/@ton/core/dist/address/contractAddress.js
var require_contractAddress = __commonJS({
  "node_modules/@ton/core/dist/address/contractAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contractAddress = void 0;
    var Builder_1 = require_Builder();
    var StateInit_1 = require_StateInit();
    var Address_1 = require_Address();
    function contractAddress(workchain, init) {
      let hash = (0, Builder_1.beginCell)().store((0, StateInit_1.storeStateInit)(init)).endCell().hash();
      return new Address_1.Address(workchain, hash);
    }
    exports.contractAddress = contractAddress;
  }
});

// node_modules/@ton/core/dist/tuple/tuple.js
var require_tuple = __commonJS({
  "node_modules/@ton/core/dist/tuple/tuple.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTuple = exports.serializeTuple = void 0;
    var Builder_1 = require_Builder();
    var INT64_MIN = BigInt("-9223372036854775808");
    var INT64_MAX = BigInt("9223372036854775807");
    function serializeTupleItem(src, builder) {
      if (src.type === "null") {
        builder.storeUint(0, 8);
      } else if (src.type === "int") {
        if (src.value <= INT64_MAX && src.value >= INT64_MIN) {
          builder.storeUint(1, 8);
          builder.storeInt(src.value, 64);
        } else {
          builder.storeUint(256, 15);
          builder.storeInt(src.value, 257);
        }
      } else if (src.type === "nan") {
        builder.storeInt(767, 16);
      } else if (src.type === "cell") {
        builder.storeUint(3, 8);
        builder.storeRef(src.cell);
      } else if (src.type === "slice") {
        builder.storeUint(4, 8);
        builder.storeUint(0, 10);
        builder.storeUint(src.cell.bits.length, 10);
        builder.storeUint(0, 3);
        builder.storeUint(src.cell.refs.length, 3);
        builder.storeRef(src.cell);
      } else if (src.type === "builder") {
        builder.storeUint(5, 8);
        builder.storeRef(src.cell);
      } else if (src.type === "tuple") {
        let head = null;
        let tail = null;
        for (let i = 0; i < src.items.length; i++) {
          let s = head;
          head = tail;
          tail = s;
          if (i > 1) {
            head = (0, Builder_1.beginCell)().storeRef(tail).storeRef(head).endCell();
          }
          let bc = (0, Builder_1.beginCell)();
          serializeTupleItem(src.items[i], bc);
          tail = bc.endCell();
        }
        builder.storeUint(7, 8);
        builder.storeUint(src.items.length, 16);
        if (head) {
          builder.storeRef(head);
        }
        if (tail) {
          builder.storeRef(tail);
        }
      } else {
        throw Error("Invalid value");
      }
    }
    function parseStackItem(cs) {
      let kind = cs.loadUint(8);
      if (kind === 0) {
        return { type: "null" };
      } else if (kind === 1) {
        return { type: "int", value: cs.loadIntBig(64) };
      } else if (kind === 2) {
        if (cs.loadUint(7) === 0) {
          return { type: "int", value: cs.loadIntBig(257) };
        } else {
          cs.loadBit();
          return { type: "nan" };
        }
      } else if (kind === 3) {
        return { type: "cell", cell: cs.loadRef() };
      } else if (kind === 4) {
        let startBits = cs.loadUint(10);
        let endBits = cs.loadUint(10);
        let startRefs = cs.loadUint(3);
        let endRefs = cs.loadUint(3);
        let rs = cs.loadRef().beginParse();
        rs.skip(startBits);
        let dt = rs.loadBits(endBits - startBits);
        let builder = (0, Builder_1.beginCell)().storeBits(dt);
        if (startRefs < endRefs) {
          for (let i = 0; i < startRefs; i++) {
            rs.loadRef();
          }
          for (let i = 0; i < endRefs - startRefs; i++) {
            builder.storeRef(rs.loadRef());
          }
        }
        return { type: "slice", cell: builder.endCell() };
      } else if (kind === 5) {
        return { type: "builder", cell: cs.loadRef() };
      } else if (kind === 7) {
        let length = cs.loadUint(16);
        let items = [];
        if (length > 1) {
          let head = cs.loadRef().beginParse();
          let tail = cs.loadRef().beginParse();
          items.unshift(parseStackItem(tail));
          for (let i = 0; i < length - 2; i++) {
            let ohead = head;
            head = ohead.loadRef().beginParse();
            tail = ohead.loadRef().beginParse();
            items.unshift(parseStackItem(tail));
          }
          items.unshift(parseStackItem(head));
        } else if (length === 1) {
          items.push(parseStackItem(cs.loadRef().beginParse()));
        }
        return { type: "tuple", items };
      } else {
        throw Error("Unsupported stack item");
      }
    }
    function serializeTupleTail(src, builder) {
      if (src.length > 0) {
        let tail = (0, Builder_1.beginCell)();
        serializeTupleTail(src.slice(0, src.length - 1), tail);
        builder.storeRef(tail.endCell());
        serializeTupleItem(src[src.length - 1], builder);
      }
    }
    function serializeTuple(src) {
      let builder = (0, Builder_1.beginCell)();
      builder.storeUint(src.length, 24);
      let r = [...src];
      serializeTupleTail(r, builder);
      return builder.endCell();
    }
    exports.serializeTuple = serializeTuple;
    function parseTuple(src) {
      let res = [];
      let cs = src.beginParse();
      let size = cs.loadUint(24);
      for (let i = 0; i < size; i++) {
        let next = cs.loadRef();
        res.unshift(parseStackItem(cs));
        cs = next.beginParse();
      }
      return res;
    }
    exports.parseTuple = parseTuple;
  }
});

// node_modules/@ton/core/dist/tuple/reader.js
var require_reader = __commonJS({
  "node_modules/@ton/core/dist/tuple/reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TupleReader = void 0;
    var TupleReader = class _TupleReader {
      constructor(items) {
        this.items = [...items];
      }
      get remaining() {
        return this.items.length;
      }
      peek() {
        if (this.items.length === 0) {
          throw Error("EOF");
        }
        return this.items[0];
      }
      pop() {
        if (this.items.length === 0) {
          throw Error("EOF");
        }
        let res = this.items[0];
        this.items.splice(0, 1);
        return res;
      }
      skip(num = 1) {
        for (let i = 0; i < num; i++) {
          this.pop();
        }
        return this;
      }
      readBigNumber() {
        let popped = this.pop();
        if (popped.type !== "int") {
          throw Error("Not a number");
        }
        return popped.value;
      }
      readBigNumberOpt() {
        let popped = this.pop();
        if (popped.type === "null") {
          return null;
        }
        if (popped.type !== "int") {
          throw Error("Not a number");
        }
        return popped.value;
      }
      readNumber() {
        return Number(this.readBigNumber());
      }
      readNumberOpt() {
        let r = this.readBigNumberOpt();
        if (r !== null) {
          return Number(r);
        } else {
          return null;
        }
      }
      readBoolean() {
        let res = this.readNumber();
        return res === 0 ? false : true;
      }
      readBooleanOpt() {
        let res = this.readNumberOpt();
        if (res !== null) {
          return res === 0 ? false : true;
        } else {
          return null;
        }
      }
      readAddress() {
        let r = this.readCell().beginParse().loadAddress();
        if (r !== null) {
          return r;
        } else {
          throw Error("Not an address");
        }
      }
      readAddressOpt() {
        let r = this.readCellOpt();
        if (r !== null) {
          return r.beginParse().loadMaybeAddress();
        } else {
          return null;
        }
      }
      readCell() {
        let popped = this.pop();
        if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
          throw Error("Not a cell: " + popped.type);
        }
        return popped.cell;
      }
      readCellOpt() {
        let popped = this.pop();
        if (popped.type === "null") {
          return null;
        }
        if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
          throw Error("Not a cell");
        }
        return popped.cell;
      }
      readTuple() {
        let popped = this.pop();
        if (popped.type !== "tuple") {
          throw Error("Not a tuple");
        }
        return new _TupleReader(popped.items);
      }
      readTupleOpt() {
        let popped = this.pop();
        if (popped.type === "null") {
          return null;
        }
        if (popped.type !== "tuple") {
          throw Error("Not a tuple");
        }
        return new _TupleReader(popped.items);
      }
      static readLispList(reader) {
        const result = [];
        let tail = reader;
        while (tail !== null) {
          var head = tail.pop();
          if (tail.items.length === 0 || tail.items[0].type !== "tuple" && tail.items[0].type !== "null") {
            throw Error("Lisp list consists only from (any, tuple) elements and ends with null");
          }
          tail = tail.readTupleOpt();
          result.push(head);
        }
        return result;
      }
      readLispListDirect() {
        if (this.items.length === 1 && this.items[0].type === "null") {
          return [];
        }
        return _TupleReader.readLispList(this);
      }
      readLispList() {
        return _TupleReader.readLispList(this.readTupleOpt());
      }
      readBuffer() {
        let s = this.readCell().beginParse();
        if (s.remainingRefs !== 0) {
          throw Error("Not a buffer");
        }
        if (s.remainingBits % 8 !== 0) {
          throw Error("Not a buffer");
        }
        return s.loadBuffer(s.remainingBits / 8);
      }
      readBufferOpt() {
        let popped = this.peek();
        if (popped.type === "null") {
          return null;
        }
        let s = this.readCell().beginParse();
        if (s.remainingRefs !== 0) {
          throw Error("Not a buffer");
        }
        if (s.remainingBits % 8 !== 0) {
          throw Error("Not a buffer");
        }
        return s.loadBuffer(s.remainingBits / 8);
      }
      readString() {
        let s = this.readCell().beginParse();
        return s.loadStringTail();
      }
      readStringOpt() {
        let popped = this.peek();
        if (popped.type === "null") {
          return null;
        }
        let s = this.readCell().beginParse();
        return s.loadStringTail();
      }
    };
    exports.TupleReader = TupleReader;
  }
});

// node_modules/@ton/core/dist/tuple/builder.js
var require_builder = __commonJS({
  "node_modules/@ton/core/dist/tuple/builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TupleBuilder = void 0;
    var Builder_1 = require_Builder();
    var Cell_1 = require_Cell();
    var Slice_1 = require_Slice();
    var TupleBuilder = class {
      constructor() {
        this._tuple = [];
      }
      writeNumber(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          this._tuple.push({ type: "int", value: BigInt(v) });
        }
      }
      writeBoolean(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          this._tuple.push({ type: "int", value: v ? -1n : 0n });
        }
      }
      writeBuffer(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          this._tuple.push({ type: "slice", cell: (0, Builder_1.beginCell)().storeBuffer(v).endCell() });
        }
      }
      writeString(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          this._tuple.push({ type: "slice", cell: (0, Builder_1.beginCell)().storeStringTail(v).endCell() });
        }
      }
      writeCell(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          if (v instanceof Cell_1.Cell) {
            this._tuple.push({ type: "cell", cell: v });
          } else if (v instanceof Slice_1.Slice) {
            this._tuple.push({ type: "cell", cell: v.asCell() });
          }
        }
      }
      writeSlice(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          if (v instanceof Cell_1.Cell) {
            this._tuple.push({ type: "slice", cell: v });
          } else if (v instanceof Slice_1.Slice) {
            this._tuple.push({ type: "slice", cell: v.asCell() });
          }
        }
      }
      writeBuilder(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          if (v instanceof Cell_1.Cell) {
            this._tuple.push({ type: "builder", cell: v });
          } else if (v instanceof Slice_1.Slice) {
            this._tuple.push({ type: "builder", cell: v.asCell() });
          }
        }
      }
      writeTuple(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          this._tuple.push({ type: "tuple", items: v });
        }
      }
      writeAddress(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          this._tuple.push({ type: "slice", cell: (0, Builder_1.beginCell)().storeAddress(v).endCell() });
        }
      }
      build() {
        return [...this._tuple];
      }
    };
    exports.TupleBuilder = TupleBuilder;
  }
});

// node_modules/@ton/core/dist/utils/convert.js
var require_convert = __commonJS({
  "node_modules/@ton/core/dist/utils/convert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromNano = exports.toNano = void 0;
    function toNano(src) {
      if (typeof src === "bigint") {
        return src * 1000000000n;
      } else {
        if (typeof src === "number") {
          if (!Number.isFinite(src)) {
            throw Error("Invalid number");
          }
          if (Math.log10(src) <= 6) {
            src = src.toLocaleString("en", { minimumFractionDigits: 9, useGrouping: false });
          } else if (src - Math.trunc(src) === 0) {
            src = src.toLocaleString("en", { maximumFractionDigits: 0, useGrouping: false });
          } else {
            throw Error("Not enough precision for a number value. Use string value instead");
          }
        }
        let neg = false;
        while (src.startsWith("-")) {
          neg = !neg;
          src = src.slice(1);
        }
        if (src === ".") {
          throw Error("Invalid number");
        }
        let parts = src.split(".");
        if (parts.length > 2) {
          throw Error("Invalid number");
        }
        let whole = parts[0];
        let frac = parts[1];
        if (!whole) {
          whole = "0";
        }
        if (!frac) {
          frac = "0";
        }
        if (frac.length > 9) {
          throw Error("Invalid number");
        }
        while (frac.length < 9) {
          frac += "0";
        }
        let r = BigInt(whole) * 1000000000n + BigInt(frac);
        if (neg) {
          r = -r;
        }
        return r;
      }
    }
    exports.toNano = toNano;
    function fromNano(src) {
      let v = BigInt(src);
      let neg = false;
      if (v < 0) {
        neg = true;
        v = -v;
      }
      let frac = v % 1000000000n;
      let facStr = frac.toString();
      while (facStr.length < 9) {
        facStr = "0" + facStr;
      }
      facStr = facStr.match(/^([0-9]*[1-9]|0)(0*)/)[1];
      let whole = v / 1000000000n;
      let wholeStr = whole.toString();
      let value = `${wholeStr}${facStr === "0" ? "" : `.${facStr}`}`;
      if (neg) {
        value = "-" + value;
      }
      return value;
    }
    exports.fromNano = fromNano;
  }
});

// node_modules/@ton/core/dist/types/_helpers.js
var require_helpers = __commonJS({
  "node_modules/@ton/core/dist/types/_helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.comment = exports.external = exports.internal = void 0;
    var Address_1 = require_Address();
    var Cell_1 = require_Cell();
    var Builder_1 = require_Builder();
    var convert_1 = require_convert();
    function internal(src) {
      let bounce = true;
      if (src.bounce !== null && src.bounce !== void 0) {
        bounce = src.bounce;
      }
      let to;
      if (typeof src.to === "string") {
        to = Address_1.Address.parse(src.to);
      } else if (Address_1.Address.isAddress(src.to)) {
        to = src.to;
      } else {
        throw new Error(`Invalid address ${src.to}`);
      }
      let value;
      if (typeof src.value === "string") {
        value = (0, convert_1.toNano)(src.value);
      } else {
        value = src.value;
      }
      let body = Cell_1.Cell.EMPTY;
      if (typeof src.body === "string") {
        body = (0, Builder_1.beginCell)().storeUint(0, 32).storeStringTail(src.body).endCell();
      } else if (src.body) {
        body = src.body;
      }
      return {
        info: {
          type: "internal",
          dest: to,
          value: { coins: value },
          bounce,
          ihrDisabled: true,
          bounced: false,
          ihrFee: 0n,
          forwardFee: 0n,
          createdAt: 0,
          createdLt: 0n
        },
        init: src.init ?? void 0,
        body
      };
    }
    exports.internal = internal;
    function external(src) {
      let to;
      if (typeof src.to === "string") {
        to = Address_1.Address.parse(src.to);
      } else if (Address_1.Address.isAddress(src.to)) {
        to = src.to;
      } else {
        throw new Error(`Invalid address ${src.to}`);
      }
      return {
        info: {
          type: "external-in",
          dest: to,
          importFee: 0n
        },
        init: src.init ?? void 0,
        body: src.body || Cell_1.Cell.EMPTY
      };
    }
    exports.external = external;
    function comment(src) {
      return (0, Builder_1.beginCell)().storeUint(0, 32).storeStringTail(src).endCell();
    }
    exports.comment = comment;
  }
});

// node_modules/@ton/core/dist/types/AccountState.js
var require_AccountState = __commonJS({
  "node_modules/@ton/core/dist/types/AccountState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeAccountState = exports.loadAccountState = void 0;
    var StateInit_1 = require_StateInit();
    function loadAccountState(cs) {
      if (cs.loadBit()) {
        return { type: "active", state: (0, StateInit_1.loadStateInit)(cs) };
      } else if (cs.loadBit()) {
        return { type: "frozen", stateHash: cs.loadUintBig(256) };
      } else {
        return { type: "uninit" };
      }
    }
    exports.loadAccountState = loadAccountState;
    function storeAccountState(src) {
      return (builder) => {
        if (src.type === "active") {
          builder.storeBit(true);
          builder.store((0, StateInit_1.storeStateInit)(src.state));
        } else if (src.type === "frozen") {
          builder.storeBit(false);
          builder.storeBit(true);
          builder.storeUint(src.stateHash, 256);
        } else if (src.type === "uninit") {
          builder.storeBit(false);
          builder.storeBit(false);
        }
      };
    }
    exports.storeAccountState = storeAccountState;
  }
});

// node_modules/@ton/core/dist/types/CurrencyCollection.js
var require_CurrencyCollection = __commonJS({
  "node_modules/@ton/core/dist/types/CurrencyCollection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeCurrencyCollection = exports.loadCurrencyCollection = void 0;
    var Dictionary_1 = require_Dictionary();
    function loadCurrencyCollection(slice) {
      const coins = slice.loadCoins();
      const other = slice.loadDict(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(
        5
        /* log2(32) */
      ));
      if (other.size === 0) {
        return { coins };
      } else {
        return { other, coins };
      }
    }
    exports.loadCurrencyCollection = loadCurrencyCollection;
    function storeCurrencyCollection(collection) {
      return (builder) => {
        builder.storeCoins(collection.coins);
        if (collection.other) {
          builder.storeDict(collection.other);
        } else {
          builder.storeBit(0);
        }
      };
    }
    exports.storeCurrencyCollection = storeCurrencyCollection;
  }
});

// node_modules/@ton/core/dist/types/AccountStorage.js
var require_AccountStorage = __commonJS({
  "node_modules/@ton/core/dist/types/AccountStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeAccountStorage = exports.loadAccountStorage = void 0;
    var AccountState_1 = require_AccountState();
    var CurrencyCollection_1 = require_CurrencyCollection();
    function loadAccountStorage(slice) {
      return {
        lastTransLt: slice.loadUintBig(64),
        balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice),
        state: (0, AccountState_1.loadAccountState)(slice)
      };
    }
    exports.loadAccountStorage = loadAccountStorage;
    function storeAccountStorage(src) {
      return (builder) => {
        builder.storeUint(src.lastTransLt, 64);
        builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.balance));
        builder.store((0, AccountState_1.storeAccountState)(src.state));
      };
    }
    exports.storeAccountStorage = storeAccountStorage;
  }
});

// node_modules/@ton/core/dist/types/StorageUsed.js
var require_StorageUsed = __commonJS({
  "node_modules/@ton/core/dist/types/StorageUsed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeStorageUsed = exports.loadStorageUsed = void 0;
    function loadStorageUsed(cs) {
      return {
        cells: cs.loadVarUintBig(3),
        bits: cs.loadVarUintBig(3),
        publicCells: cs.loadVarUintBig(3)
      };
    }
    exports.loadStorageUsed = loadStorageUsed;
    function storeStorageUsed(src) {
      return (builder) => {
        builder.storeVarUint(src.cells, 3);
        builder.storeVarUint(src.bits, 3);
        builder.storeVarUint(src.publicCells, 3);
      };
    }
    exports.storeStorageUsed = storeStorageUsed;
  }
});

// node_modules/@ton/core/dist/types/StorageInto.js
var require_StorageInto = __commonJS({
  "node_modules/@ton/core/dist/types/StorageInto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeStorageInfo = exports.loadStorageInfo = void 0;
    var StorageUsed_1 = require_StorageUsed();
    function loadStorageInfo(slice) {
      return {
        used: (0, StorageUsed_1.loadStorageUsed)(slice),
        lastPaid: slice.loadUint(32),
        duePayment: slice.loadMaybeCoins()
      };
    }
    exports.loadStorageInfo = loadStorageInfo;
    function storeStorageInfo(src) {
      return (builder) => {
        builder.store((0, StorageUsed_1.storeStorageUsed)(src.used));
        builder.storeUint(src.lastPaid, 32);
        builder.storeMaybeCoins(src.duePayment);
      };
    }
    exports.storeStorageInfo = storeStorageInfo;
  }
});

// node_modules/@ton/core/dist/types/Account.js
var require_Account = __commonJS({
  "node_modules/@ton/core/dist/types/Account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeAccount = exports.loadAccount = void 0;
    var AccountStorage_1 = require_AccountStorage();
    var StorageInto_1 = require_StorageInto();
    function loadAccount(slice) {
      return {
        addr: slice.loadAddress(),
        storageStats: (0, StorageInto_1.loadStorageInfo)(slice),
        storage: (0, AccountStorage_1.loadAccountStorage)(slice)
      };
    }
    exports.loadAccount = loadAccount;
    function storeAccount(src) {
      return (builder) => {
        builder.storeAddress(src.addr);
        builder.store((0, StorageInto_1.storeStorageInfo)(src.storageStats));
        builder.store((0, AccountStorage_1.storeAccountStorage)(src.storage));
      };
    }
    exports.storeAccount = storeAccount;
  }
});

// node_modules/@ton/core/dist/types/AccountStatus.js
var require_AccountStatus = __commonJS({
  "node_modules/@ton/core/dist/types/AccountStatus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeAccountStatus = exports.loadAccountStatus = void 0;
    function loadAccountStatus(slice) {
      const status = slice.loadUint(2);
      if (status === 0) {
        return "uninitialized";
      }
      if (status === 1) {
        return "frozen";
      }
      if (status === 2) {
        return "active";
      }
      if (status === 3) {
        return "non-existing";
      }
      throw Error("Invalid data");
    }
    exports.loadAccountStatus = loadAccountStatus;
    function storeAccountStatus(src) {
      return (builder) => {
        if (src === "uninitialized") {
          builder.storeUint(0, 2);
        } else if (src === "frozen") {
          builder.storeUint(1, 2);
        } else if (src === "active") {
          builder.storeUint(2, 2);
        } else if (src === "non-existing") {
          builder.storeUint(3, 2);
        } else {
          throw Error("Invalid data");
        }
        return builder;
      };
    }
    exports.storeAccountStatus = storeAccountStatus;
  }
});

// node_modules/@ton/core/dist/types/AccountStatusChange.js
var require_AccountStatusChange = __commonJS({
  "node_modules/@ton/core/dist/types/AccountStatusChange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeAccountStatusChange = exports.loadAccountStatusChange = void 0;
    function loadAccountStatusChange(slice) {
      if (!slice.loadBit()) {
        return "unchanged";
      }
      if (slice.loadBit()) {
        return "deleted";
      } else {
        return "frozen";
      }
    }
    exports.loadAccountStatusChange = loadAccountStatusChange;
    function storeAccountStatusChange(src) {
      return (builder) => {
        if (src == "unchanged") {
          builder.storeBit(0);
        } else if (src === "frozen") {
          builder.storeBit(1);
          builder.storeBit(0);
        } else if (src === "deleted") {
          builder.storeBit(1);
          builder.storeBit(1);
        } else {
          throw Error("Invalid account status change");
        }
      };
    }
    exports.storeAccountStatusChange = storeAccountStatusChange;
  }
});

// node_modules/@ton/core/dist/types/CommonMessageInfoRelaxed.js
var require_CommonMessageInfoRelaxed = __commonJS({
  "node_modules/@ton/core/dist/types/CommonMessageInfoRelaxed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeCommonMessageInfoRelaxed = exports.loadCommonMessageInfoRelaxed = void 0;
    var CurrencyCollection_1 = require_CurrencyCollection();
    function loadCommonMessageInfoRelaxed(slice) {
      if (!slice.loadBit()) {
        const ihrDisabled = slice.loadBit();
        const bounce = slice.loadBit();
        const bounced = slice.loadBit();
        const src2 = slice.loadMaybeAddress();
        const dest2 = slice.loadAddress();
        const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
        const ihrFee = slice.loadCoins();
        const forwardFee = slice.loadCoins();
        const createdLt2 = slice.loadUintBig(64);
        const createdAt2 = slice.loadUint(32);
        return {
          type: "internal",
          ihrDisabled,
          bounce,
          bounced,
          src: src2,
          dest: dest2,
          value,
          ihrFee,
          forwardFee,
          createdLt: createdLt2,
          createdAt: createdAt2
        };
      }
      if (!slice.loadBit()) {
        throw Error("External In message is not possible for CommonMessageInfoRelaxed");
      }
      const src = slice.loadMaybeAddress();
      const dest = slice.loadMaybeExternalAddress();
      const createdLt = slice.loadUintBig(64);
      const createdAt = slice.loadUint(32);
      return {
        type: "external-out",
        src,
        dest,
        createdLt,
        createdAt
      };
    }
    exports.loadCommonMessageInfoRelaxed = loadCommonMessageInfoRelaxed;
    function storeCommonMessageInfoRelaxed(source) {
      return (builder) => {
        if (source.type === "internal") {
          builder.storeBit(0);
          builder.storeBit(source.ihrDisabled);
          builder.storeBit(source.bounce);
          builder.storeBit(source.bounced);
          builder.storeAddress(source.src);
          builder.storeAddress(source.dest);
          builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
          builder.storeCoins(source.ihrFee);
          builder.storeCoins(source.forwardFee);
          builder.storeUint(source.createdLt, 64);
          builder.storeUint(source.createdAt, 32);
        } else if (source.type === "external-out") {
          builder.storeBit(1);
          builder.storeBit(1);
          builder.storeAddress(source.src);
          builder.storeAddress(source.dest);
          builder.storeUint(source.createdLt, 64);
          builder.storeUint(source.createdAt, 32);
        } else {
          throw new Error("Unknown CommonMessageInfo type");
        }
      };
    }
    exports.storeCommonMessageInfoRelaxed = storeCommonMessageInfoRelaxed;
  }
});

// node_modules/@ton/core/dist/types/MessageRelaxed.js
var require_MessageRelaxed = __commonJS({
  "node_modules/@ton/core/dist/types/MessageRelaxed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeMessageRelaxed = exports.loadMessageRelaxed = void 0;
    var Builder_1 = require_Builder();
    var CommonMessageInfoRelaxed_1 = require_CommonMessageInfoRelaxed();
    var StateInit_1 = require_StateInit();
    function loadMessageRelaxed(slice) {
      const info = (0, CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed)(slice);
      let init = null;
      if (slice.loadBit()) {
        if (!slice.loadBit()) {
          init = (0, StateInit_1.loadStateInit)(slice);
        } else {
          init = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
        }
      }
      const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
      return {
        info,
        init,
        body
      };
    }
    exports.loadMessageRelaxed = loadMessageRelaxed;
    function storeMessageRelaxed(message, opts) {
      return (builder) => {
        builder.store((0, CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed)(message.info));
        if (message.init) {
          builder.storeBit(true);
          let initCell = (0, Builder_1.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
          let needRef2 = false;
          if (opts && opts.forceRef) {
            needRef2 = true;
          } else {
            if (builder.availableBits - 2 >= initCell.bits) {
              needRef2 = false;
            } else {
              needRef2 = true;
            }
          }
          if (needRef2) {
            builder.storeBit(true);
            builder.storeRef(initCell);
          } else {
            builder.storeBit(false);
            builder.storeBuilder(initCell);
          }
        } else {
          builder.storeBit(false);
        }
        let needRef = false;
        if (opts && opts.forceRef) {
          needRef = true;
        } else {
          if (builder.availableBits - 1 >= message.body.bits.length && builder.refs + message.body.refs.length <= 4 && !message.body.isExotic) {
            needRef = false;
          } else {
            needRef = true;
          }
        }
        if (needRef) {
          builder.storeBit(true);
          builder.storeRef(message.body);
        } else {
          builder.storeBit(false);
          builder.storeBuilder(message.body.asBuilder());
        }
      };
    }
    exports.storeMessageRelaxed = storeMessageRelaxed;
  }
});

// node_modules/@ton/core/dist/types/OutList.js
var require_OutList = __commonJS({
  "node_modules/@ton/core/dist/types/OutList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadOutList = exports.storeOutList = exports.loadOutAction = exports.storeOutAction = void 0;
    var MessageRelaxed_1 = require_MessageRelaxed();
    var Builder_1 = require_Builder();
    function storeOutAction(action) {
      switch (action.type) {
        case "sendMsg":
          return storeOutActionSendMsg(action);
        case "setCode":
          return storeOutActionSetCode(action);
        default:
          throw new Error(`Unknown action type ${action.type}`);
      }
    }
    exports.storeOutAction = storeOutAction;
    var outActionSendMsgTag = 247711853;
    function storeOutActionSendMsg(action) {
      return (builder) => {
        builder.storeUint(outActionSendMsgTag, 32).storeUint(action.mode, 8).storeRef((0, Builder_1.beginCell)().store((0, MessageRelaxed_1.storeMessageRelaxed)(action.outMsg)).endCell());
      };
    }
    var outActionSetCodeTag = 2907562126;
    function storeOutActionSetCode(action) {
      return (builder) => {
        builder.storeUint(outActionSetCodeTag, 32).storeRef(action.newCode);
      };
    }
    function loadOutAction(slice) {
      const tag = slice.loadUint(32);
      if (tag === outActionSendMsgTag) {
        const mode = slice.loadUint(8);
        const outMsg = (0, MessageRelaxed_1.loadMessageRelaxed)(slice.loadRef().beginParse());
        return {
          type: "sendMsg",
          mode,
          outMsg
        };
      }
      if (tag === outActionSetCodeTag) {
        const newCode = slice.loadRef();
        return {
          type: "setCode",
          newCode
        };
      }
      throw new Error(`Unknown out action tag 0x${tag.toString(16)}`);
    }
    exports.loadOutAction = loadOutAction;
    function storeOutList(actions) {
      const cell = actions.reduce((cell2, action) => (0, Builder_1.beginCell)().storeRef(cell2).store(storeOutAction(action)).endCell(), (0, Builder_1.beginCell)().endCell());
      return (builder) => {
        builder.storeSlice(cell.beginParse());
      };
    }
    exports.storeOutList = storeOutList;
    function loadOutList(slice) {
      const actions = [];
      while (slice.remainingRefs) {
        const nextCell = slice.loadRef();
        actions.push(loadOutAction(slice));
        slice = nextCell.beginParse();
      }
      return actions.reverse();
    }
    exports.loadOutList = loadOutList;
  }
});

// node_modules/@ton/core/dist/types/CommonMessageInfo.js
var require_CommonMessageInfo = __commonJS({
  "node_modules/@ton/core/dist/types/CommonMessageInfo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeCommonMessageInfo = exports.loadCommonMessageInfo = void 0;
    var CurrencyCollection_1 = require_CurrencyCollection();
    function loadCommonMessageInfo(slice) {
      if (!slice.loadBit()) {
        const ihrDisabled = slice.loadBit();
        const bounce = slice.loadBit();
        const bounced = slice.loadBit();
        const src2 = slice.loadAddress();
        const dest2 = slice.loadAddress();
        const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
        const ihrFee = slice.loadCoins();
        const forwardFee = slice.loadCoins();
        const createdLt2 = slice.loadUintBig(64);
        const createdAt2 = slice.loadUint(32);
        return {
          type: "internal",
          ihrDisabled,
          bounce,
          bounced,
          src: src2,
          dest: dest2,
          value,
          ihrFee,
          forwardFee,
          createdLt: createdLt2,
          createdAt: createdAt2
        };
      }
      if (!slice.loadBit()) {
        const src2 = slice.loadMaybeExternalAddress();
        const dest2 = slice.loadAddress();
        const importFee = slice.loadCoins();
        return {
          type: "external-in",
          src: src2,
          dest: dest2,
          importFee
        };
      }
      const src = slice.loadAddress();
      const dest = slice.loadMaybeExternalAddress();
      const createdLt = slice.loadUintBig(64);
      const createdAt = slice.loadUint(32);
      return {
        type: "external-out",
        src,
        dest,
        createdLt,
        createdAt
      };
    }
    exports.loadCommonMessageInfo = loadCommonMessageInfo;
    function storeCommonMessageInfo(source) {
      return (builder) => {
        if (source.type === "internal") {
          builder.storeBit(0);
          builder.storeBit(source.ihrDisabled);
          builder.storeBit(source.bounce);
          builder.storeBit(source.bounced);
          builder.storeAddress(source.src);
          builder.storeAddress(source.dest);
          builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
          builder.storeCoins(source.ihrFee);
          builder.storeCoins(source.forwardFee);
          builder.storeUint(source.createdLt, 64);
          builder.storeUint(source.createdAt, 32);
        } else if (source.type === "external-in") {
          builder.storeBit(1);
          builder.storeBit(0);
          builder.storeAddress(source.src);
          builder.storeAddress(source.dest);
          builder.storeCoins(source.importFee);
        } else if (source.type === "external-out") {
          builder.storeBit(1);
          builder.storeBit(1);
          builder.storeAddress(source.src);
          builder.storeAddress(source.dest);
          builder.storeUint(source.createdLt, 64);
          builder.storeUint(source.createdAt, 32);
        } else {
          throw new Error("Unknown CommonMessageInfo type");
        }
      };
    }
    exports.storeCommonMessageInfo = storeCommonMessageInfo;
  }
});

// node_modules/@ton/core/dist/types/ComputeSkipReason.js
var require_ComputeSkipReason = __commonJS({
  "node_modules/@ton/core/dist/types/ComputeSkipReason.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeComputeSkipReason = exports.loadComputeSkipReason = void 0;
    function loadComputeSkipReason(slice) {
      let reason = slice.loadUint(2);
      if (reason === 0) {
        return "no-state";
      } else if (reason === 1) {
        return "bad-state";
      } else if (reason === 2) {
        return "no-gas";
      }
      throw new Error(`Unknown ComputeSkipReason: ${reason}`);
    }
    exports.loadComputeSkipReason = loadComputeSkipReason;
    function storeComputeSkipReason(src) {
      return (builder) => {
        if (src === "no-state") {
          builder.storeUint(0, 2);
        } else if (src === "bad-state") {
          builder.storeUint(1, 2);
        } else if (src === "no-gas") {
          builder.storeUint(2, 2);
        } else {
          throw new Error(`Unknown ComputeSkipReason: ${src}`);
        }
      };
    }
    exports.storeComputeSkipReason = storeComputeSkipReason;
  }
});

// node_modules/@ton/core/dist/types/DepthBalanceInfo.js
var require_DepthBalanceInfo = __commonJS({
  "node_modules/@ton/core/dist/types/DepthBalanceInfo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeDepthBalanceInfo = exports.loadDepthBalanceInfo = void 0;
    var CurrencyCollection_1 = require_CurrencyCollection();
    function loadDepthBalanceInfo(slice) {
      let splitDepth = slice.loadUint(5);
      return {
        splitDepth,
        balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice)
      };
    }
    exports.loadDepthBalanceInfo = loadDepthBalanceInfo;
    function storeDepthBalanceInfo(src) {
      return (builder) => {
        builder.storeUint(src.splitDepth, 5);
        builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.balance));
      };
    }
    exports.storeDepthBalanceInfo = storeDepthBalanceInfo;
  }
});

// node_modules/@ton/core/dist/types/HashUpdate.js
var require_HashUpdate = __commonJS({
  "node_modules/@ton/core/dist/types/HashUpdate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeHashUpdate = exports.loadHashUpdate = void 0;
    function loadHashUpdate(slice) {
      if (slice.loadUint(8) !== 114) {
        throw Error("Invalid data");
      }
      const oldHash = slice.loadBuffer(32);
      const newHash = slice.loadBuffer(32);
      return { oldHash, newHash };
    }
    exports.loadHashUpdate = loadHashUpdate;
    function storeHashUpdate(src) {
      return (builder) => {
        builder.storeUint(114, 8);
        builder.storeBuffer(src.oldHash);
        builder.storeBuffer(src.newHash);
      };
    }
    exports.storeHashUpdate = storeHashUpdate;
  }
});

// node_modules/@ton/core/dist/types/MasterchainStateExtra.js
var require_MasterchainStateExtra = __commonJS({
  "node_modules/@ton/core/dist/types/MasterchainStateExtra.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadMasterchainStateExtra = void 0;
    var Dictionary_1 = require_Dictionary();
    var CurrencyCollection_1 = require_CurrencyCollection();
    function loadMasterchainStateExtra(cs) {
      if (cs.loadUint(16) !== 52262) {
        throw Error("Invalid data");
      }
      if (cs.loadBit()) {
        cs.loadRef();
      }
      let configAddress = cs.loadUintBig(256);
      let config = Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.Int(32), Dictionary_1.Dictionary.Values.Cell(), cs);
      const globalBalance = (0, CurrencyCollection_1.loadCurrencyCollection)(cs);
      return {
        config,
        configAddress,
        globalBalance
      };
    }
    exports.loadMasterchainStateExtra = loadMasterchainStateExtra;
  }
});

// node_modules/@ton/core/dist/types/Message.js
var require_Message = __commonJS({
  "node_modules/@ton/core/dist/types/Message.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageValue = exports.storeMessage = exports.loadMessage = void 0;
    var Builder_1 = require_Builder();
    var CommonMessageInfo_1 = require_CommonMessageInfo();
    var StateInit_1 = require_StateInit();
    function loadMessage(slice) {
      const info = (0, CommonMessageInfo_1.loadCommonMessageInfo)(slice);
      let init = null;
      if (slice.loadBit()) {
        if (!slice.loadBit()) {
          init = (0, StateInit_1.loadStateInit)(slice);
        } else {
          init = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
        }
      }
      const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
      return {
        info,
        init,
        body
      };
    }
    exports.loadMessage = loadMessage;
    function storeMessage(message, opts) {
      return (builder) => {
        builder.store((0, CommonMessageInfo_1.storeCommonMessageInfo)(message.info));
        if (message.init) {
          builder.storeBit(true);
          let initCell = (0, Builder_1.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
          let needRef2 = false;
          if (opts && opts.forceRef) {
            needRef2 = true;
          } else {
            needRef2 = builder.availableBits - 2 < initCell.bits + message.body.bits.length;
          }
          if (needRef2) {
            builder.storeBit(true);
            builder.storeRef(initCell);
          } else {
            builder.storeBit(false);
            builder.storeBuilder(initCell);
          }
        } else {
          builder.storeBit(false);
        }
        let needRef = false;
        if (opts && opts.forceRef) {
          needRef = true;
        } else {
          needRef = builder.availableBits - 1 < message.body.bits.length || builder.refs + message.body.refs.length > 4;
        }
        if (needRef) {
          builder.storeBit(true);
          builder.storeRef(message.body);
        } else {
          builder.storeBit(false);
          builder.storeBuilder(message.body.asBuilder());
        }
      };
    }
    exports.storeMessage = storeMessage;
    exports.MessageValue = {
      serialize(src, builder) {
        builder.storeRef((0, Builder_1.beginCell)().store(storeMessage(src)));
      },
      parse(slice) {
        return loadMessage(slice.loadRef().beginParse());
      }
    };
  }
});

// node_modules/@ton/core/dist/types/SendMode.js
var require_SendMode = __commonJS({
  "node_modules/@ton/core/dist/types/SendMode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SendMode = void 0;
    var SendMode;
    (function(SendMode2) {
      SendMode2[SendMode2["CARRY_ALL_REMAINING_BALANCE"] = 128] = "CARRY_ALL_REMAINING_BALANCE";
      SendMode2[SendMode2["CARRY_ALL_REMAINING_INCOMING_VALUE"] = 64] = "CARRY_ALL_REMAINING_INCOMING_VALUE";
      SendMode2[SendMode2["DESTROY_ACCOUNT_IF_ZERO"] = 32] = "DESTROY_ACCOUNT_IF_ZERO";
      SendMode2[SendMode2["PAY_GAS_SEPARATELY"] = 1] = "PAY_GAS_SEPARATELY";
      SendMode2[SendMode2["IGNORE_ERRORS"] = 2] = "IGNORE_ERRORS";
      SendMode2[SendMode2["NONE"] = 0] = "NONE";
    })(SendMode || (exports.SendMode = SendMode = {}));
  }
});

// node_modules/@ton/core/dist/types/ShardAccount.js
var require_ShardAccount = __commonJS({
  "node_modules/@ton/core/dist/types/ShardAccount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeShardAccount = exports.loadShardAccount = void 0;
    var Builder_1 = require_Builder();
    var Account_1 = require_Account();
    function loadShardAccount(slice) {
      let accountRef = slice.loadRef();
      let account = void 0;
      if (!accountRef.isExotic) {
        let accountSlice = accountRef.beginParse();
        if (accountSlice.loadBit()) {
          account = (0, Account_1.loadAccount)(accountSlice);
        }
      }
      return {
        account,
        lastTransactionHash: slice.loadUintBig(256),
        lastTransactionLt: slice.loadUintBig(64)
      };
    }
    exports.loadShardAccount = loadShardAccount;
    function storeShardAccount(src) {
      return (builder) => {
        if (src.account) {
          builder.storeRef((0, Builder_1.beginCell)().storeBit(true).store((0, Account_1.storeAccount)(src.account)));
        } else {
          builder.storeRef((0, Builder_1.beginCell)().storeBit(false));
        }
        builder.storeUint(src.lastTransactionHash, 256);
        builder.storeUint(src.lastTransactionLt, 64);
      };
    }
    exports.storeShardAccount = storeShardAccount;
  }
});

// node_modules/@ton/core/dist/types/ShardAccounts.js
var require_ShardAccounts = __commonJS({
  "node_modules/@ton/core/dist/types/ShardAccounts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = void 0;
    var Dictionary_1 = require_Dictionary();
    var DepthBalanceInfo_1 = require_DepthBalanceInfo();
    var ShardAccount_1 = require_ShardAccount();
    exports.ShardAccountRefValue = {
      parse: (cs) => {
        let depthBalanceInfo = (0, DepthBalanceInfo_1.loadDepthBalanceInfo)(cs);
        let shardAccount = (0, ShardAccount_1.loadShardAccount)(cs);
        return {
          depthBalanceInfo,
          shardAccount
        };
      },
      serialize(src, builder) {
        builder.store((0, DepthBalanceInfo_1.storeDepthBalanceInfo)(src.depthBalanceInfo));
        builder.store((0, ShardAccount_1.storeShardAccount)(src.shardAccount));
      }
    };
    function loadShardAccounts(cs) {
      return Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.BigUint(256), exports.ShardAccountRefValue, cs);
    }
    exports.loadShardAccounts = loadShardAccounts;
    function storeShardAccounts(src) {
      return (Builder) => {
        Builder.storeDict(src);
      };
    }
    exports.storeShardAccounts = storeShardAccounts;
  }
});

// node_modules/@ton/core/dist/types/ShardIdent.js
var require_ShardIdent = __commonJS({
  "node_modules/@ton/core/dist/types/ShardIdent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeShardIdent = exports.loadShardIdent = void 0;
    function loadShardIdent(slice) {
      if (slice.loadUint(2) !== 0) {
        throw Error("Invalid data");
      }
      return {
        shardPrefixBits: slice.loadUint(6),
        workchainId: slice.loadInt(32),
        shardPrefix: slice.loadUintBig(64)
      };
    }
    exports.loadShardIdent = loadShardIdent;
    function storeShardIdent(src) {
      return (builder) => {
        builder.storeUint(0, 2);
        builder.storeUint(src.shardPrefixBits, 6);
        builder.storeInt(src.workchainId, 32);
        builder.storeUint(src.shardPrefix, 64);
      };
    }
    exports.storeShardIdent = storeShardIdent;
  }
});

// node_modules/@ton/core/dist/types/ShardStateUnsplit.js
var require_ShardStateUnsplit = __commonJS({
  "node_modules/@ton/core/dist/types/ShardStateUnsplit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadShardStateUnsplit = void 0;
    var MasterchainStateExtra_1 = require_MasterchainStateExtra();
    var ShardAccounts_1 = require_ShardAccounts();
    var ShardIdent_1 = require_ShardIdent();
    function loadShardStateUnsplit(cs) {
      if (cs.loadUint(32) !== 2418257890) {
        throw Error("Invalid data");
      }
      let globalId = cs.loadInt(32);
      let shardId = (0, ShardIdent_1.loadShardIdent)(cs);
      let seqno = cs.loadUint(32);
      let vertSeqNo = cs.loadUint(32);
      let genUtime = cs.loadUint(32);
      let genLt = cs.loadUintBig(64);
      let minRefMcSeqno = cs.loadUint(32);
      cs.loadRef();
      let beforeSplit = cs.loadBit();
      let shardAccountsRef = cs.loadRef();
      let accounts = void 0;
      if (!shardAccountsRef.isExotic) {
        accounts = (0, ShardAccounts_1.loadShardAccounts)(shardAccountsRef.beginParse());
      }
      cs.loadRef();
      let mcStateExtra = cs.loadBit();
      let extras = null;
      if (mcStateExtra) {
        let cell = cs.loadRef();
        if (!cell.isExotic) {
          extras = (0, MasterchainStateExtra_1.loadMasterchainStateExtra)(cell.beginParse());
        }
      }
      ;
      return {
        globalId,
        shardId,
        seqno,
        vertSeqNo,
        genUtime,
        genLt,
        minRefMcSeqno,
        beforeSplit,
        accounts,
        extras
      };
    }
    exports.loadShardStateUnsplit = loadShardStateUnsplit;
  }
});

// node_modules/@ton/core/dist/types/SplitMergeInfo.js
var require_SplitMergeInfo = __commonJS({
  "node_modules/@ton/core/dist/types/SplitMergeInfo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeSplitMergeInfo = exports.loadSplitMergeInfo = void 0;
    function loadSplitMergeInfo(slice) {
      let currentShardPrefixLength = slice.loadUint(6);
      let accountSplitDepth = slice.loadUint(6);
      let thisAddress = slice.loadUintBig(256);
      let siblingAddress = slice.loadUintBig(256);
      return {
        currentShardPrefixLength,
        accountSplitDepth,
        thisAddress,
        siblingAddress
      };
    }
    exports.loadSplitMergeInfo = loadSplitMergeInfo;
    function storeSplitMergeInfo(src) {
      return (builder) => {
        builder.storeUint(src.currentShardPrefixLength, 6);
        builder.storeUint(src.accountSplitDepth, 6);
        builder.storeUint(src.thisAddress, 256);
        builder.storeUint(src.siblingAddress, 256);
      };
    }
    exports.storeSplitMergeInfo = storeSplitMergeInfo;
  }
});

// node_modules/@ton/core/dist/types/StorageUsedShort.js
var require_StorageUsedShort = __commonJS({
  "node_modules/@ton/core/dist/types/StorageUsedShort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeStorageUsedShort = exports.loadStorageUsedShort = void 0;
    function loadStorageUsedShort(slice) {
      let cells = slice.loadVarUintBig(3);
      let bits = slice.loadVarUintBig(3);
      return {
        cells,
        bits
      };
    }
    exports.loadStorageUsedShort = loadStorageUsedShort;
    function storeStorageUsedShort(src) {
      return (builder) => {
        builder.storeVarUint(src.cells, 3);
        builder.storeVarUint(src.bits, 3);
      };
    }
    exports.storeStorageUsedShort = storeStorageUsedShort;
  }
});

// node_modules/@ton/core/dist/types/TransactionActionPhase.js
var require_TransactionActionPhase = __commonJS({
  "node_modules/@ton/core/dist/types/TransactionActionPhase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTransactionActionPhase = exports.loadTransactionActionPhase = void 0;
    var AccountStatusChange_1 = require_AccountStatusChange();
    var StorageUsedShort_1 = require_StorageUsedShort();
    function loadTransactionActionPhase(slice) {
      let success = slice.loadBit();
      let valid = slice.loadBit();
      let noFunds = slice.loadBit();
      let statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
      let totalFwdFees = slice.loadBit() ? slice.loadCoins() : void 0;
      let totalActionFees = slice.loadBit() ? slice.loadCoins() : void 0;
      let resultCode = slice.loadInt(32);
      let resultArg = slice.loadBit() ? slice.loadInt(32) : void 0;
      let totalActions = slice.loadUint(16);
      let specActions = slice.loadUint(16);
      let skippedActions = slice.loadUint(16);
      let messagesCreated = slice.loadUint(16);
      let actionListHash = slice.loadUintBig(256);
      let totalMessageSize = (0, StorageUsedShort_1.loadStorageUsedShort)(slice);
      return {
        success,
        valid,
        noFunds,
        statusChange,
        totalFwdFees,
        totalActionFees,
        resultCode,
        resultArg,
        totalActions,
        specActions,
        skippedActions,
        messagesCreated,
        actionListHash,
        totalMessageSize
      };
    }
    exports.loadTransactionActionPhase = loadTransactionActionPhase;
    function storeTransactionActionPhase(src) {
      return (builder) => {
        builder.storeBit(src.success);
        builder.storeBit(src.valid);
        builder.storeBit(src.noFunds);
        builder.store((0, AccountStatusChange_1.storeAccountStatusChange)(src.statusChange));
        builder.storeMaybeCoins(src.totalFwdFees);
        builder.storeMaybeCoins(src.totalActionFees);
        builder.storeInt(src.resultCode, 32);
        builder.storeMaybeInt(src.resultArg, 32);
        builder.storeUint(src.totalActions, 16);
        builder.storeUint(src.specActions, 16);
        builder.storeUint(src.skippedActions, 16);
        builder.storeUint(src.messagesCreated, 16);
        builder.storeUint(src.actionListHash, 256);
        builder.store((0, StorageUsedShort_1.storeStorageUsedShort)(src.totalMessageSize));
      };
    }
    exports.storeTransactionActionPhase = storeTransactionActionPhase;
  }
});

// node_modules/@ton/core/dist/types/TransactionBouncePhase.js
var require_TransactionBouncePhase = __commonJS({
  "node_modules/@ton/core/dist/types/TransactionBouncePhase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTransactionBouncePhase = exports.loadTransactionBouncePhase = void 0;
    var StorageUsedShort_1 = require_StorageUsedShort();
    function loadTransactionBouncePhase(slice) {
      if (slice.loadBit()) {
        let messageSize = (0, StorageUsedShort_1.loadStorageUsedShort)(slice);
        let messageFees = slice.loadCoins();
        let forwardFees = slice.loadCoins();
        return {
          type: "ok",
          messageSize,
          messageFees,
          forwardFees
        };
      }
      if (slice.loadBit()) {
        let messageSize = (0, StorageUsedShort_1.loadStorageUsedShort)(slice);
        let requiredForwardFees = slice.loadCoins();
        return {
          type: "no-funds",
          messageSize,
          requiredForwardFees
        };
      }
      return {
        type: "negative-funds"
      };
    }
    exports.loadTransactionBouncePhase = loadTransactionBouncePhase;
    function storeTransactionBouncePhase(src) {
      return (builder) => {
        if (src.type === "ok") {
          builder.storeBit(true);
          builder.store((0, StorageUsedShort_1.storeStorageUsedShort)(src.messageSize));
          builder.storeCoins(src.messageFees);
          builder.storeCoins(src.forwardFees);
        } else if (src.type === "negative-funds") {
          builder.storeBit(false);
          builder.storeBit(false);
        } else if (src.type === "no-funds") {
          builder.storeBit(false);
          builder.storeBit(true);
          builder.store((0, StorageUsedShort_1.storeStorageUsedShort)(src.messageSize));
          builder.storeCoins(src.requiredForwardFees);
        } else {
          throw new Error("Invalid TransactionBouncePhase type");
        }
      };
    }
    exports.storeTransactionBouncePhase = storeTransactionBouncePhase;
  }
});

// node_modules/@ton/core/dist/types/TransactionComputePhase.js
var require_TransactionComputePhase = __commonJS({
  "node_modules/@ton/core/dist/types/TransactionComputePhase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTransactionComputePhase = exports.loadTransactionComputePhase = void 0;
    var Builder_1 = require_Builder();
    var ComputeSkipReason_1 = require_ComputeSkipReason();
    function loadTransactionComputePhase(slice) {
      if (!slice.loadBit()) {
        let reason = (0, ComputeSkipReason_1.loadComputeSkipReason)(slice);
        return {
          type: "skipped",
          reason
        };
      }
      let success = slice.loadBit();
      let messageStateUsed = slice.loadBit();
      let accountActivated = slice.loadBit();
      let gasFees = slice.loadCoins();
      const vmState = slice.loadRef().beginParse();
      let gasUsed = vmState.loadVarUintBig(3);
      let gasLimit = vmState.loadVarUintBig(3);
      let gasCredit = vmState.loadBit() ? vmState.loadVarUintBig(2) : void 0;
      let mode = vmState.loadUint(8);
      let exitCode = vmState.loadInt(32);
      let exitArg = vmState.loadBit() ? vmState.loadInt(32) : void 0;
      let vmSteps = vmState.loadUint(32);
      let vmInitStateHash = vmState.loadUintBig(256);
      let vmFinalStateHash = vmState.loadUintBig(256);
      return {
        type: "vm",
        success,
        messageStateUsed,
        accountActivated,
        gasFees,
        gasUsed,
        gasLimit,
        gasCredit,
        mode,
        exitCode,
        exitArg,
        vmSteps,
        vmInitStateHash,
        vmFinalStateHash
      };
    }
    exports.loadTransactionComputePhase = loadTransactionComputePhase;
    function storeTransactionComputePhase(src) {
      return (builder) => {
        if (src.type === "skipped") {
          builder.storeBit(0);
          builder.store((0, ComputeSkipReason_1.storeComputeSkipReason)(src.reason));
          return;
        }
        builder.storeBit(1);
        builder.storeBit(src.success);
        builder.storeBit(src.messageStateUsed);
        builder.storeBit(src.accountActivated);
        builder.storeCoins(src.gasFees);
        builder.storeRef((0, Builder_1.beginCell)().storeVarUint(src.gasUsed, 3).storeVarUint(src.gasLimit, 3).store((b) => src.gasCredit !== void 0 && src.gasCredit !== null ? b.storeBit(1).storeVarUint(src.gasCredit, 2) : b.storeBit(0)).storeUint(src.mode, 8).storeInt(src.exitCode, 32).store((b) => src.exitArg !== void 0 && src.exitArg !== null ? b.storeBit(1).storeInt(src.exitArg, 32) : b.storeBit(0)).storeUint(src.vmSteps, 32).storeUint(src.vmInitStateHash, 256).storeUint(src.vmFinalStateHash, 256).endCell());
      };
    }
    exports.storeTransactionComputePhase = storeTransactionComputePhase;
  }
});

// node_modules/@ton/core/dist/types/TransactionCreditPhase.js
var require_TransactionCreditPhase = __commonJS({
  "node_modules/@ton/core/dist/types/TransactionCreditPhase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTransactionCreditPhase = exports.loadTransactionCreditPhase = void 0;
    var CurrencyCollection_1 = require_CurrencyCollection();
    function loadTransactionCreditPhase(slice) {
      const dueFeesColelcted = slice.loadBit() ? slice.loadCoins() : void 0;
      const credit = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      return {
        dueFeesColelcted,
        credit
      };
    }
    exports.loadTransactionCreditPhase = loadTransactionCreditPhase;
    function storeTransactionCreditPhase(src) {
      return (builder) => {
        if (src.dueFeesColelcted === null || src.dueFeesColelcted === void 0) {
          builder.storeBit(false);
        } else {
          builder.storeBit(true);
          builder.storeCoins(src.dueFeesColelcted);
        }
        builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.credit));
      };
    }
    exports.storeTransactionCreditPhase = storeTransactionCreditPhase;
  }
});

// node_modules/@ton/core/dist/types/TransactionStoragePhase.js
var require_TransactionStoragePhase = __commonJS({
  "node_modules/@ton/core/dist/types/TransactionStoragePhase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTransactionsStoragePhase = exports.loadTransactionStoragePhase = void 0;
    var AccountStatusChange_1 = require_AccountStatusChange();
    function loadTransactionStoragePhase(slice) {
      const storageFeesCollected = slice.loadCoins();
      let storageFeesDue = void 0;
      if (slice.loadBit()) {
        storageFeesDue = slice.loadCoins();
      }
      const statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
      return {
        storageFeesCollected,
        storageFeesDue,
        statusChange
      };
    }
    exports.loadTransactionStoragePhase = loadTransactionStoragePhase;
    function storeTransactionsStoragePhase(src) {
      return (builder) => {
        builder.storeCoins(src.storageFeesCollected);
        if (src.storageFeesDue === null || src.storageFeesDue === void 0) {
          builder.storeBit(false);
        } else {
          builder.storeBit(true);
          builder.storeCoins(src.storageFeesDue);
        }
        builder.store((0, AccountStatusChange_1.storeAccountStatusChange)(src.statusChange));
      };
    }
    exports.storeTransactionsStoragePhase = storeTransactionsStoragePhase;
  }
});

// node_modules/@ton/core/dist/types/TransactionDescription.js
var require_TransactionDescription = __commonJS({
  "node_modules/@ton/core/dist/types/TransactionDescription.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTransactionDescription = exports.loadTransactionDescription = void 0;
    var Builder_1 = require_Builder();
    var SplitMergeInfo_1 = require_SplitMergeInfo();
    var Transaction_1 = require_Transaction();
    var TransactionActionPhase_1 = require_TransactionActionPhase();
    var TransactionBouncePhase_1 = require_TransactionBouncePhase();
    var TransactionComputePhase_1 = require_TransactionComputePhase();
    var TransactionCreditPhase_1 = require_TransactionCreditPhase();
    var TransactionStoragePhase_1 = require_TransactionStoragePhase();
    function loadTransactionDescription(slice) {
      let type = slice.loadUint(4);
      if (type === 0) {
        const creditFirst = slice.loadBit();
        let storagePhase = void 0;
        if (slice.loadBit()) {
          storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
        }
        let creditPhase = void 0;
        if (slice.loadBit()) {
          creditPhase = (0, TransactionCreditPhase_1.loadTransactionCreditPhase)(slice);
        }
        let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
        let actionPhase = void 0;
        if (slice.loadBit()) {
          actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
        }
        let aborted = slice.loadBit();
        let bouncePhase = void 0;
        if (slice.loadBit()) {
          bouncePhase = (0, TransactionBouncePhase_1.loadTransactionBouncePhase)(slice);
        }
        const destroyed = slice.loadBit();
        return {
          type: "generic",
          creditFirst,
          storagePhase,
          creditPhase,
          computePhase,
          actionPhase,
          bouncePhase,
          aborted,
          destroyed
        };
      }
      if (type === 1) {
        return {
          type: "storage",
          storagePhase: (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice)
        };
      }
      if (type === 2 || type === 3) {
        const isTock = type === 3;
        let storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
        let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
        let actionPhase = void 0;
        if (slice.loadBit()) {
          actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
        }
        const aborted = slice.loadBit();
        const destroyed = slice.loadBit();
        return {
          type: "tick-tock",
          isTock,
          storagePhase,
          computePhase,
          actionPhase,
          aborted,
          destroyed
        };
      }
      if (type === 4) {
        let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
        let storagePhase = void 0;
        if (slice.loadBit()) {
          storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
        }
        let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
        let actionPhase = void 0;
        if (slice.loadBit()) {
          actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
        }
        const aborted = slice.loadBit();
        const destroyed = slice.loadBit();
        return {
          type: "split-prepare",
          splitInfo,
          storagePhase,
          computePhase,
          actionPhase,
          aborted,
          destroyed
        };
      }
      if (type === 5) {
        let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
        let prepareTransaction = (0, Transaction_1.loadTransaction)(slice.loadRef().beginParse());
        const installed = slice.loadBit();
        return {
          type: "split-install",
          splitInfo,
          prepareTransaction,
          installed
        };
      }
      throw Error(`Unsupported transaction description type ${type}`);
    }
    exports.loadTransactionDescription = loadTransactionDescription;
    function storeTransactionDescription(src) {
      return (builder) => {
        if (src.type === "generic") {
          builder.storeUint(0, 4);
          builder.storeBit(src.creditFirst);
          if (src.storagePhase) {
            builder.storeBit(true);
            builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
          } else {
            builder.storeBit(false);
          }
          if (src.creditPhase) {
            builder.storeBit(true);
            builder.store((0, TransactionCreditPhase_1.storeTransactionCreditPhase)(src.creditPhase));
          } else {
            builder.storeBit(false);
          }
          builder.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
          if (src.actionPhase) {
            builder.storeBit(true);
            builder.storeRef((0, Builder_1.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase)));
          } else {
            builder.storeBit(false);
          }
          builder.storeBit(src.aborted);
          if (src.bouncePhase) {
            builder.storeBit(true);
            builder.store((0, TransactionBouncePhase_1.storeTransactionBouncePhase)(src.bouncePhase));
          } else {
            builder.storeBit(false);
          }
          builder.storeBit(src.destroyed);
        } else if (src.type === "storage") {
          builder.storeUint(1, 4);
          builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
        } else if (src.type === "tick-tock") {
          builder.storeUint(src.isTock ? 3 : 2, 4);
          builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
          builder.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
          if (src.actionPhase) {
            builder.storeBit(true);
            builder.storeRef((0, Builder_1.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase)));
          } else {
            builder.storeBit(false);
          }
          builder.storeBit(src.aborted);
          builder.storeBit(src.destroyed);
        } else if (src.type === "split-prepare") {
          builder.storeUint(4, 4);
          builder.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src.splitInfo));
          if (src.storagePhase) {
            builder.storeBit(true);
            builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
          } else {
            builder.storeBit(false);
          }
          builder.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
          if (src.actionPhase) {
            builder.storeBit(true);
            builder.store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase));
          } else {
            builder.storeBit(false);
          }
          builder.storeBit(src.aborted);
          builder.storeBit(src.destroyed);
        } else if (src.type === "split-install") {
          builder.storeUint(5, 4);
          builder.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src.splitInfo));
          builder.storeRef((0, Builder_1.beginCell)().store((0, Transaction_1.storeTransaction)(src.prepareTransaction)));
          builder.storeBit(src.installed);
        } else {
          throw Error(`Unsupported transaction description type ${src.type}`);
        }
      };
    }
    exports.storeTransactionDescription = storeTransactionDescription;
  }
});

// node_modules/@ton/core/dist/types/Transaction.js
var require_Transaction = __commonJS({
  "node_modules/@ton/core/dist/types/Transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTransaction = exports.loadTransaction = void 0;
    var Builder_1 = require_Builder();
    var Dictionary_1 = require_Dictionary();
    var AccountStatus_1 = require_AccountStatus();
    var CurrencyCollection_1 = require_CurrencyCollection();
    var HashUpdate_1 = require_HashUpdate();
    var Message_1 = require_Message();
    var TransactionDescription_1 = require_TransactionDescription();
    function loadTransaction(slice) {
      let raw = slice.asCell();
      if (slice.loadUint(4) !== 7) {
        throw Error("Invalid data");
      }
      let address = slice.loadUintBig(256);
      let lt = slice.loadUintBig(64);
      let prevTransactionHash = slice.loadUintBig(256);
      let prevTransactionLt = slice.loadUintBig(64);
      let now = slice.loadUint(32);
      let outMessagesCount = slice.loadUint(15);
      let oldStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
      let endStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
      let msgRef = slice.loadRef();
      let msgSlice = msgRef.beginParse();
      let inMessage = msgSlice.loadBit() ? (0, Message_1.loadMessage)(msgSlice.loadRef().beginParse()) : void 0;
      let outMessages = msgSlice.loadDict(Dictionary_1.Dictionary.Keys.Uint(15), Message_1.MessageValue);
      msgSlice.endParse();
      let totalFees = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      let stateUpdate = (0, HashUpdate_1.loadHashUpdate)(slice.loadRef().beginParse());
      let description = (0, TransactionDescription_1.loadTransactionDescription)(slice.loadRef().beginParse());
      return {
        address,
        lt,
        prevTransactionHash,
        prevTransactionLt,
        now,
        outMessagesCount,
        oldStatus,
        endStatus,
        inMessage,
        outMessages,
        totalFees,
        stateUpdate,
        description,
        raw,
        hash: () => raw.hash()
      };
    }
    exports.loadTransaction = loadTransaction;
    function storeTransaction(src) {
      return (builder) => {
        builder.storeUint(7, 4);
        builder.storeUint(src.address, 256);
        builder.storeUint(src.lt, 64);
        builder.storeUint(src.prevTransactionHash, 256);
        builder.storeUint(src.prevTransactionLt, 64);
        builder.storeUint(src.now, 32);
        builder.storeUint(src.outMessagesCount, 15);
        builder.store((0, AccountStatus_1.storeAccountStatus)(src.oldStatus));
        builder.store((0, AccountStatus_1.storeAccountStatus)(src.endStatus));
        let msgBuilder = (0, Builder_1.beginCell)();
        if (src.inMessage) {
          msgBuilder.storeBit(true);
          msgBuilder.storeRef((0, Builder_1.beginCell)().store((0, Message_1.storeMessage)(src.inMessage)));
        } else {
          msgBuilder.storeBit(false);
        }
        msgBuilder.storeDict(src.outMessages);
        builder.storeRef(msgBuilder);
        builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.totalFees));
        builder.storeRef((0, Builder_1.beginCell)().store((0, HashUpdate_1.storeHashUpdate)(src.stateUpdate)));
        builder.storeRef((0, Builder_1.beginCell)().store((0, TransactionDescription_1.storeTransactionDescription)(src.description)));
      };
    }
    exports.storeTransaction = storeTransaction;
  }
});

// node_modules/@ton/core/dist/types/_export.js
var require_export = __commonJS({
  "node_modules/@ton/core/dist/types/_export.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadStorageInfo = exports.storeStateInit = exports.loadStateInit = exports.storeSplitMergeInfo = exports.loadSplitMergeInfo = exports.storeSimpleLibrary = exports.loadSimpleLibrary = exports.loadShardStateUnsplit = exports.storeShardIdent = exports.loadShardIdent = exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = exports.storeShardAccount = exports.loadShardAccount = exports.SendMode = exports.storeMessageRelaxed = exports.loadMessageRelaxed = exports.storeMessage = exports.loadMessage = exports.loadMasterchainStateExtra = exports.storeHashUpdate = exports.loadHashUpdate = exports.storeDepthBalanceInfo = exports.loadDepthBalanceInfo = exports.storeCurrencyCollection = exports.loadCurrencyCollection = exports.storeComputeSkipReason = exports.loadComputeSkipReason = exports.storeCommonMessageInfoRelaxed = exports.loadCommonMessageInfoRelaxed = exports.storeCommonMessageInfo = exports.loadCommonMessageInfo = exports.storeOutList = exports.loadOutList = exports.storeOutAction = exports.loadOutAction = exports.storeAccountStorage = exports.loadAccountStorage = exports.storeAccountStatusChange = exports.loadAccountStatusChange = exports.storeAccountStatus = exports.loadAccountStatus = exports.storeAccountState = exports.loadAccountState = exports.storeAccount = exports.loadAccount = exports.comment = exports.external = exports.internal = void 0;
    exports.storeTransactionsStoragePhase = exports.loadTransactionStoragePhase = exports.storeTransactionDescription = exports.loadTransactionDescription = exports.storeTransactionCreditPhase = exports.loadTransactionCreditPhase = exports.storeTransactionComputePhase = exports.loadTransactionComputePhase = exports.storeTransactionBouncePhase = exports.loadTransactionBouncePhase = exports.storeTransactionActionPhase = exports.loadTransactionActionPhase = exports.storeTransaction = exports.loadTransaction = exports.storeTickTock = exports.loadTickTock = exports.storeStorageUsedShort = exports.loadStorageUsedShort = exports.storeStorageUsed = exports.loadStorageUsed = exports.storeStorageInfo = void 0;
    var _helpers_1 = require_helpers();
    Object.defineProperty(exports, "internal", { enumerable: true, get: function() {
      return _helpers_1.internal;
    } });
    Object.defineProperty(exports, "external", { enumerable: true, get: function() {
      return _helpers_1.external;
    } });
    Object.defineProperty(exports, "comment", { enumerable: true, get: function() {
      return _helpers_1.comment;
    } });
    var Account_1 = require_Account();
    Object.defineProperty(exports, "loadAccount", { enumerable: true, get: function() {
      return Account_1.loadAccount;
    } });
    Object.defineProperty(exports, "storeAccount", { enumerable: true, get: function() {
      return Account_1.storeAccount;
    } });
    var AccountState_1 = require_AccountState();
    Object.defineProperty(exports, "loadAccountState", { enumerable: true, get: function() {
      return AccountState_1.loadAccountState;
    } });
    Object.defineProperty(exports, "storeAccountState", { enumerable: true, get: function() {
      return AccountState_1.storeAccountState;
    } });
    var AccountStatus_1 = require_AccountStatus();
    Object.defineProperty(exports, "loadAccountStatus", { enumerable: true, get: function() {
      return AccountStatus_1.loadAccountStatus;
    } });
    Object.defineProperty(exports, "storeAccountStatus", { enumerable: true, get: function() {
      return AccountStatus_1.storeAccountStatus;
    } });
    var AccountStatusChange_1 = require_AccountStatusChange();
    Object.defineProperty(exports, "loadAccountStatusChange", { enumerable: true, get: function() {
      return AccountStatusChange_1.loadAccountStatusChange;
    } });
    Object.defineProperty(exports, "storeAccountStatusChange", { enumerable: true, get: function() {
      return AccountStatusChange_1.storeAccountStatusChange;
    } });
    var AccountStorage_1 = require_AccountStorage();
    Object.defineProperty(exports, "loadAccountStorage", { enumerable: true, get: function() {
      return AccountStorage_1.loadAccountStorage;
    } });
    Object.defineProperty(exports, "storeAccountStorage", { enumerable: true, get: function() {
      return AccountStorage_1.storeAccountStorage;
    } });
    var OutList_1 = require_OutList();
    Object.defineProperty(exports, "loadOutAction", { enumerable: true, get: function() {
      return OutList_1.loadOutAction;
    } });
    Object.defineProperty(exports, "storeOutAction", { enumerable: true, get: function() {
      return OutList_1.storeOutAction;
    } });
    Object.defineProperty(exports, "loadOutList", { enumerable: true, get: function() {
      return OutList_1.loadOutList;
    } });
    Object.defineProperty(exports, "storeOutList", { enumerable: true, get: function() {
      return OutList_1.storeOutList;
    } });
    var CommonMessageInfo_1 = require_CommonMessageInfo();
    Object.defineProperty(exports, "loadCommonMessageInfo", { enumerable: true, get: function() {
      return CommonMessageInfo_1.loadCommonMessageInfo;
    } });
    Object.defineProperty(exports, "storeCommonMessageInfo", { enumerable: true, get: function() {
      return CommonMessageInfo_1.storeCommonMessageInfo;
    } });
    var CommonMessageInfoRelaxed_1 = require_CommonMessageInfoRelaxed();
    Object.defineProperty(exports, "loadCommonMessageInfoRelaxed", { enumerable: true, get: function() {
      return CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed;
    } });
    Object.defineProperty(exports, "storeCommonMessageInfoRelaxed", { enumerable: true, get: function() {
      return CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed;
    } });
    var ComputeSkipReason_1 = require_ComputeSkipReason();
    Object.defineProperty(exports, "loadComputeSkipReason", { enumerable: true, get: function() {
      return ComputeSkipReason_1.loadComputeSkipReason;
    } });
    Object.defineProperty(exports, "storeComputeSkipReason", { enumerable: true, get: function() {
      return ComputeSkipReason_1.storeComputeSkipReason;
    } });
    var CurrencyCollection_1 = require_CurrencyCollection();
    Object.defineProperty(exports, "loadCurrencyCollection", { enumerable: true, get: function() {
      return CurrencyCollection_1.loadCurrencyCollection;
    } });
    Object.defineProperty(exports, "storeCurrencyCollection", { enumerable: true, get: function() {
      return CurrencyCollection_1.storeCurrencyCollection;
    } });
    var DepthBalanceInfo_1 = require_DepthBalanceInfo();
    Object.defineProperty(exports, "loadDepthBalanceInfo", { enumerable: true, get: function() {
      return DepthBalanceInfo_1.loadDepthBalanceInfo;
    } });
    Object.defineProperty(exports, "storeDepthBalanceInfo", { enumerable: true, get: function() {
      return DepthBalanceInfo_1.storeDepthBalanceInfo;
    } });
    var HashUpdate_1 = require_HashUpdate();
    Object.defineProperty(exports, "loadHashUpdate", { enumerable: true, get: function() {
      return HashUpdate_1.loadHashUpdate;
    } });
    Object.defineProperty(exports, "storeHashUpdate", { enumerable: true, get: function() {
      return HashUpdate_1.storeHashUpdate;
    } });
    var MasterchainStateExtra_1 = require_MasterchainStateExtra();
    Object.defineProperty(exports, "loadMasterchainStateExtra", { enumerable: true, get: function() {
      return MasterchainStateExtra_1.loadMasterchainStateExtra;
    } });
    var Message_1 = require_Message();
    Object.defineProperty(exports, "loadMessage", { enumerable: true, get: function() {
      return Message_1.loadMessage;
    } });
    Object.defineProperty(exports, "storeMessage", { enumerable: true, get: function() {
      return Message_1.storeMessage;
    } });
    var MessageRelaxed_1 = require_MessageRelaxed();
    Object.defineProperty(exports, "loadMessageRelaxed", { enumerable: true, get: function() {
      return MessageRelaxed_1.loadMessageRelaxed;
    } });
    Object.defineProperty(exports, "storeMessageRelaxed", { enumerable: true, get: function() {
      return MessageRelaxed_1.storeMessageRelaxed;
    } });
    var SendMode_1 = require_SendMode();
    Object.defineProperty(exports, "SendMode", { enumerable: true, get: function() {
      return SendMode_1.SendMode;
    } });
    var ShardAccount_1 = require_ShardAccount();
    Object.defineProperty(exports, "loadShardAccount", { enumerable: true, get: function() {
      return ShardAccount_1.loadShardAccount;
    } });
    Object.defineProperty(exports, "storeShardAccount", { enumerable: true, get: function() {
      return ShardAccount_1.storeShardAccount;
    } });
    var ShardAccounts_1 = require_ShardAccounts();
    Object.defineProperty(exports, "ShardAccountRefValue", { enumerable: true, get: function() {
      return ShardAccounts_1.ShardAccountRefValue;
    } });
    Object.defineProperty(exports, "loadShardAccounts", { enumerable: true, get: function() {
      return ShardAccounts_1.loadShardAccounts;
    } });
    Object.defineProperty(exports, "storeShardAccounts", { enumerable: true, get: function() {
      return ShardAccounts_1.storeShardAccounts;
    } });
    var ShardIdent_1 = require_ShardIdent();
    Object.defineProperty(exports, "loadShardIdent", { enumerable: true, get: function() {
      return ShardIdent_1.loadShardIdent;
    } });
    Object.defineProperty(exports, "storeShardIdent", { enumerable: true, get: function() {
      return ShardIdent_1.storeShardIdent;
    } });
    var ShardStateUnsplit_1 = require_ShardStateUnsplit();
    Object.defineProperty(exports, "loadShardStateUnsplit", { enumerable: true, get: function() {
      return ShardStateUnsplit_1.loadShardStateUnsplit;
    } });
    var SimpleLibrary_1 = require_SimpleLibrary();
    Object.defineProperty(exports, "loadSimpleLibrary", { enumerable: true, get: function() {
      return SimpleLibrary_1.loadSimpleLibrary;
    } });
    Object.defineProperty(exports, "storeSimpleLibrary", { enumerable: true, get: function() {
      return SimpleLibrary_1.storeSimpleLibrary;
    } });
    var SplitMergeInfo_1 = require_SplitMergeInfo();
    Object.defineProperty(exports, "loadSplitMergeInfo", { enumerable: true, get: function() {
      return SplitMergeInfo_1.loadSplitMergeInfo;
    } });
    Object.defineProperty(exports, "storeSplitMergeInfo", { enumerable: true, get: function() {
      return SplitMergeInfo_1.storeSplitMergeInfo;
    } });
    var StateInit_1 = require_StateInit();
    Object.defineProperty(exports, "loadStateInit", { enumerable: true, get: function() {
      return StateInit_1.loadStateInit;
    } });
    Object.defineProperty(exports, "storeStateInit", { enumerable: true, get: function() {
      return StateInit_1.storeStateInit;
    } });
    var StorageInto_1 = require_StorageInto();
    Object.defineProperty(exports, "loadStorageInfo", { enumerable: true, get: function() {
      return StorageInto_1.loadStorageInfo;
    } });
    Object.defineProperty(exports, "storeStorageInfo", { enumerable: true, get: function() {
      return StorageInto_1.storeStorageInfo;
    } });
    var StorageUsed_1 = require_StorageUsed();
    Object.defineProperty(exports, "loadStorageUsed", { enumerable: true, get: function() {
      return StorageUsed_1.loadStorageUsed;
    } });
    Object.defineProperty(exports, "storeStorageUsed", { enumerable: true, get: function() {
      return StorageUsed_1.storeStorageUsed;
    } });
    var StorageUsedShort_1 = require_StorageUsedShort();
    Object.defineProperty(exports, "loadStorageUsedShort", { enumerable: true, get: function() {
      return StorageUsedShort_1.loadStorageUsedShort;
    } });
    Object.defineProperty(exports, "storeStorageUsedShort", { enumerable: true, get: function() {
      return StorageUsedShort_1.storeStorageUsedShort;
    } });
    var TickTock_1 = require_TickTock();
    Object.defineProperty(exports, "loadTickTock", { enumerable: true, get: function() {
      return TickTock_1.loadTickTock;
    } });
    Object.defineProperty(exports, "storeTickTock", { enumerable: true, get: function() {
      return TickTock_1.storeTickTock;
    } });
    var Transaction_1 = require_Transaction();
    Object.defineProperty(exports, "loadTransaction", { enumerable: true, get: function() {
      return Transaction_1.loadTransaction;
    } });
    Object.defineProperty(exports, "storeTransaction", { enumerable: true, get: function() {
      return Transaction_1.storeTransaction;
    } });
    var TransactionActionPhase_1 = require_TransactionActionPhase();
    Object.defineProperty(exports, "loadTransactionActionPhase", { enumerable: true, get: function() {
      return TransactionActionPhase_1.loadTransactionActionPhase;
    } });
    Object.defineProperty(exports, "storeTransactionActionPhase", { enumerable: true, get: function() {
      return TransactionActionPhase_1.storeTransactionActionPhase;
    } });
    var TransactionBouncePhase_1 = require_TransactionBouncePhase();
    Object.defineProperty(exports, "loadTransactionBouncePhase", { enumerable: true, get: function() {
      return TransactionBouncePhase_1.loadTransactionBouncePhase;
    } });
    Object.defineProperty(exports, "storeTransactionBouncePhase", { enumerable: true, get: function() {
      return TransactionBouncePhase_1.storeTransactionBouncePhase;
    } });
    var TransactionComputePhase_1 = require_TransactionComputePhase();
    Object.defineProperty(exports, "loadTransactionComputePhase", { enumerable: true, get: function() {
      return TransactionComputePhase_1.loadTransactionComputePhase;
    } });
    Object.defineProperty(exports, "storeTransactionComputePhase", { enumerable: true, get: function() {
      return TransactionComputePhase_1.storeTransactionComputePhase;
    } });
    var TransactionCreditPhase_1 = require_TransactionCreditPhase();
    Object.defineProperty(exports, "loadTransactionCreditPhase", { enumerable: true, get: function() {
      return TransactionCreditPhase_1.loadTransactionCreditPhase;
    } });
    Object.defineProperty(exports, "storeTransactionCreditPhase", { enumerable: true, get: function() {
      return TransactionCreditPhase_1.storeTransactionCreditPhase;
    } });
    var TransactionDescription_1 = require_TransactionDescription();
    Object.defineProperty(exports, "loadTransactionDescription", { enumerable: true, get: function() {
      return TransactionDescription_1.loadTransactionDescription;
    } });
    Object.defineProperty(exports, "storeTransactionDescription", { enumerable: true, get: function() {
      return TransactionDescription_1.storeTransactionDescription;
    } });
    var TransactionStoragePhase_1 = require_TransactionStoragePhase();
    Object.defineProperty(exports, "loadTransactionStoragePhase", { enumerable: true, get: function() {
      return TransactionStoragePhase_1.loadTransactionStoragePhase;
    } });
    Object.defineProperty(exports, "storeTransactionsStoragePhase", { enumerable: true, get: function() {
      return TransactionStoragePhase_1.storeTransactionsStoragePhase;
    } });
  }
});

// node_modules/@ton/core/dist/contract/openContract.js
var require_openContract = __commonJS({
  "node_modules/@ton/core/dist/contract/openContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.openContract = void 0;
    var Address_1 = require_Address();
    var Cell_1 = require_Cell();
    function openContract(src, factory) {
      let address;
      let init = null;
      if (!Address_1.Address.isAddress(src.address)) {
        throw Error("Invalid address");
      }
      address = src.address;
      if (src.init) {
        if (!(src.init.code instanceof Cell_1.Cell)) {
          throw Error("Invalid init.code");
        }
        if (!(src.init.data instanceof Cell_1.Cell)) {
          throw Error("Invalid init.data");
        }
        init = src.init;
      }
      let executor = factory({ address, init });
      return new Proxy(src, {
        get(target, prop) {
          const value = target[prop];
          if (typeof prop === "string" && (prop.startsWith("get") || prop.startsWith("send"))) {
            if (typeof value === "function") {
              return (...args) => value.apply(target, [executor, ...args]);
            }
          }
          return value;
        }
      });
    }
    exports.openContract = openContract;
  }
});

// node_modules/@ton/core/dist/contract/ComputeError.js
var require_ComputeError = __commonJS({
  "node_modules/@ton/core/dist/contract/ComputeError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ComputeError = void 0;
    var ComputeError = class _ComputeError extends Error {
      constructor(message, exitCode, opts) {
        super(message);
        this.exitCode = exitCode;
        this.debugLogs = opts && opts.debugLogs ? opts.debugLogs : null;
        this.logs = opts && opts.logs ? opts.logs : null;
        Object.setPrototypeOf(this, _ComputeError.prototype);
      }
    };
    exports.ComputeError = ComputeError;
  }
});

// node_modules/@ton/core/dist/utils/getMethodId.js
var require_getMethodId = __commonJS({
  "node_modules/@ton/core/dist/utils/getMethodId.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMethodId = void 0;
    var TABLE = new Int16Array([
      0,
      4129,
      8258,
      12387,
      16516,
      20645,
      24774,
      28903,
      33032,
      37161,
      41290,
      45419,
      49548,
      53677,
      57806,
      61935,
      4657,
      528,
      12915,
      8786,
      21173,
      17044,
      29431,
      25302,
      37689,
      33560,
      45947,
      41818,
      54205,
      50076,
      62463,
      58334,
      9314,
      13379,
      1056,
      5121,
      25830,
      29895,
      17572,
      21637,
      42346,
      46411,
      34088,
      38153,
      58862,
      62927,
      50604,
      54669,
      13907,
      9842,
      5649,
      1584,
      30423,
      26358,
      22165,
      18100,
      46939,
      42874,
      38681,
      34616,
      63455,
      59390,
      55197,
      51132,
      18628,
      22757,
      26758,
      30887,
      2112,
      6241,
      10242,
      14371,
      51660,
      55789,
      59790,
      63919,
      35144,
      39273,
      43274,
      47403,
      23285,
      19156,
      31415,
      27286,
      6769,
      2640,
      14899,
      10770,
      56317,
      52188,
      64447,
      60318,
      39801,
      35672,
      47931,
      43802,
      27814,
      31879,
      19684,
      23749,
      11298,
      15363,
      3168,
      7233,
      60846,
      64911,
      52716,
      56781,
      44330,
      48395,
      36200,
      40265,
      32407,
      28342,
      24277,
      20212,
      15891,
      11826,
      7761,
      3696,
      65439,
      61374,
      57309,
      53244,
      48923,
      44858,
      40793,
      36728,
      37256,
      33193,
      45514,
      41451,
      53516,
      49453,
      61774,
      57711,
      4224,
      161,
      12482,
      8419,
      20484,
      16421,
      28742,
      24679,
      33721,
      37784,
      41979,
      46042,
      49981,
      54044,
      58239,
      62302,
      689,
      4752,
      8947,
      13010,
      16949,
      21012,
      25207,
      29270,
      46570,
      42443,
      38312,
      34185,
      62830,
      58703,
      54572,
      50445,
      13538,
      9411,
      5280,
      1153,
      29798,
      25671,
      21540,
      17413,
      42971,
      47098,
      34713,
      38840,
      59231,
      63358,
      50973,
      55100,
      9939,
      14066,
      1681,
      5808,
      26199,
      30326,
      17941,
      22068,
      55628,
      51565,
      63758,
      59695,
      39368,
      35305,
      47498,
      43435,
      22596,
      18533,
      30726,
      26663,
      6336,
      2273,
      14466,
      10403,
      52093,
      56156,
      60223,
      64286,
      35833,
      39896,
      43963,
      48026,
      19061,
      23124,
      27191,
      31254,
      2801,
      6864,
      10931,
      14994,
      64814,
      60687,
      56684,
      52557,
      48554,
      44427,
      40424,
      36297,
      31782,
      27655,
      23652,
      19525,
      15522,
      11395,
      7392,
      3265,
      61215,
      65342,
      53085,
      57212,
      44955,
      49082,
      36825,
      40952,
      28183,
      32310,
      20053,
      24180,
      11923,
      16050,
      3793,
      7920
    ]);
    function crc16(data) {
      if (!(data instanceof Buffer)) {
        data = Buffer.from(data);
      }
      let crc = 0;
      for (let index = 0; index < data.length; index++) {
        const byte = data[index];
        crc = (TABLE[(crc >> 8 ^ byte) & 255] ^ crc << 8) & 65535;
      }
      return crc;
    }
    function getMethodId(name) {
      return crc16(name) & 65535 | 65536;
    }
    exports.getMethodId = getMethodId;
  }
});

// node_modules/@ton/core/dist/crypto/safeSign.js
var require_safeSign = __commonJS({
  "node_modules/@ton/core/dist/crypto/safeSign.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.safeSignVerify = exports.safeSign = void 0;
    var crypto_1 = require_dist();
    var MIN_SEED_LENGTH = 8;
    var MAX_SEED_LENGTH = 64;
    function createSafeSignHash(cell, seed) {
      let seedData = Buffer.from(seed);
      if (seedData.length > MAX_SEED_LENGTH) {
        throw Error("Seed can	 be longer than 64 bytes");
      }
      if (seedData.length < MIN_SEED_LENGTH) {
        throw Error("Seed must be at least 8 bytes");
      }
      return (0, crypto_1.sha256_sync)(Buffer.concat([Buffer.from([255, 255]), seedData, cell.hash()]));
    }
    function safeSign(cell, secretKey, seed = "ton-safe-sign-magic") {
      return (0, crypto_1.sign)(createSafeSignHash(cell, seed), secretKey);
    }
    exports.safeSign = safeSign;
    function safeSignVerify(cell, signature, publicKey, seed = "ton-safe-sign-magic") {
      return (0, crypto_1.signVerify)(createSafeSignHash(cell, seed), signature, publicKey);
    }
    exports.safeSignVerify = safeSignVerify;
  }
});

// node_modules/@ton/core/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@ton/core/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.safeSignVerify = exports.safeSign = exports.getMethodId = exports.base32Encode = exports.base32Decode = exports.crc32c = exports.crc16 = exports.fromNano = exports.toNano = exports.ComputeError = exports.openContract = exports.TupleBuilder = exports.TupleReader = exports.serializeTuple = exports.parseTuple = exports.generateMerkleUpdate = exports.generateMerkleProof = exports.exoticPruned = exports.exoticMerkleUpdate = exports.exoticMerkleProof = exports.Dictionary = exports.Cell = exports.CellType = exports.Slice = exports.beginCell = exports.Builder = exports.BitBuilder = exports.BitReader = exports.BitString = exports.contractAddress = exports.ADNLAddress = exports.ExternalAddress = exports.address = exports.Address = void 0;
    var Address_1 = require_Address();
    Object.defineProperty(exports, "Address", { enumerable: true, get: function() {
      return Address_1.Address;
    } });
    Object.defineProperty(exports, "address", { enumerable: true, get: function() {
      return Address_1.address;
    } });
    var ExternalAddress_1 = require_ExternalAddress();
    Object.defineProperty(exports, "ExternalAddress", { enumerable: true, get: function() {
      return ExternalAddress_1.ExternalAddress;
    } });
    var ADNLAddress_1 = require_ADNLAddress();
    Object.defineProperty(exports, "ADNLAddress", { enumerable: true, get: function() {
      return ADNLAddress_1.ADNLAddress;
    } });
    var contractAddress_1 = require_contractAddress();
    Object.defineProperty(exports, "contractAddress", { enumerable: true, get: function() {
      return contractAddress_1.contractAddress;
    } });
    var BitString_1 = require_BitString();
    Object.defineProperty(exports, "BitString", { enumerable: true, get: function() {
      return BitString_1.BitString;
    } });
    var BitReader_1 = require_BitReader();
    Object.defineProperty(exports, "BitReader", { enumerable: true, get: function() {
      return BitReader_1.BitReader;
    } });
    var BitBuilder_1 = require_BitBuilder();
    Object.defineProperty(exports, "BitBuilder", { enumerable: true, get: function() {
      return BitBuilder_1.BitBuilder;
    } });
    var Builder_1 = require_Builder();
    Object.defineProperty(exports, "Builder", { enumerable: true, get: function() {
      return Builder_1.Builder;
    } });
    Object.defineProperty(exports, "beginCell", { enumerable: true, get: function() {
      return Builder_1.beginCell;
    } });
    var Slice_1 = require_Slice();
    Object.defineProperty(exports, "Slice", { enumerable: true, get: function() {
      return Slice_1.Slice;
    } });
    var CellType_1 = require_CellType();
    Object.defineProperty(exports, "CellType", { enumerable: true, get: function() {
      return CellType_1.CellType;
    } });
    var Cell_1 = require_Cell();
    Object.defineProperty(exports, "Cell", { enumerable: true, get: function() {
      return Cell_1.Cell;
    } });
    var Dictionary_1 = require_Dictionary();
    Object.defineProperty(exports, "Dictionary", { enumerable: true, get: function() {
      return Dictionary_1.Dictionary;
    } });
    var exoticMerkleProof_1 = require_exoticMerkleProof();
    Object.defineProperty(exports, "exoticMerkleProof", { enumerable: true, get: function() {
      return exoticMerkleProof_1.exoticMerkleProof;
    } });
    var exoticMerkleUpdate_1 = require_exoticMerkleUpdate();
    Object.defineProperty(exports, "exoticMerkleUpdate", { enumerable: true, get: function() {
      return exoticMerkleUpdate_1.exoticMerkleUpdate;
    } });
    var exoticPruned_1 = require_exoticPruned();
    Object.defineProperty(exports, "exoticPruned", { enumerable: true, get: function() {
      return exoticPruned_1.exoticPruned;
    } });
    var generateMerkleProof_1 = require_generateMerkleProof();
    Object.defineProperty(exports, "generateMerkleProof", { enumerable: true, get: function() {
      return generateMerkleProof_1.generateMerkleProof;
    } });
    var generateMerkleUpdate_1 = require_generateMerkleUpdate();
    Object.defineProperty(exports, "generateMerkleUpdate", { enumerable: true, get: function() {
      return generateMerkleUpdate_1.generateMerkleUpdate;
    } });
    var tuple_1 = require_tuple();
    Object.defineProperty(exports, "parseTuple", { enumerable: true, get: function() {
      return tuple_1.parseTuple;
    } });
    Object.defineProperty(exports, "serializeTuple", { enumerable: true, get: function() {
      return tuple_1.serializeTuple;
    } });
    var reader_1 = require_reader();
    Object.defineProperty(exports, "TupleReader", { enumerable: true, get: function() {
      return reader_1.TupleReader;
    } });
    var builder_1 = require_builder();
    Object.defineProperty(exports, "TupleBuilder", { enumerable: true, get: function() {
      return builder_1.TupleBuilder;
    } });
    __exportStar(require_export(), exports);
    var openContract_1 = require_openContract();
    Object.defineProperty(exports, "openContract", { enumerable: true, get: function() {
      return openContract_1.openContract;
    } });
    var ComputeError_1 = require_ComputeError();
    Object.defineProperty(exports, "ComputeError", { enumerable: true, get: function() {
      return ComputeError_1.ComputeError;
    } });
    var convert_1 = require_convert();
    Object.defineProperty(exports, "toNano", { enumerable: true, get: function() {
      return convert_1.toNano;
    } });
    Object.defineProperty(exports, "fromNano", { enumerable: true, get: function() {
      return convert_1.fromNano;
    } });
    var crc16_1 = require_crc16();
    Object.defineProperty(exports, "crc16", { enumerable: true, get: function() {
      return crc16_1.crc16;
    } });
    var crc32c_1 = require_crc32c();
    Object.defineProperty(exports, "crc32c", { enumerable: true, get: function() {
      return crc32c_1.crc32c;
    } });
    var base32_1 = require_base32();
    Object.defineProperty(exports, "base32Decode", { enumerable: true, get: function() {
      return base32_1.base32Decode;
    } });
    Object.defineProperty(exports, "base32Encode", { enumerable: true, get: function() {
      return base32_1.base32Encode;
    } });
    var getMethodId_1 = require_getMethodId();
    Object.defineProperty(exports, "getMethodId", { enumerable: true, get: function() {
      return getMethodId_1.getMethodId;
    } });
    var safeSign_1 = require_safeSign();
    Object.defineProperty(exports, "safeSign", { enumerable: true, get: function() {
      return safeSign_1.safeSign;
    } });
    Object.defineProperty(exports, "safeSignVerify", { enumerable: true, get: function() {
      return safeSign_1.safeSignVerify;
    } });
  }
});

// node_modules/@ton/ton/dist/client/api/TonCache.js
var require_TonCache = __commonJS({
  "node_modules/@ton/ton/dist/client/api/TonCache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InMemoryCache = void 0;
    var InMemoryCache = class {
      constructor() {
        this.cache = /* @__PURE__ */ new Map();
        this.set = async (namespace, key, value) => {
          if (value !== null) {
            this.cache.set(namespace + "$$" + key, value);
          } else {
            this.cache.delete(namespace + "$$" + key);
          }
        };
        this.get = async (namespace, key) => {
          let res = this.cache.get(namespace + "$$" + key);
          if (res !== void 0) {
            return res;
          } else {
            return null;
          }
        };
      }
    };
    exports.InMemoryCache = InMemoryCache;
  }
});

// node_modules/dataloader/index.js
var require_dataloader = __commonJS({
  "node_modules/dataloader/index.js"(exports, module) {
    "use strict";
    var DataLoader = function() {
      function DataLoader2(batchLoadFn, options) {
        if (typeof batchLoadFn !== "function") {
          throw new TypeError("DataLoader must be constructed with a function which accepts " + ("Array<key> and returns Promise<Array<value>>, but got: " + batchLoadFn + "."));
        }
        this._batchLoadFn = batchLoadFn;
        this._maxBatchSize = getValidMaxBatchSize(options);
        this._batchScheduleFn = getValidBatchScheduleFn(options);
        this._cacheKeyFn = getValidCacheKeyFn(options);
        this._cacheMap = getValidCacheMap(options);
        this._batch = null;
        this.name = getValidName(options);
      }
      var _proto = DataLoader2.prototype;
      _proto.load = function load(key) {
        if (key === null || key === void 0) {
          throw new TypeError("The loader.load() function must be called with a value, " + ("but got: " + String(key) + "."));
        }
        var batch = getCurrentBatch(this);
        var cacheMap = this._cacheMap;
        var cacheKey = this._cacheKeyFn(key);
        if (cacheMap) {
          var cachedPromise = cacheMap.get(cacheKey);
          if (cachedPromise) {
            var cacheHits = batch.cacheHits || (batch.cacheHits = []);
            return new Promise(function(resolve) {
              cacheHits.push(function() {
                resolve(cachedPromise);
              });
            });
          }
        }
        batch.keys.push(key);
        var promise = new Promise(function(resolve, reject) {
          batch.callbacks.push({
            resolve,
            reject
          });
        });
        if (cacheMap) {
          cacheMap.set(cacheKey, promise);
        }
        return promise;
      };
      _proto.loadMany = function loadMany(keys) {
        if (!isArrayLike(keys)) {
          throw new TypeError("The loader.loadMany() function must be called with Array<key> " + ("but got: " + keys + "."));
        }
        var loadPromises = [];
        for (var i = 0; i < keys.length; i++) {
          loadPromises.push(this.load(keys[i])["catch"](function(error) {
            return error;
          }));
        }
        return Promise.all(loadPromises);
      };
      _proto.clear = function clear(key) {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          var cacheKey = this._cacheKeyFn(key);
          cacheMap["delete"](cacheKey);
        }
        return this;
      };
      _proto.clearAll = function clearAll() {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          cacheMap.clear();
        }
        return this;
      };
      _proto.prime = function prime(key, value) {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          var cacheKey = this._cacheKeyFn(key);
          if (cacheMap.get(cacheKey) === void 0) {
            var promise;
            if (value instanceof Error) {
              promise = Promise.reject(value);
              promise["catch"](function() {
              });
            } else {
              promise = Promise.resolve(value);
            }
            cacheMap.set(cacheKey, promise);
          }
        }
        return this;
      };
      return DataLoader2;
    }();
    var enqueuePostPromiseJob = typeof process === "object" && typeof process.nextTick === "function" ? function(fn) {
      if (!resolvedPromise) {
        resolvedPromise = Promise.resolve();
      }
      resolvedPromise.then(function() {
        process.nextTick(fn);
      });
    } : typeof setImmediate === "function" ? function(fn) {
      setImmediate(fn);
    } : function(fn) {
      setTimeout(fn);
    };
    var resolvedPromise;
    function getCurrentBatch(loader) {
      var existingBatch = loader._batch;
      if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {
        return existingBatch;
      }
      var newBatch = {
        hasDispatched: false,
        keys: [],
        callbacks: []
      };
      loader._batch = newBatch;
      loader._batchScheduleFn(function() {
        dispatchBatch(loader, newBatch);
      });
      return newBatch;
    }
    function dispatchBatch(loader, batch) {
      batch.hasDispatched = true;
      if (batch.keys.length === 0) {
        resolveCacheHits(batch);
        return;
      }
      var batchPromise;
      try {
        batchPromise = loader._batchLoadFn(batch.keys);
      } catch (e) {
        return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function " + ("errored synchronously: " + String(e) + ".")));
      }
      if (!batchPromise || typeof batchPromise.then !== "function") {
        return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise: " + String(batchPromise) + ".")));
      }
      batchPromise.then(function(values) {
        if (!isArrayLike(values)) {
          throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise of an Array: " + String(values) + "."));
        }
        if (values.length !== batch.keys.length) {
          throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys." + ("\n\nKeys:\n" + String(batch.keys)) + ("\n\nValues:\n" + String(values)));
        }
        resolveCacheHits(batch);
        for (var i = 0; i < batch.callbacks.length; i++) {
          var value = values[i];
          if (value instanceof Error) {
            batch.callbacks[i].reject(value);
          } else {
            batch.callbacks[i].resolve(value);
          }
        }
      })["catch"](function(error) {
        failedDispatch(loader, batch, error);
      });
    }
    function failedDispatch(loader, batch, error) {
      resolveCacheHits(batch);
      for (var i = 0; i < batch.keys.length; i++) {
        loader.clear(batch.keys[i]);
        batch.callbacks[i].reject(error);
      }
    }
    function resolveCacheHits(batch) {
      if (batch.cacheHits) {
        for (var i = 0; i < batch.cacheHits.length; i++) {
          batch.cacheHits[i]();
        }
      }
    }
    function getValidMaxBatchSize(options) {
      var shouldBatch = !options || options.batch !== false;
      if (!shouldBatch) {
        return 1;
      }
      var maxBatchSize = options && options.maxBatchSize;
      if (maxBatchSize === void 0) {
        return Infinity;
      }
      if (typeof maxBatchSize !== "number" || maxBatchSize < 1) {
        throw new TypeError("maxBatchSize must be a positive number: " + maxBatchSize);
      }
      return maxBatchSize;
    }
    function getValidBatchScheduleFn(options) {
      var batchScheduleFn = options && options.batchScheduleFn;
      if (batchScheduleFn === void 0) {
        return enqueuePostPromiseJob;
      }
      if (typeof batchScheduleFn !== "function") {
        throw new TypeError("batchScheduleFn must be a function: " + batchScheduleFn);
      }
      return batchScheduleFn;
    }
    function getValidCacheKeyFn(options) {
      var cacheKeyFn = options && options.cacheKeyFn;
      if (cacheKeyFn === void 0) {
        return function(key) {
          return key;
        };
      }
      if (typeof cacheKeyFn !== "function") {
        throw new TypeError("cacheKeyFn must be a function: " + cacheKeyFn);
      }
      return cacheKeyFn;
    }
    function getValidCacheMap(options) {
      var shouldCache = !options || options.cache !== false;
      if (!shouldCache) {
        return null;
      }
      var cacheMap = options && options.cacheMap;
      if (cacheMap === void 0) {
        return /* @__PURE__ */ new Map();
      }
      if (cacheMap !== null) {
        var cacheFunctions = ["get", "set", "delete", "clear"];
        var missingFunctions = cacheFunctions.filter(function(fnName) {
          return cacheMap && typeof cacheMap[fnName] !== "function";
        });
        if (missingFunctions.length !== 0) {
          throw new TypeError("Custom cacheMap missing methods: " + missingFunctions.join(", "));
        }
      }
      return cacheMap;
    }
    function getValidName(options) {
      if (options && options.name) {
        return options.name;
      }
      return null;
    }
    function isArrayLike(x) {
      return typeof x === "object" && x !== null && typeof x.length === "number" && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));
    }
    module.exports = DataLoader;
  }
});

// node_modules/axios/dist/browser/axios.cjs
var require_axios = __commonJS({
  "node_modules/axios/dist/browser/axios.cjs"(exports, module) {
    "use strict";
    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    var { toString } = Object.prototype;
    var { getPrototypeOf } = Object;
    var kindOf = ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    var kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    var typeOfTest = (type) => (thing) => typeof thing === type;
    var { isArray } = Array;
    var isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    var isString = typeOfTest("string");
    var isFunction = typeOfTest("function");
    var isNumber = typeOfTest("number");
    var isObject = (thing) => thing !== null && typeof thing === "object";
    var isBoolean = (thing) => thing === true || thing === false;
    var isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
    };
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    var isStream = (val) => isObject(val) && isFunction(val.pipe);
    var isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
    };
    var isURLSearchParams = kindOfTest("URLSearchParams");
    var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      key = key.toLowerCase();
      const keys = Object.keys(obj);
      let i = keys.length;
      let _key;
      while (i-- > 0) {
        _key = keys[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    var _global = (() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    var isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l = arguments.length; i < l; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }
    var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    var stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    var endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    var toArray = (thing) => {
      if (!thing)
        return null;
      if (isArray(thing))
        return thing;
      let i = thing.length;
      if (!isNumber(i))
        return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    var isTypedArray = ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    var forEachEntry = (obj, fn) => {
      const generator = obj && obj[Symbol.iterator];
      const iterator = generator.call(obj);
      let result;
      while ((result = iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    var matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    var isRegExp = kindOfTest("RegExp");
    var reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    var freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction(value))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    var toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
      return obj;
    };
    var noop = () => {
    };
    var toFiniteNumber = (value, defaultValue) => {
      value = +value;
      return Number.isFinite(value) ? value : defaultValue;
    };
    var ALPHA = "abcdefghijklmnopqrstuvwxyz";
    var DIGIT = "0123456789";
    var ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      while (size--) {
        str += alphabet[Math.random() * length | 0];
      }
      return str;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
    }
    var toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i) => {
        if (isObject(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack[i] = source;
            const target = isArray(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    var isAsyncFn = kindOfTest("AsyncFunction");
    var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
    var utils$1 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      ALPHABET,
      generateString,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable
    };
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils$1.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype$1 = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code, config, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    var httpAdapter = null;
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path)
        return key;
      return path.concat(key).map(function each(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new FormData();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$1.isUndefined(value))
          return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function each(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url, params, options) {
      if (!params) {
        return url;
      }
      const _encode = options && options.encode || encode;
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    }
    var InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    };
    var InterceptorManager$1 = InterceptorManager;
    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    var URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    var FormData$1 = typeof FormData !== "undefined" ? FormData : null;
    var Blob$1 = typeof Blob !== "undefined" ? Blob : null;
    var platform$1 = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
      },
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    var hasStandardBrowserEnv = ((product) => {
      return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
    })(typeof navigator !== "undefined" && navigator.product);
    var hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    var utils = Object.freeze({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserWebWorkerEnv,
      hasStandardBrowserEnv
    });
    var platform = {
      ...utils,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys = Object.keys(arr);
      let i;
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        let name = path[index++];
        if (name === "__proto__")
          return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && utils$1.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$1.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index);
        if (result && utils$1.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    var defaults$1 = defaults;
    var ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    var parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    var $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value))
        return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    var AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while (i--) {
          const key = keys[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    var AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config = this || defaults$1;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    var cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path, domain, secure) {
          const cookie = [name + "=" + encodeURIComponent(value)];
          utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
          utils$1.isString(path) && cookie.push("path=" + path);
          utils$1.isString(domain) && cookie.push("domain=" + domain);
          secure === true && cookie.push("secure");
          document.cookie = cookie.join("; ");
        },
        read(name) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    var isURLSameOrigin = platform.hasStandardBrowserEnv ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        const msie = /(msie|trident)/i.test(navigator.userAgent);
        const urlParsingNode = document.createElement("a");
        let originURL;
        function resolveURL(url) {
          let href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }()
    );
    function parseProtocol(url) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    }
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function progressEventReducer(listener, isDownloadStream) {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return (e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
      };
    }
    var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    var xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        let requestData = config.data;
        const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
        let { responseType, withXSRFToken } = config;
        let onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        let contentType;
        if (utils$1.isFormData(requestData)) {
          if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
            requestHeaders.setContentType(false);
          } else if ((contentType = requestHeaders.getContentType()) !== false) {
            const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
            requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
          }
        }
        let request = new XMLHttpRequest();
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        if (platform.hasStandardBrowserEnv) {
          withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
          if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {
            const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
            if (xsrfValue) {
              requestHeaders.set(config.xsrfHeaderName, xsrfValue);
            }
          }
        }
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
        }
        if (config.cancelToken || config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(fullPath);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
    var knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter
    };
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    var renderReason = (reason) => `- ${reason}`;
    var isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    var adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
        const { length } = adapters2;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for (let i = 0; i < length; i++) {
          nameOrAdapter = adapters2[i];
          let id;
          adapter = nameOrAdapter;
          if (!isResolvedHandle(nameOrAdapter)) {
            adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
            if (adapter === void 0) {
              throw new AxiosError(`Unknown adapter '${id}'`);
            }
          }
          if (adapter) {
            break;
          }
          rejectedReasons[id || "#" + i] = adapter;
        }
        if (!adapter) {
          const reasons = Object.entries(rejectedReasons).map(
            ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
          );
          let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
          throw new AxiosError(
            `There is no suitable adapter to dispatch the request ` + s,
            "ERR_NOT_SUPPORT"
          );
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    var headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b, caseless) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(a, b, caseless);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a, caseless);
        }
      }
      function valueFromConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        }
      }
      function defaultToConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
          return getMergedValue(a, b);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
      };
      utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    var VERSION = "1.6.8";
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys = Object.keys(options);
      let i = keys.length;
      while (i-- > 0) {
        const opt = keys[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    var validator = {
      assertOptions,
      validators: validators$1
    };
    var validators = validator.validators;
    var Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config) {
        try {
          return await this._request(configOrUrl, config);
        } catch (err) {
          if (err instanceof Error) {
            let dummy;
            Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
            const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            if (!err.stack) {
              err.stack = stack;
            } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack;
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var Axios$1 = Axios;
    var CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners)
            return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError(message, config, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new _CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };
    var CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    var HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    var HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    module.exports = axios;
  }
});

// node_modules/zod/lib/helpers/util.js
var require_util = __commonJS({
  "node_modules/zod/lib/helpers/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = void 0;
    var util;
    (function(util2) {
      util2.assertEqual = (val) => val;
      function assertIs(_arg) {
      }
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util = exports.util || (exports.util = {}));
    var objectUtil;
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil = exports.objectUtil || (exports.objectUtil = {}));
    exports.ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    var getParsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return exports.ZodParsedType.undefined;
        case "string":
          return exports.ZodParsedType.string;
        case "number":
          return isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;
        case "boolean":
          return exports.ZodParsedType.boolean;
        case "function":
          return exports.ZodParsedType.function;
        case "bigint":
          return exports.ZodParsedType.bigint;
        case "symbol":
          return exports.ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return exports.ZodParsedType.array;
          }
          if (data === null) {
            return exports.ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return exports.ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return exports.ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return exports.ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return exports.ZodParsedType.date;
          }
          return exports.ZodParsedType.object;
        default:
          return exports.ZodParsedType.unknown;
      }
    };
    exports.getParsedType = getParsedType;
  }
});

// node_modules/zod/lib/ZodError.js
var require_ZodError = __commonJS({
  "node_modules/zod/lib/ZodError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ZodError = exports.quotelessJson = exports.ZodIssueCode = void 0;
    var util_1 = require_util();
    exports.ZodIssueCode = util_1.util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    var quotelessJson = (obj) => {
      const json = JSON.stringify(obj, null, 2);
      return json.replace(/"([^"]+)":/g, "$1:");
    };
    exports.quotelessJson = quotelessJson;
    var ZodError = class _ZodError extends Error {
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      get errors() {
        return this.issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
          for (const issue of error.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue.path.length) {
                const el = issue.path[i];
                const terminal = i === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      static assert(value) {
        if (!(value instanceof _ZodError)) {
          throw new Error(`Not a ZodError: ${value}`);
        }
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util_1.util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    exports.ZodError = ZodError;
    ZodError.create = (issues) => {
      const error = new ZodError(issues);
      return error;
    };
  }
});

// node_modules/zod/lib/locales/en.js
var require_en = __commonJS({
  "node_modules/zod/lib/locales/en.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var ZodError_1 = require_ZodError();
    var errorMap = (issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodError_1.ZodIssueCode.invalid_type:
          if (issue.received === util_1.ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodError_1.ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1.util.jsonStringifyReplacer)}`;
          break;
        case ZodError_1.ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util_1.util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodError_1.ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodError_1.ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util_1.util.joinValues(issue.options)}`;
          break;
        case ZodError_1.ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util_1.util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodError_1.ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodError_1.ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodError_1.ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodError_1.ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util_1.util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodError_1.ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodError_1.ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodError_1.ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodError_1.ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodError_1.ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodError_1.ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util_1.util.assertNever(issue);
      }
      return { message };
    };
    exports.default = errorMap;
  }
});

// node_modules/zod/lib/errors.js
var require_errors = __commonJS({
  "node_modules/zod/lib/errors.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getErrorMap = exports.setErrorMap = exports.defaultErrorMap = void 0;
    var en_1 = __importDefault(require_en());
    exports.defaultErrorMap = en_1.default;
    var overrideErrorMap = en_1.default;
    function setErrorMap(map) {
      overrideErrorMap = map;
    }
    exports.setErrorMap = setErrorMap;
    function getErrorMap() {
      return overrideErrorMap;
    }
    exports.getErrorMap = getErrorMap;
  }
});

// node_modules/zod/lib/helpers/parseUtil.js
var require_parseUtil = __commonJS({
  "node_modules/zod/lib/helpers/parseUtil.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.addIssueToContext = exports.EMPTY_PATH = exports.makeIssue = void 0;
    var errors_1 = require_errors();
    var en_1 = __importDefault(require_en());
    var makeIssue = (params) => {
      const { data, path, errorMaps, issueData } = params;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      if (issueData.message !== void 0) {
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message
        };
      }
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: errorMessage
      };
    };
    exports.makeIssue = makeIssue;
    exports.EMPTY_PATH = [];
    function addIssueToContext(ctx, issueData) {
      const overrideMap = (0, errors_1.getErrorMap)();
      const issue = (0, exports.makeIssue)({
        issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          overrideMap,
          overrideMap === en_1.default ? void 0 : en_1.default
          // then global default map
        ].filter((x) => !!x)
      });
      ctx.common.issues.push(issue);
    }
    exports.addIssueToContext = addIssueToContext;
    var ParseStatus = class _ParseStatus {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return exports.INVALID;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return exports.INVALID;
          if (value.status === "aborted")
            return exports.INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    exports.ParseStatus = ParseStatus;
    exports.INVALID = Object.freeze({
      status: "aborted"
    });
    var DIRTY = (value) => ({ status: "dirty", value });
    exports.DIRTY = DIRTY;
    var OK = (value) => ({ status: "valid", value });
    exports.OK = OK;
    var isAborted = (x) => x.status === "aborted";
    exports.isAborted = isAborted;
    var isDirty = (x) => x.status === "dirty";
    exports.isDirty = isDirty;
    var isValid = (x) => x.status === "valid";
    exports.isValid = isValid;
    var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
    exports.isAsync = isAsync;
  }
});

// node_modules/zod/lib/helpers/typeAliases.js
var require_typeAliases = __commonJS({
  "node_modules/zod/lib/helpers/typeAliases.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/zod/lib/helpers/errorUtil.js
var require_errorUtil = __commonJS({
  "node_modules/zod/lib/helpers/errorUtil.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorUtil = void 0;
    var errorUtil;
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
    })(errorUtil = exports.errorUtil || (exports.errorUtil = {}));
  }
});

// node_modules/zod/lib/types.js
var require_types = __commonJS({
  "node_modules/zod/lib/types.js"(exports) {
    "use strict";
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var _ZodEnum_cache;
    var _ZodNativeEnum_cache;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boolean = exports.bigint = exports.array = exports.any = exports.coerce = exports.ZodFirstPartyTypeKind = exports.late = exports.ZodSchema = exports.Schema = exports.custom = exports.ZodReadonly = exports.ZodPipeline = exports.ZodBranded = exports.BRAND = exports.ZodNaN = exports.ZodCatch = exports.ZodDefault = exports.ZodNullable = exports.ZodOptional = exports.ZodTransformer = exports.ZodEffects = exports.ZodPromise = exports.ZodNativeEnum = exports.ZodEnum = exports.ZodLiteral = exports.ZodLazy = exports.ZodFunction = exports.ZodSet = exports.ZodMap = exports.ZodRecord = exports.ZodTuple = exports.ZodIntersection = exports.ZodDiscriminatedUnion = exports.ZodUnion = exports.ZodObject = exports.ZodArray = exports.ZodVoid = exports.ZodNever = exports.ZodUnknown = exports.ZodAny = exports.ZodNull = exports.ZodUndefined = exports.ZodSymbol = exports.ZodDate = exports.ZodBoolean = exports.ZodBigInt = exports.ZodNumber = exports.ZodString = exports.datetimeRegex = exports.ZodType = void 0;
    exports.NEVER = exports.void = exports.unknown = exports.union = exports.undefined = exports.tuple = exports.transformer = exports.symbol = exports.string = exports.strictObject = exports.set = exports.record = exports.promise = exports.preprocess = exports.pipeline = exports.ostring = exports.optional = exports.onumber = exports.oboolean = exports.object = exports.number = exports.nullable = exports.null = exports.never = exports.nativeEnum = exports.nan = exports.map = exports.literal = exports.lazy = exports.intersection = exports.instanceof = exports.function = exports.enum = exports.effect = exports.discriminatedUnion = exports.date = void 0;
    var errors_1 = require_errors();
    var errorUtil_1 = require_errorUtil();
    var parseUtil_1 = require_parseUtil();
    var util_1 = require_util();
    var ZodError_1 = require_ZodError();
    var ParseInputLazyPath = class {
      constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (this._key instanceof Array) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    var handleResult = (ctx, result) => {
      if ((0, parseUtil_1.isValid)(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error = new ZodError_1.ZodError(ctx.common.issues);
            this._error = error;
            return this._error;
          }
        };
      }
    };
    function processCreateParams(params) {
      if (!params)
        return {};
      const { errorMap, invalid_type_error, required_error, description } = params;
      if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
      }
      if (errorMap)
        return { errorMap, description };
      const customMap = (iss, ctx) => {
        var _a, _b;
        const { message } = params;
        if (iss.code === "invalid_enum_value") {
          return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
        }
        if (typeof ctx.data === "undefined") {
          return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
        }
        if (iss.code !== "invalid_type")
          return { message: ctx.defaultError };
        return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
      };
      return { errorMap: customMap, description };
    }
    var ZodType = class {
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return (0, util_1.getParsedType)(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: (0, util_1.getParsedType)(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new parseUtil_1.ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: (0, util_1.getParsedType)(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if ((0, parseUtil_1.isAsync)(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        var _a;
        const ctx = {
          common: {
            issues: [],
            async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_1.getParsedType)(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            async: true
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_1.getParsedType)(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check, message) {
        const getIssueProperties = (val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = () => ctx.addIssue({
            code: ZodError_1.ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this, this._def);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    exports.ZodType = ZodType;
    exports.Schema = ZodType;
    exports.ZodSchema = ZodType;
    var cuidRegex = /^c[^\s-]{8,}$/i;
    var cuid2Regex = /^[0-9a-z]+$/;
    var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
    var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    var nanoidRegex = /^[a-z0-9_-]{21}$/i;
    var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    var emojiRegex;
    var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
    var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    var dateRegex = new RegExp(`^${dateRegexSource}$`);
    function timeRegexSource(args) {
      let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
      if (args.precision) {
        regex = `${regex}\\.\\d{${args.precision}}`;
      } else if (args.precision == null) {
        regex = `${regex}(\\.\\d+)?`;
      }
      return regex;
    }
    function timeRegex(args) {
      return new RegExp(`^${timeRegexSource(args)}$`);
    }
    function datetimeRegex(args) {
      let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
      const opts = [];
      opts.push(args.local ? `Z?` : `Z`);
      if (args.offset)
        opts.push(`([+-]\\d{2}:?\\d{2})`);
      regex = `${regex}(${opts.join("|")})`;
      return new RegExp(`^${regex}$`);
    }
    exports.datetimeRegex = datetimeRegex;
    function isValidIP(ip, version) {
      if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
        return true;
      }
      if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
        return true;
      }
      return false;
    }
    var ZodString = class _ZodString extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.string,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "email",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "emoji",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "uuid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "nanoid") {
            if (!nanoidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "nanoid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "cuid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "cuid2",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "ulid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch (_a) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "url",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "regex",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "date") {
            const regex = dateRegex;
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: "date",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "time") {
            const regex = timeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: "time",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "duration") {
            if (!durationRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "duration",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "ip",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64") {
            if (!base64Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "base64",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
          validation,
          code: ZodError_1.ZodIssueCode.invalid_string,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      _addCheck(check) {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil_1.errorUtil.errToObj(options) });
      }
      datetime(options) {
        var _a, _b;
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
          local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
          ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      date(message) {
        return this._addCheck({ kind: "date", message });
      }
      time(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "time",
            precision: null,
            message: options
          });
        }
        return this._addCheck({
          kind: "time",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options === null || options === void 0 ? void 0 : options.position,
          ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      /**
       * @deprecated Use z.string().min(1) instead.
       * @see {@link ZodString.min}
       */
      nonempty(message) {
        return this.min(1, errorUtil_1.errorUtil.errToObj(message));
      }
      trim() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    exports.ZodString = ZodString;
    ZodString.create = (params) => {
      var _a;
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    function floatSafeRemainder(val, step) {
      const valDecCount = (val.toString().split(".")[1] || "").length;
      const stepDecCount = (step.toString().split(".")[1] || "").length;
      const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
      const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
      const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
      return valInt % stepInt / Math.pow(10, decCount);
    }
    var ZodNumber = class _ZodNumber extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.number,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        let ctx = void 0;
        const status = new parseUtil_1.ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util_1.util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil_1.errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil_1.errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util_1.util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    exports.ZodNumber = ZodNumber;
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    var ZodBigInt = class _ZodBigInt extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.bigint) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.bigint,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        let ctx = void 0;
        const status = new parseUtil_1.ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil_1.errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    exports.ZodBigInt = ZodBigInt;
    ZodBigInt.create = (params) => {
      var _a;
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    var ZodBoolean = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodBoolean = ZodBoolean;
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    var ZodDate = class _ZodDate extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.date,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        if (isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_date
          });
          return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    exports.ZodDate = ZodDate;
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    var ZodSymbol = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodSymbol = ZodSymbol;
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    var ZodUndefined = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodUndefined = ZodUndefined;
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    var ZodNull = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.null,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodNull = ZodNull;
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    var ZodAny = class extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodAny = ZodAny;
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    var ZodUnknown = class extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodUnknown = ZodUnknown;
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    var ZodNever = class extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.never,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
    };
    exports.ZodNever = ZodNever;
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    var ZodVoid = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.void,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodVoid = ZodVoid;
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    var ZodArray = class _ZodArray extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.array,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          })).then((result2) => {
            return parseUtil_1.ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return parseUtil_1.ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    exports.ZodArray = ZodArray;
    ZodArray.create = (schema, params) => {
      return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    function deepPartialify(schema) {
      if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
          const fieldSchema = schema.shape[key];
          newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
          ...schema._def,
          shape: () => newShape
        });
      } else if (schema instanceof ZodArray) {
        return new ZodArray({
          ...schema._def,
          type: deepPartialify(schema.element)
        });
      } else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
      } else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
      } else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
      } else {
        return schema;
      }
    }
    var ZodObject = class _ZodObject extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util_1.util.objectKeys(shape);
        return this._cached = { shape, keys };
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") {
          } else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              syncPairs.push({
                key,
                value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil_1.errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a, _b, _c, _d;
              const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil_1.errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index) {
        return new _ZodObject({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        const shape = {};
        util_1.util.objectKeys(mask).forEach((key) => {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util_1.util.objectKeys(this.shape));
      }
    };
    exports.ZodObject = ZodObject;
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    var ZodUnion = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError_1.ZodError(result.ctx.common.issues));
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union,
            unionErrors
          });
          return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError_1.ZodError(issues2));
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union,
            unionErrors
          });
          return parseUtil_1.INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    exports.ZodUnion = ZodUnion;
    ZodUnion.create = (types, params) => {
      return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    var getDiscriminator = (type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return util_1.util.objectValues(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else if (type instanceof ZodOptional) {
        return [void 0, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
      } else {
        return [];
      }
    };
    var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues.length) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    };
    exports.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
    function mergeValues(a, b) {
      const aType = (0, util_1.getParsedType)(a);
      const bType = (0, util_1.getParsedType)(b);
      if (a === b) {
        return { valid: true, data: a };
      } else if (aType === util_1.ZodParsedType.object && bType === util_1.ZodParsedType.object) {
        const bKeys = util_1.util.objectKeys(b);
        const sharedKeys = util_1.util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
          const sharedValue = mergeValues(a[key], b[key]);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
      } else if (aType === util_1.ZodParsedType.array && bType === util_1.ZodParsedType.array) {
        if (a.length !== b.length) {
          return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
          const itemA = a[index];
          const itemB = b[index];
          const sharedValue = mergeValues(itemA, itemB);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
      } else if (aType === util_1.ZodParsedType.date && bType === util_1.ZodParsedType.date && +a === +b) {
        return { valid: true, data: a };
      } else {
        return { valid: false };
      }
    }
    var ZodIntersection = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight)) {
            return parseUtil_1.INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_intersection_types
            });
            return parseUtil_1.INVALID;
          }
          if ((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    exports.ZodIntersection = ZodIntersection;
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    var ZodTuple = class _ZodTuple extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.array,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return parseUtil_1.INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return parseUtil_1.ParseStatus.mergeArray(status, results);
          });
        } else {
          return parseUtil_1.ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    exports.ZodTuple = ZodTuple;
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    var ZodRecord = class _ZodRecord extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (ctx.common.async) {
          return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new _ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    exports.ZodRecord = ZodRecord;
    var ZodMap = class extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.map) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.map,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return parseUtil_1.INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return parseUtil_1.INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    exports.ZodMap = ZodMap;
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    var ZodSet = class _ZodSet extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.set) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.set,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return parseUtil_1.INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    exports.ZodSet = ZodSet;
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    var ZodFunction = class _ZodFunction extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.function) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.function,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        function makeArgsIssue(args, error) {
          return (0, parseUtil_1.makeIssue)({
            data: args,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              (0, errors_1.getErrorMap)(),
              errors_1.defaultErrorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodError_1.ZodIssueCode.invalid_arguments,
              argumentsError: error
            }
          });
        }
        function makeReturnsIssue(returns, error) {
          return (0, parseUtil_1.makeIssue)({
            data: returns,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              (0, errors_1.getErrorMap)(),
              errors_1.defaultErrorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodError_1.ZodIssueCode.invalid_return_type,
              returnTypeError: error
            }
          });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me = this;
          return (0, parseUtil_1.OK)(async function(...args) {
            const error = new ZodError_1.ZodError([]);
            const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
              error.addIssue(makeArgsIssue(args, e));
              throw error;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
              error.addIssue(makeReturnsIssue(result, e));
              throw error;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return (0, parseUtil_1.OK)(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new _ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    };
    exports.ZodFunction = ZodFunction;
    var ZodLazy = class extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    exports.ZodLazy = ZodLazy;
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    var ZodLiteral = class extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    exports.ZodLiteral = ZodLiteral;
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    function createZodEnum(values, params) {
      return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params)
      });
    }
    var ZodEnum = class _ZodEnum extends ZodType {
      constructor() {
        super(...arguments);
        _ZodEnum_cache.set(this, void 0);
      }
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          (0, parseUtil_1.addIssueToContext)(ctx, {
            expected: util_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_1.ZodIssueCode.invalid_type
          });
          return parseUtil_1.INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
          __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values, newDef = this._def) {
        return _ZodEnum.create(values, {
          ...this._def,
          ...newDef
        });
      }
      exclude(values, newDef = this._def) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
          ...this._def,
          ...newDef
        });
      }
    };
    exports.ZodEnum = ZodEnum;
    _ZodEnum_cache = /* @__PURE__ */ new WeakMap();
    ZodEnum.create = createZodEnum;
    var ZodNativeEnum = class extends ZodType {
      constructor() {
        super(...arguments);
        _ZodNativeEnum_cache.set(this, void 0);
      }
      _parse(input) {
        const nativeEnumValues = util_1.util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== util_1.ZodParsedType.string && ctx.parsedType !== util_1.ZodParsedType.number) {
          const expectedValues = util_1.util.objectValues(nativeEnumValues);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            expected: util_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_1.ZodIssueCode.invalid_type
          });
          return parseUtil_1.INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
          __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util_1.util.getValidEnumValues(this._def.values)), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
          const expectedValues = util_1.util.objectValues(nativeEnumValues);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    exports.ZodNativeEnum = ZodNativeEnum;
    _ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    var ZodPromise = class extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.promise && ctx.common.async === false) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.promise,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const promisified = ctx.parsedType === util_1.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return (0, parseUtil_1.OK)(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    exports.ZodPromise = ZodPromise;
    ZodPromise.create = (schema, params) => {
      return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    var ZodEffects = class extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: (arg) => {
            (0, parseUtil_1.addIssueToContext)(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(processed).then(async (processed2) => {
              if (status.value === "aborted")
                return parseUtil_1.INVALID;
              const result = await this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
              if (result.status === "aborted")
                return parseUtil_1.INVALID;
              if (result.status === "dirty")
                return (0, parseUtil_1.DIRTY)(result.value);
              if (status.value === "dirty")
                return (0, parseUtil_1.DIRTY)(result.value);
              return result;
            });
          } else {
            if (status.value === "aborted")
              return parseUtil_1.INVALID;
            const result = this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return parseUtil_1.INVALID;
            if (result.status === "dirty")
              return (0, parseUtil_1.DIRTY)(result.value);
            if (status.value === "dirty")
              return (0, parseUtil_1.DIRTY)(result.value);
            return result;
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return parseUtil_1.INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return parseUtil_1.INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!(0, parseUtil_1.isValid)(base))
              return base;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!(0, parseUtil_1.isValid)(base))
                return base;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
            });
          }
        }
        util_1.util.assertNever(effect);
      }
    };
    exports.ZodEffects = ZodEffects;
    exports.ZodTransformer = ZodEffects;
    ZodEffects.create = (schema, effect, params) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    var ZodOptional = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.undefined) {
          return (0, parseUtil_1.OK)(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports.ZodOptional = ZodOptional;
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    var ZodNullable = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.null) {
          return (0, parseUtil_1.OK)(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports.ZodNullable = ZodNullable;
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    var ZodDefault = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === util_1.ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    exports.ZodDefault = ZodDefault;
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    var ZodCatch = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if ((0, parseUtil_1.isAsync)(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError_1.ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError_1.ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    exports.ZodCatch = ZodCatch;
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    var ZodNaN = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.nan,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    exports.ZodNaN = ZodNaN;
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    exports.BRAND = Symbol("zod_brand");
    var ZodBranded = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    exports.ZodBranded = ZodBranded;
    var ZodPipeline = class _ZodPipeline extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return parseUtil_1.INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return (0, parseUtil_1.DIRTY)(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return parseUtil_1.INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new _ZodPipeline({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    exports.ZodPipeline = ZodPipeline;
    var ZodReadonly = class extends ZodType {
      _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data) => {
          if ((0, parseUtil_1.isValid)(data)) {
            data.value = Object.freeze(data.value);
          }
          return data;
        };
        return (0, parseUtil_1.isAsync)(result) ? result.then((data) => freeze(data)) : freeze(result);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports.ZodReadonly = ZodReadonly;
    ZodReadonly.create = (type, params) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    function custom(check, params = {}, fatal) {
      if (check)
        return ZodAny.create().superRefine((data, ctx) => {
          var _a, _b;
          if (!check(data)) {
            const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
            const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
            const p2 = typeof p === "string" ? { message: p } : p;
            ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
          }
        });
      return ZodAny.create();
    }
    exports.custom = custom;
    exports.late = {
      object: ZodObject.lazycreate
    };
    var ZodFirstPartyTypeKind;
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind = exports.ZodFirstPartyTypeKind || (exports.ZodFirstPartyTypeKind = {}));
    var instanceOfType = (cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params);
    exports.instanceof = instanceOfType;
    var stringType = ZodString.create;
    exports.string = stringType;
    var numberType = ZodNumber.create;
    exports.number = numberType;
    var nanType = ZodNaN.create;
    exports.nan = nanType;
    var bigIntType = ZodBigInt.create;
    exports.bigint = bigIntType;
    var booleanType = ZodBoolean.create;
    exports.boolean = booleanType;
    var dateType = ZodDate.create;
    exports.date = dateType;
    var symbolType = ZodSymbol.create;
    exports.symbol = symbolType;
    var undefinedType = ZodUndefined.create;
    exports.undefined = undefinedType;
    var nullType = ZodNull.create;
    exports.null = nullType;
    var anyType = ZodAny.create;
    exports.any = anyType;
    var unknownType = ZodUnknown.create;
    exports.unknown = unknownType;
    var neverType = ZodNever.create;
    exports.never = neverType;
    var voidType = ZodVoid.create;
    exports.void = voidType;
    var arrayType = ZodArray.create;
    exports.array = arrayType;
    var objectType = ZodObject.create;
    exports.object = objectType;
    var strictObjectType = ZodObject.strictCreate;
    exports.strictObject = strictObjectType;
    var unionType = ZodUnion.create;
    exports.union = unionType;
    var discriminatedUnionType = ZodDiscriminatedUnion.create;
    exports.discriminatedUnion = discriminatedUnionType;
    var intersectionType = ZodIntersection.create;
    exports.intersection = intersectionType;
    var tupleType = ZodTuple.create;
    exports.tuple = tupleType;
    var recordType = ZodRecord.create;
    exports.record = recordType;
    var mapType = ZodMap.create;
    exports.map = mapType;
    var setType = ZodSet.create;
    exports.set = setType;
    var functionType = ZodFunction.create;
    exports.function = functionType;
    var lazyType = ZodLazy.create;
    exports.lazy = lazyType;
    var literalType = ZodLiteral.create;
    exports.literal = literalType;
    var enumType = ZodEnum.create;
    exports.enum = enumType;
    var nativeEnumType = ZodNativeEnum.create;
    exports.nativeEnum = nativeEnumType;
    var promiseType = ZodPromise.create;
    exports.promise = promiseType;
    var effectsType = ZodEffects.create;
    exports.effect = effectsType;
    exports.transformer = effectsType;
    var optionalType = ZodOptional.create;
    exports.optional = optionalType;
    var nullableType = ZodNullable.create;
    exports.nullable = nullableType;
    var preprocessType = ZodEffects.createWithPreprocess;
    exports.preprocess = preprocessType;
    var pipelineType = ZodPipeline.create;
    exports.pipeline = pipelineType;
    var ostring = () => stringType().optional();
    exports.ostring = ostring;
    var onumber = () => numberType().optional();
    exports.onumber = onumber;
    var oboolean = () => booleanType().optional();
    exports.oboolean = oboolean;
    exports.coerce = {
      string: (arg) => ZodString.create({ ...arg, coerce: true }),
      number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
      boolean: (arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      }),
      bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
      date: (arg) => ZodDate.create({ ...arg, coerce: true })
    };
    exports.NEVER = parseUtil_1.INVALID;
  }
});

// node_modules/zod/lib/external.js
var require_external = __commonJS({
  "node_modules/zod/lib/external.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_errors(), exports);
    __exportStar(require_parseUtil(), exports);
    __exportStar(require_typeAliases(), exports);
    __exportStar(require_util(), exports);
    __exportStar(require_types(), exports);
    __exportStar(require_ZodError(), exports);
  }
});

// node_modules/zod/lib/index.js
var require_lib = __commonJS({
  "node_modules/zod/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.z = void 0;
    var z = __importStar(require_external());
    exports.z = z;
    __exportStar(require_external(), exports);
    exports.default = z;
  }
});

// node_modules/@ton/ton/package.json
var require_package = __commonJS({
  "node_modules/@ton/ton/package.json"(exports, module) {
    module.exports = {
      name: "@ton/ton",
      version: "13.11.1",
      repository: "https://github.com/ton-org/ton.git",
      author: "Whales Corp. <developers@whalescorp.com>",
      license: "MIT",
      main: "dist/index.js",
      files: [
        "dist"
      ],
      scripts: {
        docs: "rm -fr docs && typedoc src/index.ts",
        build: "rm -fr dist && tsc --declaration",
        test: "jest --verbose --runInBand",
        release: "yarn build && yarn release-it --npm.yarn1"
      },
      devDependencies: {
        "@release-it/keep-a-changelog": "^5.0.0",
        "@ton/core": "^0.56.0",
        "@ton/crypto": "3.2.0",
        "@ton/emulator": "^2.1.1",
        "@types/jest": "^27.0.1",
        "@types/node": "^16.7.10",
        buffer: "^6.0.3",
        expect: "^27.1.0",
        jest: "^27.1.0",
        "jest-mock": "^27.1.0",
        karma: "^6.3.4",
        "karma-chrome-launcher": "^3.1.0",
        "karma-jasmine": "^4.0.1",
        "karma-typescript": "^5.5.2",
        "karma-webpack": "^5.0.0",
        prando: "^6.0.1",
        "release-it": "^17.1.1",
        "ts-jest": "^27.0.5",
        "ts-loader": "^9.2.5",
        "ts-node": "^10.7.0",
        typedoc: "^0.23.24",
        typescript: "^4.4.2",
        webpack: "^5.51.2"
      },
      dependencies: {
        axios: "^1.6.7",
        dataloader: "^2.0.0",
        "symbol.inspect": "1.0.1",
        teslabot: "^1.3.0",
        zod: "^3.21.4"
      },
      peerDependencies: {
        "@ton/core": ">=0.56.0",
        "@ton/crypto": ">=3.2.0"
      },
      publishConfig: {
        access: "public",
        registry: "https://registry.npmjs.org/"
      },
      "release-it": {
        github: {
          release: true
        },
        plugins: {
          "@release-it/keep-a-changelog": {
            filename: "CHANGELOG.md"
          }
        }
      },
      packageManager: "yarn@3.4.1"
    };
  }
});

// node_modules/@ton/ton/dist/client/api/HttpApi.js
var require_HttpApi = __commonJS({
  "node_modules/@ton/ton/dist/client/api/HttpApi.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpApi = void 0;
    var TonCache_1 = require_TonCache();
    var dataloader_1 = __importDefault(require_dataloader());
    var axios_1 = __importDefault(require_axios());
    var zod_1 = require_lib();
    var version = require_package().version;
    var blockIdExt = zod_1.z.object({
      "@type": zod_1.z.literal("ton.blockIdExt"),
      workchain: zod_1.z.number(),
      shard: zod_1.z.string(),
      seqno: zod_1.z.number(),
      root_hash: zod_1.z.string(),
      file_hash: zod_1.z.string()
    });
    var addressInformation = zod_1.z.object({
      balance: zod_1.z.union([zod_1.z.number(), zod_1.z.string()]),
      state: zod_1.z.union([zod_1.z.literal("active"), zod_1.z.literal("uninitialized"), zod_1.z.literal("frozen")]),
      data: zod_1.z.string(),
      code: zod_1.z.string(),
      last_transaction_id: zod_1.z.object({
        "@type": zod_1.z.literal("internal.transactionId"),
        lt: zod_1.z.string(),
        hash: zod_1.z.string()
      }),
      block_id: blockIdExt,
      sync_utime: zod_1.z.number()
    });
    var bocResponse = zod_1.z.object({
      "@type": zod_1.z.literal("ok")
    });
    var feeResponse = zod_1.z.object({
      "@type": zod_1.z.literal("query.fees"),
      source_fees: zod_1.z.object({
        "@type": zod_1.z.literal("fees"),
        in_fwd_fee: zod_1.z.number(),
        storage_fee: zod_1.z.number(),
        gas_fee: zod_1.z.number(),
        fwd_fee: zod_1.z.number()
      })
    });
    var callGetMethod = zod_1.z.object({
      gas_used: zod_1.z.number(),
      exit_code: zod_1.z.number(),
      stack: zod_1.z.array(zod_1.z.unknown())
    });
    var messageData = zod_1.z.union([
      zod_1.z.object({
        "@type": zod_1.z.literal("msg.dataRaw"),
        "body": zod_1.z.string()
      }),
      zod_1.z.object({
        "@type": zod_1.z.literal("msg.dataText"),
        "text": zod_1.z.string()
      }),
      zod_1.z.object({
        "@type": zod_1.z.literal("msg.dataDecryptedText"),
        "text": zod_1.z.string()
      }),
      zod_1.z.object({
        "@type": zod_1.z.literal("msg.dataEncryptedText"),
        "text": zod_1.z.string()
      })
    ]);
    var message = zod_1.z.object({
      source: zod_1.z.string(),
      destination: zod_1.z.string(),
      value: zod_1.z.string(),
      fwd_fee: zod_1.z.string(),
      ihr_fee: zod_1.z.string(),
      created_lt: zod_1.z.string(),
      body_hash: zod_1.z.string(),
      msg_data: messageData,
      message: zod_1.z.string()
    });
    var transaction = zod_1.z.object({
      data: zod_1.z.string(),
      utime: zod_1.z.number(),
      transaction_id: zod_1.z.object({
        lt: zod_1.z.string(),
        hash: zod_1.z.string()
      }),
      fee: zod_1.z.string(),
      storage_fee: zod_1.z.string(),
      other_fee: zod_1.z.string(),
      in_msg: zod_1.z.union([zod_1.z.undefined(), message]),
      out_msgs: zod_1.z.array(message)
    });
    var getTransactions = zod_1.z.array(transaction);
    var getMasterchain = zod_1.z.object({
      state_root_hash: zod_1.z.string(),
      last: blockIdExt,
      init: blockIdExt
    });
    var getShards = zod_1.z.object({
      shards: zod_1.z.array(blockIdExt)
    });
    var blockShortTxt = zod_1.z.object({
      "@type": zod_1.z.literal("blocks.shortTxId"),
      mode: zod_1.z.number(),
      account: zod_1.z.string(),
      lt: zod_1.z.string(),
      hash: zod_1.z.string()
    });
    var getBlockTransactions = zod_1.z.object({
      id: blockIdExt,
      req_count: zod_1.z.number(),
      incomplete: zod_1.z.boolean(),
      transactions: zod_1.z.array(blockShortTxt)
    });
    var TypedCache = class {
      constructor(namespace, cache, codec, keyEncoder) {
        this.namespace = namespace;
        this.cache = cache;
        this.codec = codec;
        this.keyEncoder = keyEncoder;
      }
      async get(key) {
        let ex = await this.cache.get(this.namespace, this.keyEncoder(key));
        if (ex) {
          let decoded = this.codec.safeParse(JSON.parse(ex));
          if (decoded.success) {
            return decoded.data;
          }
        }
        return null;
      }
      async set(key, value) {
        if (value !== null) {
          await this.cache.set(this.namespace, this.keyEncoder(key), JSON.stringify(value));
        } else {
          await this.cache.set(this.namespace, this.keyEncoder(key), null);
        }
      }
    };
    var HttpApi = class {
      constructor(endpoint, parameters) {
        this.endpoint = endpoint;
        this.cache = new TonCache_1.InMemoryCache();
        this.parameters = {
          timeout: (parameters == null ? void 0 : parameters.timeout) || 3e4,
          apiKey: parameters == null ? void 0 : parameters.apiKey,
          adapter: parameters == null ? void 0 : parameters.adapter
        };
        this.shardCache = new TypedCache("ton-shard", this.cache, zod_1.z.array(blockIdExt), (src) => src + "");
        this.shardLoader = new dataloader_1.default(async (src) => {
          return await Promise.all(src.map(async (v) => {
            const cached = await this.shardCache.get(v);
            if (cached) {
              return cached;
            }
            let loaded = (await this.doCall("shards", { seqno: v }, getShards)).shards;
            await this.shardCache.set(v, loaded);
            return loaded;
          }));
        });
        this.shardTransactionsCache = new TypedCache("ton-shard-tx", this.cache, getBlockTransactions, (src) => src.workchain + ":" + src.shard + ":" + src.seqno);
        this.shardTransactionsLoader = new dataloader_1.default(async (src) => {
          return await Promise.all(src.map(async (v) => {
            const cached = await this.shardTransactionsCache.get(v);
            if (cached) {
              return cached;
            }
            let loaded = await this.doCall("getBlockTransactions", { workchain: v.workchain, seqno: v.seqno, shard: v.shard }, getBlockTransactions);
            await this.shardTransactionsCache.set(v, loaded);
            return loaded;
          }));
        }, { cacheKeyFn: (src) => src.workchain + ":" + src.shard + ":" + src.seqno });
      }
      getAddressInformation(address) {
        return this.doCall("getAddressInformation", { address: address.toString() }, addressInformation);
      }
      async getTransactions(address, opts) {
        const inclusive = opts.inclusive;
        delete opts.inclusive;
        let hash = void 0;
        if (opts.hash) {
          hash = Buffer.from(opts.hash, "base64").toString("hex");
        }
        let limit = opts.limit;
        if (opts.hash && opts.lt && inclusive !== true) {
          limit++;
        }
        let res = await this.doCall("getTransactions", { address: address.toString(), ...opts, limit, hash }, getTransactions);
        if (res.length > limit) {
          res = res.slice(0, limit);
        }
        if (opts.hash && opts.lt && inclusive !== true) {
          res.shift();
          return res;
        } else {
          return res;
        }
      }
      async getMasterchainInfo() {
        return await this.doCall("getMasterchainInfo", {}, getMasterchain);
      }
      async getShards(seqno) {
        return await this.shardLoader.load(seqno);
      }
      async getBlockTransactions(workchain, seqno, shard) {
        return await this.shardTransactionsLoader.load({ workchain, seqno, shard });
      }
      async getTransaction(address, lt, hash) {
        let convHash = Buffer.from(hash, "base64").toString("hex");
        let res = await this.doCall("getTransactions", { address: address.toString(), lt, hash: convHash, limit: 1 }, getTransactions);
        let ex = res.find((v) => v.transaction_id.lt === lt && v.transaction_id.hash === hash);
        if (ex) {
          return ex;
        } else {
          return null;
        }
      }
      async callGetMethod(address, method, stack) {
        return await this.doCall("runGetMethod", { address: address.toString(), method, stack: serializeStack(stack) }, callGetMethod);
      }
      async sendBoc(body) {
        await this.doCall("sendBoc", { boc: body.toString("base64") }, bocResponse);
      }
      async estimateFee(address, args) {
        return await this.doCall("estimateFee", {
          address: address.toString(),
          body: args.body.toBoc().toString("base64"),
          "init_data": args.initData ? args.initData.toBoc().toString("base64") : "",
          "init_code": args.initCode ? args.initCode.toBoc().toString("base64") : "",
          ignore_chksig: args.ignoreSignature
        }, feeResponse);
      }
      async tryLocateResultTx(source, destination, created_lt) {
        return await this.doCall("tryLocateResultTx", { source: source.toString(), destination: destination.toString(), created_lt }, transaction);
      }
      async tryLocateSourceTx(source, destination, created_lt) {
        return await this.doCall("tryLocateSourceTx", { source: source.toString(), destination: destination.toString(), created_lt }, transaction);
      }
      async doCall(method, body, codec) {
        let headers = {
          "Content-Type": "application/json",
          "X-Ton-Client-Version": version
        };
        if (this.parameters.apiKey) {
          headers["X-API-Key"] = this.parameters.apiKey;
        }
        let res = await axios_1.default.post(this.endpoint, JSON.stringify({
          id: "1",
          jsonrpc: "2.0",
          method,
          params: body
        }), {
          headers,
          timeout: this.parameters.timeout,
          adapter: this.parameters.adapter
        });
        if (res.status !== 200 || !res.data.ok) {
          throw Error("Received error: " + JSON.stringify(res.data));
        }
        let decoded = codec.safeParse(res.data.result);
        if (decoded.success) {
          return decoded.data;
        } else {
          throw Error("Malformed response: " + decoded.error.format()._errors.join(", "));
        }
      }
    };
    exports.HttpApi = HttpApi;
    function serializeStack(src) {
      let stack = [];
      for (let s of src) {
        if (s.type === "int") {
          stack.push(["num", s.value.toString()]);
        } else if (s.type === "cell") {
          stack.push(["tvm.Cell", s.cell.toBoc().toString("base64")]);
        } else if (s.type === "slice") {
          stack.push(["tvm.Slice", s.cell.toBoc().toString("base64")]);
        } else if (s.type === "builder") {
          stack.push(["tvm.Builder", s.cell.toBoc().toString("base64")]);
        } else {
          throw Error("Unsupported stack item type: " + s.type);
        }
      }
      return stack;
    }
  }
});

// node_modules/@ton/ton/dist/client/TonClient.js
var require_TonClient = __commonJS({
  "node_modules/@ton/ton/dist/client/TonClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TonClient = void 0;
    var HttpApi_1 = require_HttpApi();
    var core_1 = require_dist2();
    var TonClient = class {
      constructor(parameters) {
        this.parameters = {
          endpoint: parameters.endpoint
        };
        this.api = new HttpApi_1.HttpApi(this.parameters.endpoint, {
          timeout: parameters.timeout,
          apiKey: parameters.apiKey,
          adapter: parameters.httpAdapter
        });
      }
      /**
       * Get Address Balance
       * @param address address for balance check
       * @returns balance
       */
      async getBalance(address) {
        return (await this.getContractState(address)).balance;
      }
      /**
       * Invoke get method
       * @param address contract address
       * @param name name of method
       * @param params optional parameters
       * @returns stack and gas_used field
       */
      async runMethod(address, name, stack = []) {
        let res = await this.api.callGetMethod(address, name, stack);
        if (res.exit_code !== 0) {
          throw Error("Unable to execute get method. Got exit_code: " + res.exit_code);
        }
        return { gas_used: res.gas_used, stack: parseStack(res.stack) };
      }
      /**
       * Invoke get method
       * @param address contract address
       * @param name name of method
       * @param params optional parameters
       * @returns stack and gas_used field
       * @deprecated use runMethod instead
       */
      async callGetMethod(address, name, stack = []) {
        return this.runMethod(address, name, stack);
      }
      /**
       * Invoke get method that returns error code instead of throwing error
       * @param address contract address
       * @param name name of method
       * @param params optional parameters
       * @returns stack and gas_used field
      */
      async runMethodWithError(address, name, params = []) {
        let res = await this.api.callGetMethod(address, name, params);
        return { gas_used: res.gas_used, stack: parseStack(res.stack), exit_code: res.exit_code };
      }
      /**
       * Invoke get method that returns error code instead of throwing error
       * @param address contract address
       * @param name name of method
       * @param params optional parameters
       * @returns stack and gas_used field
       * @deprecated use runMethodWithError instead
       */
      async callGetMethodWithError(address, name, stack = []) {
        return this.runMethodWithError(address, name, stack);
      }
      /**
       * Get transactions
       * @param address address
       */
      async getTransactions(address, opts) {
        let tx = await this.api.getTransactions(address, opts);
        let res = [];
        for (let r of tx) {
          res.push((0, core_1.loadTransaction)(core_1.Cell.fromBoc(Buffer.from(r.data, "base64"))[0].beginParse()));
        }
        return res;
      }
      /**
       * Get transaction by it's id
       * @param address address
       * @param lt logical time
       * @param hash transaction hash
       * @returns transaction or null if not exist
       */
      async getTransaction(address, lt, hash) {
        let res = await this.api.getTransaction(address, lt, hash);
        if (res) {
          return (0, core_1.loadTransaction)(core_1.Cell.fromBoc(Buffer.from(res.data, "base64"))[0].beginParse());
        } else {
          return null;
        }
      }
      /**
       * Locate outcoming transaction of destination address by incoming message
       * @param source message source address
       * @param destination message destination address
       * @param created_lt message's created lt
       * @returns transaction
       */
      async tryLocateResultTx(source, destination, created_lt) {
        let res = await this.api.tryLocateResultTx(source, destination, created_lt);
        return (0, core_1.loadTransaction)(core_1.Cell.fromBase64(res.data).beginParse());
      }
      /**
       * Locate incoming transaction of source address by outcoming message
       * @param source message source address
       * @param destination message destination address
       * @param created_lt message's created lt
       * @returns transaction
       */
      async tryLocateSourceTx(source, destination, created_lt) {
        let res = await this.api.tryLocateSourceTx(source, destination, created_lt);
        return (0, core_1.loadTransaction)(core_1.Cell.fromBase64(res.data).beginParse());
      }
      /**
       * Fetch latest masterchain info
       * @returns masterchain info
       */
      async getMasterchainInfo() {
        let r = await this.api.getMasterchainInfo();
        return {
          workchain: r.init.workchain,
          shard: r.last.shard,
          initSeqno: r.init.seqno,
          latestSeqno: r.last.seqno
        };
      }
      /**
       * Fetch latest workchain shards
       * @param seqno masterchain seqno
       */
      async getWorkchainShards(seqno) {
        let r = await this.api.getShards(seqno);
        return r.map((m) => ({
          workchain: m.workchain,
          shard: m.shard,
          seqno: m.seqno
        }));
      }
      /**
       * Fetch transactions inf shards
       * @param workchain
       * @param seqno
       * @param shard
       */
      async getShardTransactions(workchain, seqno, shard) {
        let tx = await this.api.getBlockTransactions(workchain, seqno, shard);
        if (tx.incomplete) {
          throw Error("Unsupported");
        }
        return tx.transactions.map((v) => ({
          account: core_1.Address.parseRaw(v.account),
          lt: v.lt,
          hash: v.hash
        }));
      }
      /**
       * Send message to a network
       * @param src source message
       */
      async sendMessage(src) {
        const boc = (0, core_1.beginCell)().store((0, core_1.storeMessage)(src)).endCell().toBoc();
        await this.api.sendBoc(boc);
      }
      /**
       * Send file to a network
       * @param src source file
       */
      async sendFile(src) {
        await this.api.sendBoc(src);
      }
      /**
       * Estimate fees for external message
       * @param address target address
       * @returns
       */
      async estimateExternalMessageFee(address, args) {
        return await this.api.estimateFee(address, { body: args.body, initCode: args.initCode, initData: args.initData, ignoreSignature: args.ignoreSignature });
      }
      /**
       * Send external message to contract
       * @param contract contract to send message
       * @param src message body
       */
      async sendExternalMessage(contract, src) {
        if (await this.isContractDeployed(contract.address) || !contract.init) {
          const message = (0, core_1.external)({
            to: contract.address,
            body: src
          });
          await this.sendMessage(message);
        } else {
          const message = (0, core_1.external)({
            to: contract.address,
            init: contract.init,
            body: src
          });
          await this.sendMessage(message);
        }
      }
      /**
       * Check if contract is deployed
       * @param address addres to check
       * @returns true if contract is in active state
       */
      async isContractDeployed(address) {
        return (await this.getContractState(address)).state === "active";
      }
      /**
       * Resolves contract state
       * @param address contract address
       */
      async getContractState(address) {
        let info = await this.api.getAddressInformation(address);
        let balance = BigInt(info.balance);
        let state = info.state;
        return {
          balance,
          state,
          code: info.code !== "" ? Buffer.from(info.code, "base64") : null,
          data: info.data !== "" ? Buffer.from(info.data, "base64") : null,
          lastTransaction: info.last_transaction_id.lt !== "0" ? {
            lt: info.last_transaction_id.lt,
            hash: info.last_transaction_id.hash
          } : null,
          blockId: {
            workchain: info.block_id.workchain,
            shard: info.block_id.shard,
            seqno: info.block_id.seqno
          },
          timestampt: info.sync_utime
        };
      }
      /**
       * Open contract
       * @param src source contract
       * @returns contract
       */
      open(src) {
        return (0, core_1.openContract)(src, (args) => createProvider(this, args.address, args.init));
      }
      /**
       * Create a provider
       * @param address address
       * @param init optional init
       * @returns provider
       */
      provider(address, init) {
        return createProvider(this, address, init ?? null);
      }
    };
    exports.TonClient = TonClient;
    function parseStackEntry(s) {
      switch (s["@type"]) {
        case "tvm.stackEntryNumber":
          return { type: "int", value: BigInt(s.number.number) };
        case "tvm.stackEntryCell":
          return { type: "cell", cell: core_1.Cell.fromBase64(s.cell) };
        case "tvm.stackEntryTuple":
          return { type: "tuple", items: s.tuple.elements.map(parseStackEntry) };
        default:
          throw Error("Unsupported item type: " + s["@type"]);
      }
    }
    function parseStackItem(s) {
      if (s[0] === "num") {
        let val = s[1];
        if (val.startsWith("-")) {
          return { type: "int", value: -BigInt(val.slice(1)) };
        } else {
          return { type: "int", value: BigInt(val) };
        }
      } else if (s[0] === "null") {
        return { type: "null" };
      } else if (s[0] === "cell") {
        return { type: "cell", cell: core_1.Cell.fromBoc(Buffer.from(s[1].bytes, "base64"))[0] };
      } else if (s[0] === "slice") {
        return { type: "slice", cell: core_1.Cell.fromBoc(Buffer.from(s[1].bytes, "base64"))[0] };
      } else if (s[0] === "builder") {
        return { type: "builder", cell: core_1.Cell.fromBoc(Buffer.from(s[1].bytes, "base64"))[0] };
      } else if (s[0] === "tuple" || s[0] === "list") {
        if (s[1].elements.length === 0) {
          return { type: "null" };
        }
        return {
          type: s[0],
          items: s[1].elements.map(parseStackEntry)
        };
      } else {
        throw Error("Unsupported stack item type: " + s[0]);
      }
    }
    function parseStack(src) {
      let stack = [];
      for (let s of src) {
        stack.push(parseStackItem(s));
      }
      return new core_1.TupleReader(stack);
    }
    function createProvider(client, address, init) {
      return {
        async getState() {
          let state = await client.getContractState(address);
          let balance = state.balance;
          let last = state.lastTransaction ? { lt: BigInt(state.lastTransaction.lt), hash: Buffer.from(state.lastTransaction.hash, "base64") } : null;
          let storage;
          if (state.state === "active") {
            storage = {
              type: "active",
              code: state.code ? state.code : null,
              data: state.data ? state.data : null
            };
          } else if (state.state === "uninitialized") {
            storage = {
              type: "uninit"
            };
          } else if (state.state === "frozen") {
            storage = {
              type: "frozen",
              stateHash: Buffer.alloc(0)
            };
          } else {
            throw Error("Unsupported state");
          }
          return {
            balance,
            last,
            state: storage
          };
        },
        async get(name, args) {
          let method = await client.callGetMethod(address, name, args);
          return { stack: method.stack };
        },
        async external(message) {
          let neededInit = null;
          if (init && !await client.isContractDeployed(address)) {
            neededInit = init;
          }
          const ext = (0, core_1.external)({
            to: address,
            init: neededInit,
            body: message
          });
          let boc = (0, core_1.beginCell)().store((0, core_1.storeMessage)(ext)).endCell().toBoc();
          await client.sendFile(boc);
        },
        async internal(via, message) {
          let neededInit = null;
          if (init && !await client.isContractDeployed(address)) {
            neededInit = init;
          }
          let bounce = true;
          if (message.bounce !== null && message.bounce !== void 0) {
            bounce = message.bounce;
          }
          let value;
          if (typeof message.value === "string") {
            value = (0, core_1.toNano)(message.value);
          } else {
            value = message.value;
          }
          let body = null;
          if (typeof message.body === "string") {
            body = (0, core_1.comment)(message.body);
          } else if (message.body) {
            body = message.body;
          }
          await via.send({
            to: address,
            value,
            bounce,
            sendMode: message.sendMode,
            init: neededInit,
            body
          });
        },
        open(contract) {
          return (0, core_1.openContract)(contract, (args) => createProvider(client, args.address, args.init ?? null));
        },
        getTransactions(address2, lt, hash, limit) {
          return client.getTransactions(address2, { limit: limit ?? 100, lt: lt.toString(), hash: hash.toString("base64"), inclusive: true });
        }
      };
    }
  }
});

// node_modules/@ton/ton/dist/utils/toUrlSafe.js
var require_toUrlSafe = __commonJS({
  "node_modules/@ton/ton/dist/utils/toUrlSafe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUrlSafe = void 0;
    function toUrlSafe(src) {
      while (src.indexOf("/") >= 0) {
        src = src.replace("/", "_");
      }
      while (src.indexOf("+") >= 0) {
        src = src.replace("+", "-");
      }
      while (src.indexOf("=") >= 0) {
        src = src.replace("=", "");
      }
      return src;
    }
    exports.toUrlSafe = toUrlSafe;
  }
});

// node_modules/@ton/ton/dist/client/TonClient4.js
var require_TonClient4 = __commonJS({
  "node_modules/@ton/ton/dist/client/TonClient4.js"(exports) {
    "use strict";
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _TonClient4_endpoint;
    var _TonClient4_timeout;
    var _TonClient4_adapter;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TonClient4 = void 0;
    var axios_1 = __importDefault(require_axios());
    var core_1 = require_dist2();
    var toUrlSafe_1 = require_toUrlSafe();
    var zod_1 = require_lib();
    var TonClient4 = class {
      constructor(args) {
        _TonClient4_endpoint.set(this, void 0);
        _TonClient4_timeout.set(this, void 0);
        _TonClient4_adapter.set(this, void 0);
        __classPrivateFieldSet(this, _TonClient4_endpoint, args.endpoint, "f");
        __classPrivateFieldSet(this, _TonClient4_timeout, args.timeout || 5e3, "f");
        __classPrivateFieldSet(this, _TonClient4_adapter, args.httpAdapter, "f");
      }
      /**
       * Get Last Block
       * @returns last block info
       */
      async getLastBlock() {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/latest", { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        let lastBlock = lastBlockCodec.safeParse(res.data);
        if (!lastBlock.success) {
          throw Error("Mailformed response: " + lastBlock.error.format()._errors.join(", "));
        }
        return lastBlock.data;
      }
      /**
       * Get block info
       * @param seqno block sequence number
       * @returns block info
       */
      async getBlock(seqno) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        let block = blockCodec.safeParse(res.data);
        if (!block.success) {
          throw Error("Mailformed response");
        }
        if (!block.data.exist) {
          throw Error("Block is out of scope");
        }
        return block.data.block;
      }
      /**
       * Get block info by unix timestamp
       * @param ts unix timestamp
       * @returns block info
       */
      async getBlockByUtime(ts) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/utime/" + ts, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        let block = blockCodec.safeParse(res.data);
        if (!block.success) {
          throw Error("Mailformed response");
        }
        if (!block.data.exist) {
          throw Error("Block is out of scope");
        }
        return block.data.block;
      }
      /**
       * Get block info by unix timestamp
       * @param seqno block sequence number
       * @param address account address
       * @returns account info
       */
      async getAccount(seqno, address) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        let account = accountCodec.safeParse(res.data);
        if (!account.success) {
          throw Error("Mailformed response");
        }
        return account.data;
      }
      /**
       * Get account lite info (without code and data)
       * @param seqno block sequence number
       * @param address account address
       * @returns account lite info
       */
      async getAccountLite(seqno, address) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }) + "/lite", { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        let account = accountLiteCodec.safeParse(res.data);
        if (!account.success) {
          throw Error("Mailformed response");
        }
        return account.data;
      }
      /**
       * Check if contract is deployed
       * @param address addres to check
       * @returns true if contract is in active state
       */
      async isContractDeployed(seqno, address) {
        let account = await this.getAccountLite(seqno, address);
        return account.account.state.type === "active";
      }
      /**
       * Check if account was updated since
       * @param seqno block sequence number
       * @param address account address
       * @param lt account last transaction lt
       * @returns account change info
       */
      async isAccountChanged(seqno, address, lt) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }) + "/changed/" + lt.toString(10), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        let changed = changedCodec.safeParse(res.data);
        if (!changed.success) {
          throw Error("Mailformed response");
        }
        return changed.data;
      }
      /**
       * Load unparsed account transactions
       * @param address address
       * @param lt last transaction lt
       * @param hash last transaction hash
       * @returns unparsed transactions
       */
      async getAccountTransactions(address, lt, hash) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/account/" + address.toString({ urlSafe: true }) + "/tx/" + lt.toString(10) + "/" + (0, toUrlSafe_1.toUrlSafe)(hash.toString("base64")), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        let transactions = transactionsCodec.safeParse(res.data);
        if (!transactions.success) {
          throw Error("Mailformed response");
        }
        let data = transactions.data;
        let tx = [];
        let cells = core_1.Cell.fromBoc(Buffer.from(data.boc, "base64"));
        for (let i = 0; i < data.blocks.length; i++) {
          tx.push({
            block: data.blocks[i],
            tx: (0, core_1.loadTransaction)(cells[i].beginParse())
          });
        }
        return tx;
      }
      /**
       * Load parsed account transactions
       * @param address address
       * @param lt last transaction lt
       * @param hash last transaction hash
       * @param count number of transactions to load
       * @returns parsed transactions
       */
      async getAccountTransactionsParsed(address, lt, hash, count = 20) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/account/" + address.toString({ urlSafe: true }) + "/tx/parsed/" + lt.toString(10) + "/" + (0, toUrlSafe_1.toUrlSafe)(hash.toString("base64")), {
          adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
          timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f"),
          params: {
            count
          }
        });
        let parsedTransactionsRes = parsedTransactionsCodec.safeParse(res.data);
        if (!parsedTransactionsRes.success) {
          throw Error("Mailformed response");
        }
        return parsedTransactionsRes.data;
      }
      /**
       * Get network config
       * @param seqno block sequence number
       * @param ids optional config ids
       * @returns network config
       */
      async getConfig(seqno, ids) {
        let tail = "";
        if (ids && ids.length > 0) {
          tail = "/" + [...ids].sort().join(",");
        }
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/config" + tail, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        let config = configCodec.safeParse(res.data);
        if (!config.success) {
          throw Error("Mailformed response");
        }
        return config.data;
      }
      /**
       * Execute run method
       * @param seqno block sequence number
       * @param address account address
       * @param name method name
       * @param args method arguments
       * @returns method result
       */
      async runMethod(seqno, address, name, args) {
        let tail = args && args.length > 0 ? "/" + (0, toUrlSafe_1.toUrlSafe)((0, core_1.serializeTuple)(args).toBoc({ idx: false, crc32: false }).toString("base64")) : "";
        let url = __classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }) + "/run/" + encodeURIComponent(name) + tail;
        let res = await axios_1.default.get(url, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        let runMethod = runMethodCodec.safeParse(res.data);
        if (!runMethod.success) {
          throw Error("Mailformed response");
        }
        let resultTuple = runMethod.data.resultRaw ? (0, core_1.parseTuple)(core_1.Cell.fromBoc(Buffer.from(runMethod.data.resultRaw, "base64"))[0]) : [];
        return {
          exitCode: runMethod.data.exitCode,
          result: resultTuple,
          resultRaw: runMethod.data.resultRaw,
          block: runMethod.data.block,
          shardBlock: runMethod.data.shardBlock,
          reader: new core_1.TupleReader(resultTuple)
        };
      }
      /**
       * Send external message
       * @param message message boc
       * @returns message status
       */
      async sendMessage(message) {
        let res = await axios_1.default.post(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/send", { boc: message.toString("base64") }, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        let send = sendCodec.safeParse(res.data);
        if (!send.success) {
          throw Error("Mailformed response");
        }
        return { status: res.data.status };
      }
      /**
       * Open smart contract
       * @param contract contract
       * @returns opened contract
       */
      open(contract) {
        return (0, core_1.openContract)(contract, (args) => createProvider(this, null, args.address, args.init));
      }
      /**
       * Open smart contract
       * @param block block number
       * @param contract contract
       * @returns opened contract
       */
      openAt(block, contract) {
        return (0, core_1.openContract)(contract, (args) => createProvider(this, block, args.address, args.init));
      }
      /**
       * Create provider
       * @param address address
       * @param init optional init data
       * @returns provider
       */
      provider(address, init) {
        return createProvider(this, null, address, init ?? null);
      }
      /**
       * Create provider at specified block number
       * @param block block number
       * @param address address
       * @param init optional init data
       * @returns provider
       */
      providerAt(block, address, init) {
        return createProvider(this, block, address, init ?? null);
      }
    };
    exports.TonClient4 = TonClient4;
    _TonClient4_endpoint = /* @__PURE__ */ new WeakMap(), _TonClient4_timeout = /* @__PURE__ */ new WeakMap(), _TonClient4_adapter = /* @__PURE__ */ new WeakMap();
    function createProvider(client, block, address, init) {
      return {
        async getState() {
          let sq = block;
          if (sq === null) {
            let res = await client.getLastBlock();
            sq = res.last.seqno;
          }
          let state = await client.getAccount(sq, address);
          let last = state.account.last ? { lt: BigInt(state.account.last.lt), hash: Buffer.from(state.account.last.hash, "base64") } : null;
          let storage;
          if (state.account.state.type === "active") {
            storage = {
              type: "active",
              code: state.account.state.code ? Buffer.from(state.account.state.code, "base64") : null,
              data: state.account.state.data ? Buffer.from(state.account.state.data, "base64") : null
            };
          } else if (state.account.state.type === "uninit") {
            storage = {
              type: "uninit"
            };
          } else if (state.account.state.type === "frozen") {
            storage = {
              type: "frozen",
              stateHash: Buffer.from(state.account.state.stateHash, "base64")
            };
          } else {
            throw Error("Unsupported state");
          }
          return {
            balance: BigInt(state.account.balance.coins),
            last,
            state: storage
          };
        },
        async get(name, args) {
          let sq = block;
          if (sq === null) {
            let res = await client.getLastBlock();
            sq = res.last.seqno;
          }
          let method = await client.runMethod(sq, address, name, args);
          if (method.exitCode !== 0 && method.exitCode !== 1) {
            throw Error("Exit code: " + method.exitCode);
          }
          return {
            stack: new core_1.TupleReader(method.result)
          };
        },
        async external(message) {
          let last = await client.getLastBlock();
          let neededInit = null;
          if (init && (await client.getAccountLite(last.last.seqno, address)).account.state.type !== "active") {
            neededInit = init;
          }
          const ext = (0, core_1.external)({
            to: address,
            init: neededInit,
            body: message
          });
          let pkg = (0, core_1.beginCell)().store((0, core_1.storeMessage)(ext)).endCell().toBoc();
          await client.sendMessage(pkg);
        },
        async internal(via, message) {
          let last = await client.getLastBlock();
          let neededInit = null;
          if (init && (await client.getAccountLite(last.last.seqno, address)).account.state.type !== "active") {
            neededInit = init;
          }
          let bounce = true;
          if (message.bounce !== null && message.bounce !== void 0) {
            bounce = message.bounce;
          }
          let value;
          if (typeof message.value === "string") {
            value = (0, core_1.toNano)(message.value);
          } else {
            value = message.value;
          }
          let body = null;
          if (typeof message.body === "string") {
            body = (0, core_1.comment)(message.body);
          } else if (message.body) {
            body = message.body;
          }
          await via.send({
            to: address,
            value,
            bounce,
            sendMode: message.sendMode,
            init: neededInit,
            body
          });
        },
        open(contract) {
          return (0, core_1.openContract)(contract, (args) => createProvider(client, block, args.address, args.init ?? null));
        },
        async getTransactions(address2, lt, hash, limit) {
          const useLimit = typeof limit === "number";
          if (useLimit && limit <= 0) {
            return [];
          }
          let transactions = [];
          do {
            const txs = await client.getAccountTransactions(address2, lt, hash);
            const firstTx = txs[0].tx;
            const [firstLt, firstHash] = [firstTx.lt, firstTx.hash()];
            const needSkipFirst = transactions.length > 0 && firstLt === lt && firstHash.equals(hash);
            if (needSkipFirst) {
              txs.shift();
            }
            if (txs.length === 0) {
              break;
            }
            const lastTx = txs[txs.length - 1].tx;
            const [lastLt, lastHash] = [lastTx.lt, lastTx.hash()];
            if (lastLt === lt && lastHash.equals(hash)) {
              break;
            }
            transactions.push(...txs.map((tx) => tx.tx));
            lt = lastLt;
            hash = lastHash;
          } while (useLimit && transactions.length < limit);
          if (useLimit) {
            transactions = transactions.slice(0, limit);
          }
          return transactions;
        }
      };
    }
    var lastBlockCodec = zod_1.z.object({
      last: zod_1.z.object({
        seqno: zod_1.z.number(),
        shard: zod_1.z.string(),
        workchain: zod_1.z.number(),
        fileHash: zod_1.z.string(),
        rootHash: zod_1.z.string()
      }),
      init: zod_1.z.object({
        fileHash: zod_1.z.string(),
        rootHash: zod_1.z.string()
      }),
      stateRootHash: zod_1.z.string(),
      now: zod_1.z.number()
    });
    var blockCodec = zod_1.z.union([zod_1.z.object({
      exist: zod_1.z.literal(false)
    }), zod_1.z.object({
      exist: zod_1.z.literal(true),
      block: zod_1.z.object({
        shards: zod_1.z.array(zod_1.z.object({
          workchain: zod_1.z.number(),
          seqno: zod_1.z.number(),
          shard: zod_1.z.string(),
          rootHash: zod_1.z.string(),
          fileHash: zod_1.z.string(),
          transactions: zod_1.z.array(zod_1.z.object({
            account: zod_1.z.string(),
            hash: zod_1.z.string(),
            lt: zod_1.z.string()
          }))
        }))
      })
    })]);
    var storageStatCodec = zod_1.z.object({
      lastPaid: zod_1.z.number(),
      duePayment: zod_1.z.union([zod_1.z.null(), zod_1.z.string()]),
      used: zod_1.z.object({
        bits: zod_1.z.number(),
        cells: zod_1.z.number(),
        publicCells: zod_1.z.number()
      })
    });
    var accountCodec = zod_1.z.object({
      account: zod_1.z.object({
        state: zod_1.z.union([
          zod_1.z.object({ type: zod_1.z.literal("uninit") }),
          zod_1.z.object({ type: zod_1.z.literal("active"), code: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]), data: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]) }),
          zod_1.z.object({ type: zod_1.z.literal("frozen"), stateHash: zod_1.z.string() })
        ]),
        balance: zod_1.z.object({
          coins: zod_1.z.string()
        }),
        last: zod_1.z.union([
          zod_1.z.null(),
          zod_1.z.object({
            lt: zod_1.z.string(),
            hash: zod_1.z.string()
          })
        ]),
        storageStat: zod_1.z.union([zod_1.z.null(), storageStatCodec])
      }),
      block: zod_1.z.object({
        workchain: zod_1.z.number(),
        seqno: zod_1.z.number(),
        shard: zod_1.z.string(),
        rootHash: zod_1.z.string(),
        fileHash: zod_1.z.string()
      })
    });
    var accountLiteCodec = zod_1.z.object({
      account: zod_1.z.object({
        state: zod_1.z.union([
          zod_1.z.object({ type: zod_1.z.literal("uninit") }),
          zod_1.z.object({ type: zod_1.z.literal("active"), codeHash: zod_1.z.string(), dataHash: zod_1.z.string() }),
          zod_1.z.object({ type: zod_1.z.literal("frozen"), stateHash: zod_1.z.string() })
        ]),
        balance: zod_1.z.object({
          coins: zod_1.z.string()
        }),
        last: zod_1.z.union([
          zod_1.z.null(),
          zod_1.z.object({
            lt: zod_1.z.string(),
            hash: zod_1.z.string()
          })
        ]),
        storageStat: zod_1.z.union([zod_1.z.null(), storageStatCodec])
      })
    });
    var changedCodec = zod_1.z.object({
      changed: zod_1.z.boolean(),
      block: zod_1.z.object({
        workchain: zod_1.z.number(),
        seqno: zod_1.z.number(),
        shard: zod_1.z.string(),
        rootHash: zod_1.z.string(),
        fileHash: zod_1.z.string()
      })
    });
    var runMethodCodec = zod_1.z.object({
      exitCode: zod_1.z.number(),
      resultRaw: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
      block: zod_1.z.object({
        workchain: zod_1.z.number(),
        seqno: zod_1.z.number(),
        shard: zod_1.z.string(),
        rootHash: zod_1.z.string(),
        fileHash: zod_1.z.string()
      }),
      shardBlock: zod_1.z.object({
        workchain: zod_1.z.number(),
        seqno: zod_1.z.number(),
        shard: zod_1.z.string(),
        rootHash: zod_1.z.string(),
        fileHash: zod_1.z.string()
      })
    });
    var configCodec = zod_1.z.object({
      config: zod_1.z.object({
        cell: zod_1.z.string(),
        address: zod_1.z.string(),
        globalBalance: zod_1.z.object({
          coins: zod_1.z.string()
        })
      })
    });
    var sendCodec = zod_1.z.object({
      status: zod_1.z.number()
    });
    var blocksCodec = zod_1.z.array(zod_1.z.object({
      workchain: zod_1.z.number(),
      seqno: zod_1.z.number(),
      shard: zod_1.z.string(),
      rootHash: zod_1.z.string(),
      fileHash: zod_1.z.string()
    }));
    var transactionsCodec = zod_1.z.object({
      blocks: blocksCodec,
      boc: zod_1.z.string()
    });
    var parsedAddressExternalCodec = zod_1.z.object({
      bits: zod_1.z.number(),
      data: zod_1.z.string()
    });
    var parsedMessageInfoCodec = zod_1.z.union([
      zod_1.z.object({
        type: zod_1.z.literal("internal"),
        value: zod_1.z.string(),
        dest: zod_1.z.string(),
        src: zod_1.z.string(),
        bounced: zod_1.z.boolean(),
        bounce: zod_1.z.boolean(),
        ihrDisabled: zod_1.z.boolean(),
        createdAt: zod_1.z.number(),
        createdLt: zod_1.z.string(),
        fwdFee: zod_1.z.string(),
        ihrFee: zod_1.z.string()
      }),
      zod_1.z.object({
        type: zod_1.z.literal("external-in"),
        dest: zod_1.z.string(),
        src: zod_1.z.union([parsedAddressExternalCodec, zod_1.z.null()]),
        importFee: zod_1.z.string()
      }),
      zod_1.z.object({
        type: zod_1.z.literal("external-out"),
        dest: zod_1.z.union([parsedAddressExternalCodec, zod_1.z.null()])
      })
    ]);
    var parsedStateInitCodec = zod_1.z.object({
      splitDepth: zod_1.z.union([zod_1.z.number(), zod_1.z.null()]),
      code: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
      data: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
      special: zod_1.z.union([zod_1.z.object({ tick: zod_1.z.boolean(), tock: zod_1.z.boolean() }), zod_1.z.null()])
    });
    var parsedMessageCodec = zod_1.z.object({
      body: zod_1.z.string(),
      info: parsedMessageInfoCodec,
      init: zod_1.z.union([parsedStateInitCodec, zod_1.z.null()])
    });
    var accountStatusCodec = zod_1.z.union([zod_1.z.literal("uninitialized"), zod_1.z.literal("frozen"), zod_1.z.literal("active"), zod_1.z.literal("non-existing")]);
    var txBodyCodec = zod_1.z.union([
      zod_1.z.object({ type: zod_1.z.literal("comment"), comment: zod_1.z.string() }),
      zod_1.z.object({ type: zod_1.z.literal("payload"), cell: zod_1.z.string() })
    ]);
    var parsedOperationItemCodec = zod_1.z.union([
      zod_1.z.object({ kind: zod_1.z.literal("ton"), amount: zod_1.z.string() }),
      zod_1.z.object({ kind: zod_1.z.literal("token"), amount: zod_1.z.string() })
    ]);
    var supportedMessageTypeCodec = zod_1.z.union([
      zod_1.z.literal("jetton::excesses"),
      zod_1.z.literal("jetton::transfer"),
      zod_1.z.literal("jetton::transfer_notification"),
      zod_1.z.literal("deposit"),
      zod_1.z.literal("deposit::ok"),
      zod_1.z.literal("withdraw"),
      zod_1.z.literal("withdraw::all"),
      zod_1.z.literal("withdraw::delayed"),
      zod_1.z.literal("withdraw::ok"),
      zod_1.z.literal("airdrop")
    ]);
    var opCodec = zod_1.z.object({
      type: supportedMessageTypeCodec,
      options: zod_1.z.optional(zod_1.z.record(zod_1.z.string()))
    });
    var parsedOperationCodec = zod_1.z.object({
      address: zod_1.z.string(),
      comment: zod_1.z.optional(zod_1.z.string()),
      items: zod_1.z.array(parsedOperationItemCodec),
      op: zod_1.z.optional(opCodec)
    });
    var parsedTransactionCodec = zod_1.z.object({
      address: zod_1.z.string(),
      lt: zod_1.z.string(),
      hash: zod_1.z.string(),
      prevTransaction: zod_1.z.object({
        lt: zod_1.z.string(),
        hash: zod_1.z.string()
      }),
      time: zod_1.z.number(),
      outMessagesCount: zod_1.z.number(),
      oldStatus: accountStatusCodec,
      newStatus: accountStatusCodec,
      fees: zod_1.z.string(),
      update: zod_1.z.object({
        oldHash: zod_1.z.string(),
        newHash: zod_1.z.string()
      }),
      inMessage: zod_1.z.union([parsedMessageCodec, zod_1.z.null()]),
      outMessages: zod_1.z.array(parsedMessageCodec),
      parsed: zod_1.z.object({
        seqno: zod_1.z.union([zod_1.z.number(), zod_1.z.null()]),
        body: zod_1.z.union([txBodyCodec, zod_1.z.null()]),
        status: zod_1.z.union([zod_1.z.literal("success"), zod_1.z.literal("failed"), zod_1.z.literal("pending")]),
        dest: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
        kind: zod_1.z.union([zod_1.z.literal("out"), zod_1.z.literal("in")]),
        amount: zod_1.z.string(),
        resolvedAddress: zod_1.z.string(),
        bounced: zod_1.z.boolean(),
        mentioned: zod_1.z.array(zod_1.z.string())
      }),
      operation: parsedOperationCodec
    });
    var parsedTransactionsCodec = zod_1.z.object({
      blocks: blocksCodec,
      transactions: zod_1.z.array(parsedTransactionCodec)
    });
  }
});

// node_modules/@ton/ton/dist/wallets/signing/createWalletTransfer.js
var require_createWalletTransfer = __commonJS({
  "node_modules/@ton/ton/dist/wallets/signing/createWalletTransfer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createWalletTransferV4 = exports.createWalletTransferV3 = exports.createWalletTransferV2 = exports.createWalletTransferV1 = void 0;
    var core_1 = require_dist2();
    var crypto_1 = require_dist();
    function createWalletTransferV1(args) {
      let signingMessage = (0, core_1.beginCell)().storeUint(args.seqno, 32);
      if (args.message) {
        signingMessage.storeUint(args.sendMode, 8);
        signingMessage.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(args.message)));
      }
      let signature = (0, crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
      const body = (0, core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
      return body;
    }
    exports.createWalletTransferV1 = createWalletTransferV1;
    function createWalletTransferV2(args) {
      if (args.messages.length > 4) {
        throw Error("Maximum number of messages in a single transfer is 4");
      }
      let signingMessage = (0, core_1.beginCell)().storeUint(args.seqno, 32);
      if (args.seqno === 0) {
        for (let i = 0; i < 32; i++) {
          signingMessage.storeBit(1);
        }
      } else {
        signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
      }
      for (let m of args.messages) {
        signingMessage.storeUint(args.sendMode, 8);
        signingMessage.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(m)));
      }
      let signature = (0, crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
      const body = (0, core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
      return body;
    }
    exports.createWalletTransferV2 = createWalletTransferV2;
    function createWalletTransferV3(args) {
      if (args.messages.length > 4) {
        throw Error("Maximum number of messages in a single transfer is 4");
      }
      let signingMessage = (0, core_1.beginCell)().storeUint(args.walletId, 32);
      if (args.seqno === 0) {
        for (let i = 0; i < 32; i++) {
          signingMessage.storeBit(1);
        }
      } else {
        signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
      }
      signingMessage.storeUint(args.seqno, 32);
      for (let m of args.messages) {
        signingMessage.storeUint(args.sendMode, 8);
        signingMessage.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(m)));
      }
      let signature = (0, crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
      const body = (0, core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
      return body;
    }
    exports.createWalletTransferV3 = createWalletTransferV3;
    function createWalletTransferV4(args) {
      if (args.messages.length > 4) {
        throw Error("Maximum number of messages in a single transfer is 4");
      }
      let signingMessage = (0, core_1.beginCell)().storeUint(args.walletId, 32);
      if (args.seqno === 0) {
        for (let i = 0; i < 32; i++) {
          signingMessage.storeBit(1);
        }
      } else {
        signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
      }
      signingMessage.storeUint(args.seqno, 32);
      signingMessage.storeUint(0, 8);
      for (let m of args.messages) {
        signingMessage.storeUint(args.sendMode, 8);
        signingMessage.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(m)));
      }
      let signature = (0, crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
      const body = (0, core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
      return body;
    }
    exports.createWalletTransferV4 = createWalletTransferV4;
  }
});

// node_modules/@ton/ton/dist/wallets/WalletContractV1R1.js
var require_WalletContractV1R1 = __commonJS({
  "node_modules/@ton/ton/dist/wallets/WalletContractV1R1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV1R1 = void 0;
    var core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV1R1 = class _WalletContractV1R1 {
      static create(args) {
        return new _WalletContractV1R1(args.workchain, args.publicKey);
      }
      constructor(workchain, publicKey) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEARAAAhP8AIN2k8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVEH98Ik=", "base64"))[0];
        let data = (0, core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
        this.init = { code, data };
        this.address = (0, core_1.contractAddress)(workchain, { code, data });
      }
      /**
       * Get Wallet Balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          return core_1.Cell.fromBoc(state.state.data)[0].beginParse().loadUint(32);
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create signed transfer
       */
      createTransfer(args) {
        let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV1)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          message: args.message
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              message: (0, core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV1R1 = WalletContractV1R1;
  }
});

// node_modules/@ton/ton/dist/wallets/WalletContractV1R2.js
var require_WalletContractV1R2 = __commonJS({
  "node_modules/@ton/ton/dist/wallets/WalletContractV1R2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV1R2 = void 0;
    var core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV1R2 = class _WalletContractV1R2 {
      static create(args) {
        return new _WalletContractV1R2(args.workchain, args.publicKey);
      }
      constructor(workchain, publicKey) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEAUwAAov8AIN0gggFMl7qXMO1E0NcLH+Ck8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVNDieG8=", "base64"))[0];
        let data = (0, core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
        this.init = { code, data };
        this.address = (0, core_1.contractAddress)(workchain, { code, data });
      }
      /**
       * Get Wallet Balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          let res = await provider.get("seqno", []);
          return res.stack.readNumber();
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create signed transfer
       */
      createTransfer(args) {
        let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV1)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          message: args.message
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              message: (0, core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV1R2 = WalletContractV1R2;
  }
});

// node_modules/@ton/ton/dist/wallets/WalletContractV1R3.js
var require_WalletContractV1R3 = __commonJS({
  "node_modules/@ton/ton/dist/wallets/WalletContractV1R3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV1R3 = void 0;
    var core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV1R3 = class _WalletContractV1R3 {
      static create(args) {
        return new _WalletContractV1R3(args.workchain, args.publicKey);
      }
      constructor(workchain, publicKey) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEAXwAAuv8AIN0gggFMl7ohggEznLqxnHGw7UTQ0x/XC//jBOCk8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVLW4bkI=", "base64"))[0];
        let data = (0, core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
        this.init = { code, data };
        this.address = (0, core_1.contractAddress)(workchain, { code, data });
      }
      /**
       * Get Wallet Balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          let res = await provider.get("seqno", []);
          return res.stack.readNumber();
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(executor, message) {
        await executor.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create signed transfer
       */
      createTransfer(args) {
        let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV1)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          message: args.message
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              message: (0, core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV1R3 = WalletContractV1R3;
  }
});

// node_modules/@ton/ton/dist/wallets/WalletContractV2R1.js
var require_WalletContractV2R1 = __commonJS({
  "node_modules/@ton/ton/dist/wallets/WalletContractV2R1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV2R1 = void 0;
    var core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV2R1 = class _WalletContractV2R1 {
      static create(args) {
        return new _WalletContractV2R1(args.workchain, args.publicKey);
      }
      constructor(workchain, publicKey) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEAVwAAqv8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x8B+CO78mPtRNDTH9P/0VExuvKhA/kBVBBC+RDyovgAApMg10qW0wfUAvsA6NGkyMsfy//J7VShNwu2", "base64"))[0];
        let data = (0, core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
        this.init = { code, data };
        this.address = (0, core_1.contractAddress)(workchain, { code, data });
      }
      /**
       * Get Wallet Balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          let res = await provider.get("seqno", []);
          return res.stack.readNumber();
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create signed transfer
       */
      createTransfer(args) {
        let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV2)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          messages: args.messages,
          timeout: args.timeout
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              messages: [(0, core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })]
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV2R1 = WalletContractV2R1;
  }
});

// node_modules/@ton/ton/dist/wallets/WalletContractV2R2.js
var require_WalletContractV2R2 = __commonJS({
  "node_modules/@ton/ton/dist/wallets/WalletContractV2R2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV2R2 = void 0;
    var core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV2R2 = class _WalletContractV2R2 {
      static create(args) {
        return new _WalletContractV2R2(args.workchain, args.publicKey);
      }
      constructor(workchain, publicKey) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEAYwAAwv8AIN0gggFMl7ohggEznLqxnHGw7UTQ0x/XC//jBOCk8mCDCNcYINMf0x8B+CO78mPtRNDTH9P/0VExuvKhA/kBVBBC+RDyovgAApMg10qW0wfUAvsA6NGkyMsfy//J7VQETNeh", "base64"))[0];
        let data = (0, core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
        this.init = { code, data };
        this.address = (0, core_1.contractAddress)(workchain, { code, data });
      }
      /**
       * Get Wallet Balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          let res = await provider.get("seqno", []);
          return res.stack.readNumber();
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create signed transfer
       */
      createTransfer(args) {
        let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV2)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          messages: args.messages,
          timeout: args.timeout
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              messages: [(0, core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })]
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV2R2 = WalletContractV2R2;
  }
});

// node_modules/@ton/ton/dist/wallets/WalletContractV3R1.js
var require_WalletContractV3R1 = __commonJS({
  "node_modules/@ton/ton/dist/wallets/WalletContractV3R1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV3R1 = void 0;
    var core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV3R1 = class _WalletContractV3R1 {
      static create(args) {
        return new _WalletContractV3R1(args.workchain, args.publicKey, args.walletId);
      }
      constructor(workchain, publicKey, walletId) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        if (walletId !== null && walletId !== void 0) {
          this.walletId = walletId;
        } else {
          this.walletId = 698983191 + workchain;
        }
        let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEAYgAAwP8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVD++buA=", "base64"))[0];
        let data = (0, core_1.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(publicKey).endCell();
        this.init = { code, data };
        this.address = (0, core_1.contractAddress)(workchain, { code, data });
      }
      /**
       * Get wallet balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          let res = await provider.get("seqno", []);
          return res.stack.readNumber();
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create transfer
       */
      createTransfer(args) {
        let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV3)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          messages: args.messages,
          timeout: args.timeout,
          walletId: this.walletId
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              messages: [(0, core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })]
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV3R1 = WalletContractV3R1;
  }
});

// node_modules/@ton/ton/dist/wallets/WalletContractV3R2.js
var require_WalletContractV3R2 = __commonJS({
  "node_modules/@ton/ton/dist/wallets/WalletContractV3R2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV3R2 = void 0;
    var core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV3R2 = class _WalletContractV3R2 {
      static create(args) {
        return new _WalletContractV3R2(args.workchain, args.publicKey, args.walletId);
      }
      constructor(workchain, publicKey, walletId) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        if (walletId !== null && walletId !== void 0) {
          this.walletId = walletId;
        } else {
          this.walletId = 698983191 + workchain;
        }
        let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEAcQAA3v8AIN0gggFMl7ohggEznLqxn3Gw7UTQ0x/THzHXC//jBOCk8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVBC9ba0=", "base64"))[0];
        let data = (0, core_1.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(publicKey).endCell();
        this.init = { code, data };
        this.address = (0, core_1.contractAddress)(workchain, { code, data });
      }
      /**
       * Get wallet balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          let res = await provider.get("seqno", []);
          return res.stack.readNumber();
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create transfer
       */
      createTransfer(args) {
        let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV3)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          messages: args.messages,
          timeout: args.timeout,
          walletId: this.walletId
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              messages: [(0, core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })]
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV3R2 = WalletContractV3R2;
  }
});

// node_modules/@ton/ton/dist/wallets/WalletContractV4.js
var require_WalletContractV4 = __commonJS({
  "node_modules/@ton/ton/dist/wallets/WalletContractV4.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContractV4 = void 0;
    var core_1 = require_dist2();
    var createWalletTransfer_1 = require_createWalletTransfer();
    var WalletContractV4 = class _WalletContractV4 {
      static create(args) {
        return new _WalletContractV4(args.workchain, args.publicKey, args.walletId);
      }
      constructor(workchain, publicKey, walletId) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        if (walletId !== null && walletId !== void 0) {
          this.walletId = walletId;
        } else {
          this.walletId = 698983191 + workchain;
        }
        let code = core_1.Cell.fromBoc(Buffer.from("te6ccgECFAEAAtQAART/APSkE/S88sgLAQIBIAIDAgFIBAUE+PKDCNcYINMf0x/THwL4I7vyZO1E0NMf0x/T//QE0VFDuvKhUVG68qIF+QFUEGT5EPKj+AAkpMjLH1JAyx9SMMv/UhD0AMntVPgPAdMHIcAAn2xRkyDXSpbTB9QC+wDoMOAhwAHjACHAAuMAAcADkTDjDQOkyMsfEssfy/8QERITAubQAdDTAyFxsJJfBOAi10nBIJJfBOAC0x8hghBwbHVnvSKCEGRzdHK9sJJfBeAD+kAwIPpEAcjKB8v/ydDtRNCBAUDXIfQEMFyBAQj0Cm+hMbOSXwfgBdM/yCWCEHBsdWe6kjgw4w0DghBkc3RyupJfBuMNBgcCASAICQB4AfoA9AQw+CdvIjBQCqEhvvLgUIIQcGx1Z4MesXCAGFAEywUmzxZY+gIZ9ADLaRfLH1Jgyz8gyYBA+wAGAIpQBIEBCPRZMO1E0IEBQNcgyAHPFvQAye1UAXKwjiOCEGRzdHKDHrFwgBhQBcsFUAPPFiP6AhPLassfyz/JgED7AJJfA+ICASAKCwBZvSQrb2omhAgKBrkPoCGEcNQICEekk30pkQzmkD6f+YN4EoAbeBAUiYcVnzGEAgFYDA0AEbjJftRNDXCx+AA9sp37UTQgQFA1yH0BDACyMoHy//J0AGBAQj0Cm+hMYAIBIA4PABmtznaiaEAga5Drhf/AABmvHfaiaEAQa5DrhY/AAG7SB/oA1NQi+QAFyMoHFcv/ydB3dIAYyMsFywIizxZQBfoCFMtrEszMyXP7AMhAFIEBCPRR8qcCAHCBAQjXGPoA0z/IVCBHgQEI9FHyp4IQbm90ZXB0gBjIywXLAlAGzxZQBPoCFMtqEssfyz/Jc/sAAgBsgQEI1xj6ANM/MFIkgQEI9Fnyp4IQZHN0cnB0gBjIywXLAlAFzxZQA/oCE8tqyx8Syz/Jc/sAAAr0AMntVA==", "base64"))[0];
        let data = (0, core_1.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(this.publicKey).storeBit(0).endCell();
        this.init = { code, data };
        this.address = (0, core_1.contractAddress)(workchain, { code, data });
      }
      /**
       * Get Wallet Balance
       */
      async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
      }
      /**
       * Get Wallet Seqno
       */
      async getSeqno(provider) {
        let state = await provider.getState();
        if (state.state.type === "active") {
          let res = await provider.get("seqno", []);
          return res.stack.readNumber();
        } else {
          return 0;
        }
      }
      /**
       * Send signed transfer
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send transfer
       */
      async sendTransfer(provider, args) {
        let transfer = this.createTransfer(args);
        await this.send(provider, transfer);
      }
      /**
       * Create signed transfer
       */
      createTransfer(args) {
        let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        return (0, createWalletTransfer_1.createWalletTransferV4)({
          seqno: args.seqno,
          sendMode,
          secretKey: args.secretKey,
          messages: args.messages,
          timeout: args.timeout,
          walletId: this.walletId
        });
      }
      /**
       * Create sender
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            let seqno = await this.getSeqno(provider);
            let transfer = this.createTransfer({
              seqno,
              secretKey,
              sendMode: args.sendMode,
              messages: [(0, core_1.internal)({
                to: args.to,
                value: args.value,
                init: args.init,
                body: args.body,
                bounce: args.bounce
              })]
            });
            await this.send(provider, transfer);
          }
        };
      }
    };
    exports.WalletContractV4 = WalletContractV4;
  }
});

// node_modules/@ton/ton/dist/jetton/JettonMaster.js
var require_JettonMaster = __commonJS({
  "node_modules/@ton/ton/dist/jetton/JettonMaster.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JettonMaster = void 0;
    var core_1 = require_dist2();
    var JettonMaster = class _JettonMaster {
      static create(address) {
        return new _JettonMaster(address);
      }
      constructor(address) {
        this.address = address;
      }
      async getWalletAddress(provider, owner) {
        let res = await provider.get("get_wallet_address", [{ type: "slice", cell: (0, core_1.beginCell)().storeAddress(owner).endCell() }]);
        return res.stack.readAddress();
      }
      async getJettonData(provider) {
        let res = await provider.get("get_jetton_data", []);
        let totalSupply = res.stack.readBigNumber();
        let mintable = res.stack.readBoolean();
        let adminAddress = res.stack.readAddress();
        let content = res.stack.readCell();
        let walletCode = res.stack.readCell();
        return {
          totalSupply,
          mintable,
          adminAddress,
          content,
          walletCode
        };
      }
    };
    exports.JettonMaster = JettonMaster;
  }
});

// node_modules/@ton/ton/dist/jetton/JettonWallet.js
var require_JettonWallet = __commonJS({
  "node_modules/@ton/ton/dist/jetton/JettonWallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JettonWallet = void 0;
    var JettonWallet = class _JettonWallet {
      static create(address) {
        return new _JettonWallet(address);
      }
      constructor(address) {
        this.address = address;
      }
      async getBalance(provider) {
        let state = await provider.getState();
        if (state.state.type !== "active") {
          return 0n;
        }
        let res = await provider.get("get_wallet_data", []);
        return res.stack.readBigNumber();
      }
    };
    exports.JettonWallet = JettonWallet;
  }
});

// node_modules/@ton/ton/dist/multisig/MultisigOrder.js
var require_MultisigOrder = __commonJS({
  "node_modules/@ton/ton/dist/multisig/MultisigOrder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultisigOrder = void 0;
    var crypto_1 = require_dist();
    var core_1 = require_dist2();
    var MultisigOrder = class _MultisigOrder {
      constructor(payload) {
        this.signatures = {};
        this.payload = payload;
      }
      static fromCell(cell) {
        var _a;
        let s = cell.beginParse();
        let signatures = (_a = s.loadMaybeRef()) == null ? void 0 : _a.beginParse();
        const messagesCell = s.asCell();
        let order = new _MultisigOrder(messagesCell);
        if (signatures) {
          while (signatures.remainingBits > 0) {
            const signature = signatures.loadBuffer(64);
            const ownerId = signatures.loadUint(8);
            order.signatures[ownerId] = signature;
            if (signatures.remainingRefs > 0) {
              signatures = signatures.loadRef().asSlice();
            } else {
              signatures.skip(1);
            }
          }
          signatures.endParse();
        }
        return order;
      }
      static fromPayload(payload) {
        return new _MultisigOrder(payload);
      }
      addSignature(ownerId, signature, multisig) {
        const signingHash = this.payload.hash();
        if (!(0, crypto_1.signVerify)(signingHash, signature, multisig.owners.get(ownerId).slice(0, -1))) {
          throw Error("invalid signature");
        }
        this.signatures[ownerId] = signature;
      }
      sign(ownerId, secretKey) {
        const signingHash = this.payload.hash();
        this.signatures[ownerId] = (0, crypto_1.sign)(signingHash, secretKey);
        return signingHash;
      }
      unionSignatures(other) {
        this.signatures = Object.assign({}, this.signatures, other.signatures);
      }
      clearSignatures() {
        this.signatures = {};
      }
      toCell(ownerId) {
        let b = (0, core_1.beginCell)().storeBit(0);
        for (const ownerId2 in this.signatures) {
          const signature = this.signatures[ownerId2];
          b = (0, core_1.beginCell)().storeBit(1).storeRef((0, core_1.beginCell)().storeBuffer(signature).storeUint(parseInt(ownerId2), 8).storeBuilder(b).endCell());
        }
        return (0, core_1.beginCell)().storeUint(ownerId, 8).storeBuilder(b).storeBuilder(this.payload.asBuilder()).endCell();
      }
    };
    exports.MultisigOrder = MultisigOrder;
  }
});

// node_modules/@ton/ton/dist/multisig/MultisigOrderBuilder.js
var require_MultisigOrderBuilder = __commonJS({
  "node_modules/@ton/ton/dist/multisig/MultisigOrderBuilder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultisigOrderBuilder = void 0;
    var core_1 = require_dist2();
    var MultisigOrder_1 = require_MultisigOrder();
    var MultisigOrderBuilder = class {
      constructor(walletId, offset) {
        this.messages = (0, core_1.beginCell)();
        this.queryId = 0n;
        this.walletId = walletId;
        this.queryOffset = offset || 7200;
      }
      addMessage(message, mode) {
        if (this.messages.refs >= 4) {
          throw Error("only 4 refs are allowed");
        }
        this.updateQueryId();
        this.messages.storeUint(mode, 8);
        this.messages.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(message)).endCell());
      }
      clearMessages() {
        this.messages = (0, core_1.beginCell)();
      }
      build() {
        return MultisigOrder_1.MultisigOrder.fromPayload((0, core_1.beginCell)().storeUint(this.walletId, 32).storeUint(this.queryId, 64).storeBuilder(this.messages).endCell());
      }
      updateQueryId() {
        const time = BigInt(Math.floor(Date.now() / 1e3 + this.queryOffset));
        this.queryId = time << 32n;
      }
    };
    exports.MultisigOrderBuilder = MultisigOrderBuilder;
  }
});

// node_modules/@ton/ton/dist/multisig/MultisigWallet.js
var require_MultisigWallet = __commonJS({
  "node_modules/@ton/ton/dist/multisig/MultisigWallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultisigWallet = void 0;
    var crypto_1 = require_dist();
    var core_1 = require_dist2();
    var MULTISIG_CODE = core_1.Cell.fromBase64("te6ccgECKwEABBgAART/APSkE/S88sgLAQIBIAIDAgFIBAUE2vIgxwCOgzDbPOCDCNcYIPkBAdMH2zwiwAAToVNxePQOb6Hyn9s8VBq6+RDyoAb0BCD5AQHTH1EYuvKq0z9wUwHwCgHCCAGDCryx8mhTFYBA9A5voSCYDqQgwgryZw7f+COqH1NAufJhVCOjU04gIyEiAgLMBgcCASAMDQIBIAgJAgFmCgsAA9GEAiPymAvHoHN9CYbZ5S7Z4BPHohwhJQAtAKkItdJEqCTItdKlwLUAdAT8ArobBKAATwhbpEx4CBukTDgAdAg10rDAJrUAvALyFjPFszJ4HHXI8gBzxb0AMmACASAODwIBIBQVARW77ZbVA0cFUg2zyCoCAUgQEQIBIBITAXOxHXQgwjXGCD5AQHTB4IB1MTtQ9hTIHj0Dm+h8p/XC/9eMfkQ8qCuAfQEIW6TW3Ey4PkBWNs8AaQBgJwA9rtqA6ADoAPoCAXoCEfyAgPyA3XlP+AXkegAA54tkwAAXrhlXP8EA1WZ2oexAAgEgFhcCASAYGQFRtyVbZ4YmRmpGEAgegc30McJNhFpAADMaYeYuAFrgJhwLb+4cC3d0bhAjAYm1WZtnhqvgb+2xxsoicAgej430pBHEoFpAADHDhBACGuQkuuBk9kUWE5kAOeLKhACQCB6IYFImHFImHFImXEA2YlzNijAjAgEgGhsAF7UGtc4QQDVZnah7EAIBIBwdAgOZOB4fARGsGm2eL4G2CUAjABWt+UEAzJV2oewYQAENqTbPBVfBYCMAFa3f3CCAarM7UPYgAiDbPALyZfgAUENxQxPbPO1UIyoACtP/0wcwBKDbPC+uUyCw8mISsQKkJbNTHLmwJYEA4aojoCi8sPJpggGGoPgBBZcCERACPj4wjo0REB/bPEDXePRDEL0F4lQWW1Rz51YQU9zbPFRxClR6vCQlKCYAIO1E0NMf0wfTB9M/9AT0BNEAXgGOGjDSAAHyo9MH0wdQA9cBIPkBBfkBFbrypFAD4GwhIddKqgIi10m68qtwVCATAAwByMv/ywcE1ts87VT4D3AlblOJvrGYEG4QLVDHXwePGzBUJANQTds8UFWgRlAQSRA6SwlTuds8UFQWf+L4AAeDJaGOLCaAQPSWb6UglDBTA7neII4WODk5CNIAAZfTBzAW8AcFkTDifwgHBZJsMeKz5jAGKicoKQBgcI4pA9CDCNcY0wf0BDBTFnj0Dm+h8qXXC/9URUT5EPKmrlIgsVIDvRShI27mbCIyAH5SML6OIF8D+ACTItdKmALTB9QC+wAC6DJwyMoAQBSAQPRDAvAHjhdxyMsAFMsHEssHWM8BWM8WQBOAQPRDAeIBII6KEEUQNEMA2zztVJJfBuIqABzIyx/LB8sHyz/0APQAyQ==");
    var MultisigWallet = class _MultisigWallet {
      constructor(publicKeys, workchain, walletId, k, opts) {
        this.provider = null;
        this.owners = core_1.Dictionary.empty();
        this.workchain = workchain;
        this.walletId = walletId;
        this.k = k;
        for (let i = 0; i < publicKeys.length; i += 1) {
          this.owners.set(i, Buffer.concat([publicKeys[i], Buffer.alloc(1)]));
        }
        this.init = {
          code: MULTISIG_CODE,
          data: (0, core_1.beginCell)().storeUint(this.walletId, 32).storeUint(this.owners.size, 8).storeUint(this.k, 8).storeUint(0, 64).storeDict(this.owners, core_1.Dictionary.Keys.Uint(8), core_1.Dictionary.Values.Buffer(33)).storeBit(0).endCell()
        };
        this.address = (opts == null ? void 0 : opts.address) || (0, core_1.contractAddress)(workchain, this.init);
        if (opts == null ? void 0 : opts.provider) {
          this.provider = opts.provider;
        } else if (opts == null ? void 0 : opts.client) {
          this.provider = opts.client.provider(this.address, {
            code: this.init.code,
            data: this.init.data
          });
        }
      }
      static async fromAddress(address, opts) {
        let provider;
        if (opts.provider) {
          provider = opts.provider;
        } else {
          if (!opts.client) {
            throw Error("Either provider or client must be specified");
          }
          provider = opts.client.provider(address, {
            code: null,
            data: null
          });
        }
        const contractState = (await provider.getState()).state;
        if (contractState.type !== "active") {
          throw Error("Contract must be active");
        }
        const data = core_1.Cell.fromBoc(contractState.data)[0].beginParse();
        const walletId = data.loadUint(32);
        data.skip(8);
        const k = data.loadUint(8);
        data.skip(64);
        const owners = data.loadDict(core_1.Dictionary.Keys.Uint(8), core_1.Dictionary.Values.Buffer(33));
        let publicKeys = [];
        for (const [key, value] of owners) {
          const publicKey = value.subarray(0, 32);
          publicKeys.push(publicKey);
        }
        return new _MultisigWallet(publicKeys, address.workChain, walletId, k, {
          address,
          provider,
          client: opts.client
        });
      }
      async deployExternal(provider) {
        if (!provider && !this.provider) {
          throw Error("you must specify provider if there is no such property in MultisigWallet instance");
        }
        if (!provider) {
          provider = this.provider;
        }
        await provider.external(core_1.Cell.EMPTY);
      }
      async deployInternal(sender, value = 1000000000n) {
        await sender.send({
          sendMode: 3,
          to: this.address,
          value,
          init: this.init,
          body: core_1.Cell.EMPTY,
          bounce: true
        });
      }
      async sendOrder(order, secretKey, provider) {
        if (!provider && !this.provider) {
          throw Error("you must specify provider if there is no such property in MultisigWallet instance");
        }
        if (!provider) {
          provider = this.provider;
        }
        let publicKey = (0, crypto_1.keyPairFromSecretKey)(secretKey).publicKey;
        let ownerId = this.getOwnerIdByPubkey(publicKey);
        let cell = order.toCell(ownerId);
        let signature = (0, crypto_1.sign)(cell.hash(), secretKey);
        cell = (0, core_1.beginCell)().storeBuffer(signature).storeSlice(cell.asSlice()).endCell();
        await provider.external(cell);
      }
      async sendOrderWithoutSecretKey(order, signature, ownerId, provider) {
        if (!provider && !this.provider) {
          throw Error("you must specify provider if there is no such property in MultisigWallet instance");
        }
        if (!provider) {
          provider = this.provider;
        }
        let cell = order.toCell(ownerId);
        cell = (0, core_1.beginCell)().storeBuffer(signature).storeSlice(cell.asSlice()).endCell();
        await provider.external(cell);
      }
      getOwnerIdByPubkey(publicKey) {
        for (const [key, value] of this.owners) {
          if (value.subarray(0, 32).equals(publicKey)) {
            return key;
          }
        }
        throw Error("public key is not an owner");
      }
    };
    exports.MultisigWallet = MultisigWallet;
  }
});

// node_modules/@ton/ton/dist/elector/ElectorContract.js
var require_ElectorContract = __commonJS({
  "node_modules/@ton/ton/dist/elector/ElectorContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ElectorContract = void 0;
    var core_1 = require_dist2();
    var FrozenDictValue = {
      serialize(src, builder) {
        throw Error("not implemented");
      },
      parse(src) {
        const address = new core_1.Address(-1, src.loadBuffer(32));
        const weight = src.loadUintBig(64);
        const stake = src.loadCoins();
        return { address, weight, stake };
      }
    };
    var EntitiesDictValue = {
      serialize(src, builder) {
        throw Error("not implemented");
      },
      parse(src) {
        const stake = src.loadCoins();
        src.skip(64);
        const address = new core_1.Address(-1, src.loadBuffer(32));
        const adnl = src.loadBuffer(32);
        return { stake, address, adnl };
      }
    };
    var ElectorContract = class _ElectorContract {
      //readonly source: ContractSource = new UnknownContractSource('org.ton.elector', -1, 'Elector Contract');
      static create() {
        return new _ElectorContract();
      }
      constructor() {
        this.address = core_1.Address.parseRaw("-1:3333333333333333333333333333333333333333333333333333333333333333");
      }
      async getReturnedStake(provider, address) {
        if (address.workChain !== -1) {
          throw Error("Only masterchain addresses could have stake");
        }
        const res = await provider.get("compute_returned_stake", [{ type: "int", value: BigInt("0x" + address.hash.toString("hex")) }]);
        return res.stack.readBigNumber();
      }
      async getPastElectionsList(provider) {
        const res = await provider.get("past_elections_list", []);
        const electionsListRaw = new core_1.TupleReader(res.stack.readLispList());
        const elections = [];
        while (electionsListRaw.remaining > 0) {
          const electionsListEntry = electionsListRaw.readTuple();
          const id = electionsListEntry.readNumber();
          const unfreezeAt = electionsListEntry.readNumber();
          electionsListEntry.pop();
          const stakeHeld = electionsListEntry.readNumber();
          elections.push({ id, unfreezeAt, stakeHeld });
        }
        return elections;
      }
      async getPastElections(provider) {
        const res = await provider.get("past_elections", []);
        const electionsRaw = new core_1.TupleReader(res.stack.readLispList());
        const elections = [];
        while (electionsRaw.remaining > 0) {
          const electionsEntry = electionsRaw.readTuple();
          const id = electionsEntry.readNumber();
          const unfreezeAt = electionsEntry.readNumber();
          const stakeHeld = electionsEntry.readNumber();
          electionsEntry.pop();
          const frozenDict = electionsEntry.readCell();
          const totalStake = electionsEntry.readBigNumber();
          const bonuses = electionsEntry.readBigNumber();
          let frozen = /* @__PURE__ */ new Map();
          const frozenData = frozenDict.beginParse().loadDictDirect(core_1.Dictionary.Keys.Buffer(32), FrozenDictValue);
          for (const [key, value] of frozenData) {
            frozen.set(BigInt("0x" + key.toString("hex")).toString(10), { address: value["address"], weight: value["weight"], stake: value["stake"] });
          }
          elections.push({ id, unfreezeAt, stakeHeld, totalStake, bonuses, frozen });
        }
        return elections;
      }
      async getElectionEntities(provider) {
        const account = await provider.getState();
        if (account.state.type !== "active") {
          throw Error("Unexpected error");
        }
        const cell = core_1.Cell.fromBoc(account.state.data)[0];
        const cs = cell.beginParse();
        if (!cs.loadBit()) {
          return null;
        }
        const sc = cs.loadRef().beginParse();
        const startWorkTime = sc.loadUint(32);
        const endElectionsTime = sc.loadUint(32);
        const minStake = sc.loadCoins();
        const allStakes = sc.loadCoins();
        const entitiesData = sc.loadDict(core_1.Dictionary.Keys.Buffer(32), EntitiesDictValue);
        let entities = [];
        if (entitiesData) {
          for (const [key, value] of entitiesData) {
            entities.push({ pubkey: key, stake: value["stake"], address: value["address"], adnl: value["adnl"] });
          }
        }
        return { minStake, allStakes, endElectionsTime, startWorkTime, entities };
      }
      // possible code for fetching data via get method if it is possible to set gas limit by request
      // async getElectionEntities(block: number) {
      //     const res = await this.client.runMethod(block, this.address, 'participant_list_extended');
      //     if (res.exitCode !== 0 && res.exitCode !== 1) {
      //         throw Error('Exit code: ' + res.exitCode);
      //     }
      //     let tuple = new TupleReader(res.result);
      //     const startWorkTime = tuple.readNumber();
      //     const endElectionsTime = tuple.readNumber();
      //     const minStake = tuple.readBigNumber();
      //     const allStakes = tuple.readBigNumber();
      //     let entriesTuple = tuple.readTuple();
      //     const entriesRaw = new TupleReader(entriesTuple.readLispList());
      //     let entities: { pubkey: Buffer, stake: bigint, address: Address, adnl: Buffer }[] = [];
      //     while (entriesRaw.remaining > 0) {
      //         const electionsEntry = entriesRaw.readTuple();
      //         const pubkey = electionsEntry.readBuffer();
      //         const stake = electionsEntry.readBigNumber();
      //         const address = electionsEntry.readAddress();
      //         const adnl = electionsEntry.readBuffer();
      //         entities.push({ pubkey, stake, address, adnl });
      //     }
      //     return { minStake, allStakes, endElectionsTime, startWorkTime, entities };
      // }
      async getActiveElectionId(provider) {
        const res = await provider.get("active_election_id", []);
        const electionId = res.stack.readNumber();
        return electionId > 0 ? electionId : null;
      }
      async getComplaints(provider, electionId) {
        const b = new core_1.TupleBuilder();
        b.writeNumber(electionId);
        const res = await provider.get("list_complaints", b.build());
        if (res.stack.peek().type === "null") {
          return [];
        }
        const complaintsRaw = new core_1.TupleReader(res.stack.readLispList());
        const results = [];
        while (complaintsRaw.remaining > 0) {
          const complaintsEntry = complaintsRaw.readTuple();
          const id = complaintsEntry.readBigNumber();
          const completeUnpackedComplaint = complaintsEntry.readTuple();
          const unpackedComplaints = completeUnpackedComplaint.readTuple();
          const publicKey = Buffer.from(unpackedComplaints.readBigNumber().toString(16), "hex");
          const description = unpackedComplaints.readCell();
          const createdAt = unpackedComplaints.readNumber();
          const severity = unpackedComplaints.readNumber();
          const rewardAddress = new core_1.Address(-1, Buffer.from(unpackedComplaints.readBigNumber().toString(16), "hex"));
          const paid = unpackedComplaints.readBigNumber();
          const suggestedFine = unpackedComplaints.readBigNumber();
          const suggestedFinePart = unpackedComplaints.readBigNumber();
          const votes = [];
          const votersListRaw = new core_1.TupleReader(completeUnpackedComplaint.readLispList());
          while (votersListRaw.remaining > 0) {
            votes.push(votersListRaw.readNumber());
          }
          const vsetId = completeUnpackedComplaint.readBigNumber();
          const remainingWeight = completeUnpackedComplaint.readBigNumber();
          results.push({
            id,
            publicKey,
            createdAt,
            severity,
            paid,
            suggestedFine,
            suggestedFinePart,
            rewardAddress,
            votes,
            remainingWeight,
            vsetId
          });
        }
        return results;
      }
    };
    exports.ElectorContract = ElectorContract;
  }
});

// node_modules/@ton/ton/dist/config/ConfigParser.js
var require_ConfigParser = __commonJS({
  "node_modules/@ton/ton/dist/config/ConfigParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseFullConfig = exports.loadConfigParamsAsSlice = exports.loadConfigParamById = exports.parseVotingSetup = exports.parseProposalSetup = exports.configParse29 = exports.configParse28 = exports.configParseMsgPrices = exports.configParseGasLimitsPrices = exports.configParseBridge = exports.configParseValidatorSet = exports.configParse12 = exports.configParseWorkchainDescriptor = exports.configParse40 = exports.configParse8 = exports.configParse18 = exports.configParse17 = exports.configParse16 = exports.configParse15 = exports.configParse13 = exports.configParse5 = exports.configParseMasterAddressRequired = exports.parseBridge = exports.parseValidatorSet = exports.configParseMasterAddress = void 0;
    var core_1 = require_dist2();
    function configParseMasterAddress(slice) {
      if (slice) {
        return new core_1.Address(-1, slice.loadBuffer(32));
      } else {
        return null;
      }
    }
    exports.configParseMasterAddress = configParseMasterAddress;
    function readPublicKey(slice) {
      if (slice.loadUint(32) !== 2390828938) {
        throw Error("Invalid config");
      }
      return slice.loadBuffer(32);
    }
    var ValidatorDescriptionDictValue = {
      serialize(src, builder) {
        throw Error("not implemented");
      },
      parse(src) {
        const header = src.loadUint(8);
        if (header === 83) {
          return {
            publicKey: readPublicKey(src),
            weight: src.loadUintBig(64),
            adnlAddress: null
          };
        } else if (header === 115) {
          return {
            publicKey: readPublicKey(src),
            weight: src.loadUintBig(64),
            adnlAddress: src.loadBuffer(32)
          };
        } else {
          throw Error("Invalid config");
        }
      }
    };
    function parseValidatorSet(slice) {
      const header = slice.loadUint(8);
      if (header === 17) {
        const timeSince = slice.loadUint(32);
        const timeUntil = slice.loadUint(32);
        const total = slice.loadUint(16);
        const main = slice.loadUint(16);
        const list = slice.loadDictDirect(core_1.Dictionary.Keys.Uint(16), ValidatorDescriptionDictValue);
        return {
          timeSince,
          timeUntil,
          total,
          main,
          totalWeight: null,
          list
        };
      } else if (header === 18) {
        const timeSince = slice.loadUint(32);
        const timeUntil = slice.loadUint(32);
        const total = slice.loadUint(16);
        const main = slice.loadUint(16);
        const totalWeight = slice.loadUintBig(64);
        const list = slice.loadDict(core_1.Dictionary.Keys.Uint(16), ValidatorDescriptionDictValue);
        return {
          timeSince,
          timeUntil,
          total,
          main,
          totalWeight,
          list
        };
      }
    }
    exports.parseValidatorSet = parseValidatorSet;
    function parseBridge(slice) {
      const bridgeAddress = new core_1.Address(-1, slice.loadBuffer(32));
      const oracleMultisigAddress = new core_1.Address(-1, slice.loadBuffer(32));
      const oraclesDict = slice.loadDict(core_1.Dictionary.Keys.Buffer(32), core_1.Dictionary.Values.Buffer(32));
      const oracles = /* @__PURE__ */ new Map();
      for (const [local, remote] of oraclesDict) {
        oracles.set(new core_1.Address(-1, local).toString(), remote);
      }
      const externalChainAddress = slice.loadBuffer(32);
      return {
        bridgeAddress,
        oracleMultisigAddress,
        oracles,
        externalChainAddress
      };
    }
    exports.parseBridge = parseBridge;
    function configParseMasterAddressRequired(slice) {
      if (!slice) {
        throw Error("Invalid config");
      }
      return configParseMasterAddress(slice);
    }
    exports.configParseMasterAddressRequired = configParseMasterAddressRequired;
    function configParse5(slice) {
      if (!slice) {
        throw Error("Invalid config");
      }
      const magic = slice.loadUint(8);
      if (magic === 1) {
        const blackholeAddr = slice.loadBit() ? new core_1.Address(-1, slice.loadBuffer(32)) : null;
        const feeBurnNominator = slice.loadUint(32);
        const feeBurnDenominator = slice.loadUint(32);
        return {
          blackholeAddr,
          feeBurnNominator,
          feeBurnDenominator
        };
      }
      throw new Error("Invalid config");
    }
    exports.configParse5 = configParse5;
    function configParse13(slice) {
      if (!slice) {
        throw Error("Invalid config");
      }
      const magic = slice.loadUint(8);
      if (magic === 26) {
        const deposit = slice.loadCoins();
        const bitPrice = slice.loadCoins();
        const cellPrice = slice.loadCoins();
        return {
          deposit,
          bitPrice,
          cellPrice
        };
      }
      throw new Error("Invalid config");
    }
    exports.configParse13 = configParse13;
    function configParse15(slice) {
      if (!slice) {
        throw Error("Invalid config");
      }
      const validatorsElectedFor = slice.loadUint(32);
      const electorsStartBefore = slice.loadUint(32);
      const electorsEndBefore = slice.loadUint(32);
      const stakeHeldFor = slice.loadUint(32);
      return {
        validatorsElectedFor,
        electorsStartBefore,
        electorsEndBefore,
        stakeHeldFor
      };
    }
    exports.configParse15 = configParse15;
    function configParse16(slice) {
      if (!slice) {
        throw Error("Invalid config");
      }
      const maxValidators = slice.loadUint(16);
      const maxMainValidators = slice.loadUint(16);
      const minValidators = slice.loadUint(16);
      return {
        maxValidators,
        maxMainValidators,
        minValidators
      };
    }
    exports.configParse16 = configParse16;
    function configParse17(slice) {
      if (!slice) {
        throw Error("Invalid config");
      }
      const minStake = slice.loadCoins();
      const maxStake = slice.loadCoins();
      const minTotalStake = slice.loadCoins();
      const maxStakeFactor = slice.loadUint(32);
      return {
        minStake,
        maxStake,
        minTotalStake,
        maxStakeFactor
      };
    }
    exports.configParse17 = configParse17;
    var StoragePricesDictValue = {
      serialize(src, builder) {
        throw Error("not implemented");
      },
      parse(src) {
        const header = src.loadUint(8);
        if (header !== 204) {
          throw Error("Invalid config");
        }
        const utime_since = src.loadUint(32);
        const bit_price_ps = src.loadUintBig(64);
        const cell_price_ps = src.loadUintBig(64);
        const mc_bit_price_ps = src.loadUintBig(64);
        const mc_cell_price_ps = src.loadUintBig(64);
        return {
          utime_since,
          bit_price_ps,
          cell_price_ps,
          mc_bit_price_ps,
          mc_cell_price_ps
        };
      }
    };
    function configParse18(slice) {
      if (!slice) {
        throw Error("Invalid config");
      }
      return slice.loadDictDirect(core_1.Dictionary.Keys.Buffer(4), StoragePricesDictValue).values();
    }
    exports.configParse18 = configParse18;
    function configParse8(slice) {
      if (!slice) {
        return {
          version: 0,
          capabilities: 0n
        };
      }
      const version = slice.loadUint(32);
      const capabilities = slice.loadUintBig(64);
      return {
        version,
        capabilities
      };
    }
    exports.configParse8 = configParse8;
    function configParse40(slice) {
      if (!slice) {
        return null;
      }
      const header = slice.loadUint(8);
      if (header !== 1) {
        throw Error("Invalid config");
      }
      const defaultFlatFine = slice.loadCoins();
      const defaultProportionaFine = slice.loadCoins();
      const severityFlatMult = slice.loadUint(16);
      const severityProportionalMult = slice.loadUint(16);
      const unfunishableInterval = slice.loadUint(16);
      const longInterval = slice.loadUint(16);
      const longFlatMult = slice.loadUint(16);
      const longProportionalMult = slice.loadUint(16);
      const mediumInterval = slice.loadUint(16);
      const mediumFlatMult = slice.loadUint(16);
      const mediumProportionalMult = slice.loadUint(16);
      return {
        defaultFlatFine,
        defaultProportionaFine,
        severityFlatMult,
        severityProportionalMult,
        unfunishableInterval,
        longInterval,
        longFlatMult,
        longProportionalMult,
        mediumInterval,
        mediumFlatMult,
        mediumProportionalMult
      };
    }
    exports.configParse40 = configParse40;
    function configParseWorkchainDescriptor(slice) {
      if (slice.loadUint(8) !== 166) {
        throw Error("Invalid config");
      }
      const enabledSince = slice.loadUint(32);
      const actialMinSplit = slice.loadUint(8);
      const min_split = slice.loadUint(8);
      const max_split = slice.loadUint(8);
      const basic = slice.loadBit();
      const active = slice.loadBit();
      const accept_msgs = slice.loadBit();
      const flags = slice.loadUint(13);
      const zerostateRootHash = slice.loadBuffer(32);
      const zerostateFileHash = slice.loadBuffer(32);
      const version = slice.loadUint(32);
      if (slice.loadBit()) {
        throw Error("Invalid config");
      }
      const vmVersion = slice.loadUint(32);
      const vmMode = slice.loadUintBig(64);
      return {
        enabledSince,
        actialMinSplit,
        min_split,
        max_split,
        basic,
        active,
        accept_msgs,
        flags,
        zerostateRootHash,
        zerostateFileHash,
        version,
        format: {
          vmVersion,
          vmMode
        }
      };
    }
    exports.configParseWorkchainDescriptor = configParseWorkchainDescriptor;
    var WorkchainDescriptorDictValue = {
      serialize(src, builder) {
        throw Error("not implemented");
      },
      parse(src) {
        if (src.loadUint(8) !== 166) {
          throw Error("Invalid config");
        }
        const enabledSince = src.loadUint(32);
        const actialMinSplit = src.loadUint(8);
        const min_split = src.loadUint(8);
        const max_split = src.loadUint(8);
        const basic = src.loadBit();
        const active = src.loadBit();
        const accept_msgs = src.loadBit();
        const flags = src.loadUint(13);
        const zerostateRootHash = src.loadBuffer(32);
        const zerostateFileHash = src.loadBuffer(32);
        const version = src.loadUint(32);
        if (src.loadBit()) {
          throw Error("Invalid config");
        }
        const vmVersion = src.loadUint(32);
        const vmMode = src.loadUintBig(64);
        return {
          enabledSince,
          actialMinSplit,
          min_split,
          max_split,
          basic,
          active,
          accept_msgs,
          flags,
          zerostateRootHash,
          zerostateFileHash,
          version,
          format: {
            vmVersion,
            vmMode
          }
        };
      }
    };
    function configParse12(slice) {
      if (!slice) {
        throw Error("Invalid config");
      }
      const wd = slice.loadDict(core_1.Dictionary.Keys.Uint(32), WorkchainDescriptorDictValue);
      if (wd) {
        return wd;
      }
      throw Error("No workchains exist");
    }
    exports.configParse12 = configParse12;
    function configParseValidatorSet(slice) {
      if (!slice) {
        return null;
      }
      return parseValidatorSet(slice);
    }
    exports.configParseValidatorSet = configParseValidatorSet;
    function configParseBridge(slice) {
      if (!slice) {
        return null;
      }
      return parseBridge(slice);
    }
    exports.configParseBridge = configParseBridge;
    function parseGasLimitsInternal(slice) {
      const tag = slice.loadUint(8);
      if (tag === 222) {
        const gasPrice = slice.loadUintBig(64);
        const gasLimit = slice.loadUintBig(64);
        const specialGasLimit = slice.loadUintBig(64);
        const gasCredit = slice.loadUintBig(64);
        const blockGasLimit = slice.loadUintBig(64);
        const freezeDueLimit = slice.loadUintBig(64);
        const deleteDueLimit = slice.loadUintBig(64);
        return {
          gasPrice,
          gasLimit,
          specialGasLimit,
          gasCredit,
          blockGasLimit,
          freezeDueLimit,
          deleteDueLimit
        };
      } else if (tag === 221) {
        const gasPrice = slice.loadUintBig(64);
        const gasLimit = slice.loadUintBig(64);
        const gasCredit = slice.loadUintBig(64);
        const blockGasLimit = slice.loadUintBig(64);
        const freezeDueLimit = slice.loadUintBig(64);
        const deleteDueLimit = slice.loadUintBig(64);
        return {
          gasPrice,
          gasLimit,
          gasCredit,
          blockGasLimit,
          freezeDueLimit,
          deleteDueLimit
        };
      } else {
        throw Error("Invalid config");
      }
    }
    function configParseGasLimitsPrices(slice) {
      if (!slice) {
        throw Error("Invalid config");
      }
      const tag = slice.loadUint(8);
      if (tag === 209) {
        const flatLimit = slice.loadUintBig(64);
        const flatGasPrice = slice.loadUintBig(64);
        const other = parseGasLimitsInternal(slice);
        return {
          flatLimit,
          flatGasPrice,
          other
        };
      } else {
        throw Error("Invalid config");
      }
    }
    exports.configParseGasLimitsPrices = configParseGasLimitsPrices;
    function configParseMsgPrices(slice) {
      if (!slice) {
        throw new Error("Invalid config");
      }
      const magic = slice.loadUint(8);
      if (magic !== 234) {
        throw new Error("Invalid msg prices param");
      }
      return {
        lumpPrice: slice.loadUintBig(64),
        bitPrice: slice.loadUintBig(64),
        cellPrice: slice.loadUintBig(64),
        ihrPriceFactor: slice.loadUint(32),
        firstFrac: slice.loadUint(16),
        nextFrac: slice.loadUint(16)
      };
    }
    exports.configParseMsgPrices = configParseMsgPrices;
    function configParse28(slice) {
      if (!slice) {
        throw new Error("Invalid config");
      }
      const magic = slice.loadUint(8);
      if (magic === 193) {
        const masterCatchainLifetime = slice.loadUint(32);
        const shardCatchainLifetime = slice.loadUint(32);
        const shardValidatorsLifetime = slice.loadUint(32);
        const shardValidatorsCount = slice.loadUint(32);
        return {
          masterCatchainLifetime,
          shardCatchainLifetime,
          shardValidatorsLifetime,
          shardValidatorsCount
        };
      }
      if (magic === 194) {
        const flags = slice.loadUint(7);
        const suffleMasterValidators = slice.loadBit();
        const masterCatchainLifetime = slice.loadUint(32);
        const shardCatchainLifetime = slice.loadUint(32);
        const shardValidatorsLifetime = slice.loadUint(32);
        const shardValidatorsCount = slice.loadUint(32);
        return {
          flags,
          suffleMasterValidators,
          masterCatchainLifetime,
          shardCatchainLifetime,
          shardValidatorsLifetime,
          shardValidatorsCount
        };
      }
      throw new Error("Invalid config");
    }
    exports.configParse28 = configParse28;
    function configParse29(slice) {
      if (!slice) {
        throw new Error("Invalid config");
      }
      const magic = slice.loadUint(8);
      if (magic === 214) {
        const roundCandidates = slice.loadUint(32);
        const nextCandidateDelay = slice.loadUint(32);
        const consensusTimeout = slice.loadUint(32);
        const fastAttempts = slice.loadUint(32);
        const attemptDuration = slice.loadUint(32);
        const catchainMaxDeps = slice.loadUint(32);
        const maxBlockBytes = slice.loadUint(32);
        const maxColaltedBytes = slice.loadUint(32);
        return {
          roundCandidates,
          nextCandidateDelay,
          consensusTimeout,
          fastAttempts,
          attemptDuration,
          catchainMaxDeps,
          maxBlockBytes,
          maxColaltedBytes
        };
      } else if (magic === 215) {
        const flags = slice.loadUint(7);
        const newCatchainIds = slice.loadBit();
        const roundCandidates = slice.loadUint(8);
        const nextCandidateDelay = slice.loadUint(32);
        const consensusTimeout = slice.loadUint(32);
        const fastAttempts = slice.loadUint(32);
        const attemptDuration = slice.loadUint(32);
        const catchainMaxDeps = slice.loadUint(32);
        const maxBlockBytes = slice.loadUint(32);
        const maxColaltedBytes = slice.loadUint(32);
        return {
          flags,
          newCatchainIds,
          roundCandidates,
          nextCandidateDelay,
          consensusTimeout,
          fastAttempts,
          attemptDuration,
          catchainMaxDeps,
          maxBlockBytes,
          maxColaltedBytes
        };
      } else if (magic === 216) {
        const flags = slice.loadUint(7);
        const newCatchainIds = slice.loadBit();
        const roundCandidates = slice.loadUint(8);
        const nextCandidateDelay = slice.loadUint(32);
        const consensusTimeout = slice.loadUint(32);
        const fastAttempts = slice.loadUint(32);
        const attemptDuration = slice.loadUint(32);
        const catchainMaxDeps = slice.loadUint(32);
        const maxBlockBytes = slice.loadUint(32);
        const maxColaltedBytes = slice.loadUint(32);
        const protoVersion = slice.loadUint(16);
        return {
          flags,
          newCatchainIds,
          roundCandidates,
          nextCandidateDelay,
          consensusTimeout,
          fastAttempts,
          attemptDuration,
          catchainMaxDeps,
          maxBlockBytes,
          maxColaltedBytes,
          protoVersion
        };
      } else if (magic === 217) {
        const flags = slice.loadUint(7);
        const newCatchainIds = slice.loadBit();
        const roundCandidates = slice.loadUint(8);
        const nextCandidateDelay = slice.loadUint(32);
        const consensusTimeout = slice.loadUint(32);
        const fastAttempts = slice.loadUint(32);
        const attemptDuration = slice.loadUint(32);
        const catchainMaxDeps = slice.loadUint(32);
        const maxBlockBytes = slice.loadUint(32);
        const maxColaltedBytes = slice.loadUint(32);
        const protoVersion = slice.loadUint(16);
        const catchainMaxBlocksCoeff = slice.loadUint(32);
        return {
          flags,
          newCatchainIds,
          roundCandidates,
          nextCandidateDelay,
          consensusTimeout,
          fastAttempts,
          attemptDuration,
          catchainMaxDeps,
          maxBlockBytes,
          maxColaltedBytes,
          protoVersion,
          catchainMaxBlocksCoeff
        };
      }
      throw new Error("Invalid config");
    }
    exports.configParse29 = configParse29;
    function parseProposalSetup(slice) {
      const magic = slice.loadUint(8);
      if (magic !== 54) {
        throw new Error("Invalid config");
      }
      const minTotalRounds = slice.loadUint(8);
      const maxTotalRounds = slice.loadUint(8);
      const minWins = slice.loadUint(8);
      const maxLoses = slice.loadUint(8);
      const minStoreSec = slice.loadUint(32);
      const maxStoreSec = slice.loadUint(32);
      const bitPrice = slice.loadUint(32);
      const cellPrice = slice.loadUint(32);
      return { minTotalRounds, maxTotalRounds, minWins, maxLoses, minStoreSec, maxStoreSec, bitPrice, cellPrice };
    }
    exports.parseProposalSetup = parseProposalSetup;
    function parseVotingSetup(slice) {
      if (!slice) {
        throw new Error("Invalid config");
      }
      const magic = slice.loadUint(8);
      if (magic !== 145) {
        throw new Error("Invalid config");
      }
      const normalParams = parseProposalSetup(slice.loadRef().beginParse());
      const criticalParams = parseProposalSetup(slice.loadRef().beginParse());
      return { normalParams, criticalParams };
    }
    exports.parseVotingSetup = parseVotingSetup;
    function loadConfigParams(configBase64) {
      const comfigMap = core_1.Cell.fromBase64(configBase64).beginParse().loadDictDirect(core_1.Dictionary.Keys.Int(32), core_1.Dictionary.Values.Cell());
      return comfigMap;
    }
    function loadConfigParamById(configBase64, id) {
      return loadConfigParams(configBase64).get(id);
    }
    exports.loadConfigParamById = loadConfigParamById;
    function loadConfigParamsAsSlice(configBase64) {
      const pramsAsCells = loadConfigParams(configBase64);
      const params = /* @__PURE__ */ new Map();
      for (const [key, value] of pramsAsCells) {
        params.set(key, value.beginParse());
      }
      return params;
    }
    exports.loadConfigParamsAsSlice = loadConfigParamsAsSlice;
    function parseFullConfig(configs) {
      return {
        configAddress: configParseMasterAddressRequired(configs.get(0)),
        electorAddress: configParseMasterAddressRequired(configs.get(1)),
        minterAddress: configParseMasterAddress(configs.get(2)),
        feeCollectorAddress: configParseMasterAddress(configs.get(3)),
        dnsRootAddress: configParseMasterAddress(configs.get(4)),
        burningConfig: configParse5(configs.get(5)),
        globalVersion: configParse8(configs.get(8)),
        workchains: configParse12(configs.get(12)),
        voting: parseVotingSetup(configs.get(11)),
        validators: {
          ...configParse15(configs.get(15)),
          ...configParse16(configs.get(16)),
          ...configParse17(configs.get(17))
        },
        storagePrices: configParse18(configs.get(18)),
        gasPrices: {
          masterchain: configParseGasLimitsPrices(configs.get(20)),
          workchain: configParseGasLimitsPrices(configs.get(21))
        },
        msgPrices: {
          masterchain: configParseMsgPrices(configs.get(24)),
          workchain: configParseMsgPrices(configs.get(25))
        },
        validatorSets: {
          prevValidators: configParseValidatorSet(configs.get(32)),
          prevTempValidators: configParseValidatorSet(configs.get(33)),
          currentValidators: configParseValidatorSet(configs.get(34)),
          currentTempValidators: configParseValidatorSet(configs.get(35)),
          nextValidators: configParseValidatorSet(configs.get(36)),
          nextTempValidators: configParseValidatorSet(configs.get(37))
        },
        validatorsPunish: configParse40(configs.get(40)),
        bridges: {
          ethereum: configParseBridge(configs.get(71)),
          binance: configParseBridge(configs.get(72)),
          polygon: configParseBridge(configs.get(73))
        },
        catchain: configParse28(configs.get(28)),
        consensus: configParse29(configs.get(29))
        // TODO: mint_new_price:Grams mint_add_price:Grams = ConfigParam 6;
        // TODO: to_mint:ExtraCurrencyCollection = ConfigParam 7
        // TODO: mandatory_params:(Hashmap 32 True) = ConfigParam 9
        // TODO: critical_params:(Hashmap 32 True) = ConfigParam 10
        // TODO: BlockCreateFees = ConfigParam 14
      };
    }
    exports.parseFullConfig = parseFullConfig;
  }
});

// node_modules/@ton/ton/dist/utils/fees.js
var require_fees = __commonJS({
  "node_modules/@ton/ton/dist/utils/fees.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computeMessageForwardFees = exports.computeExternalMessageFees = exports.computeGasPrices = exports.computeFwdFees = exports.computeStorageFees = void 0;
    var core_1 = require_dist2();
    function computeStorageFees(data) {
      const { lastPaid, now, storagePrices, storageStat, special, masterchain } = data;
      if (now <= lastPaid || storagePrices.length === 0 || now < storagePrices[0].utime_since || special) {
        return BigInt(0);
      }
      let upto = Math.max(lastPaid, storagePrices[0].utime_since);
      let total = BigInt(0);
      for (let i = 0; i < storagePrices.length && upto < now; i++) {
        let valid_until = i < storagePrices.length - 1 ? Math.min(now, storagePrices[i + 1].utime_since) : now;
        let payment = BigInt(0);
        if (upto < valid_until) {
          let delta = valid_until - upto;
          payment += BigInt(storageStat.cells) * (masterchain ? storagePrices[i].mc_cell_price_ps : storagePrices[i].cell_price_ps);
          payment += BigInt(storageStat.bits) * (masterchain ? storagePrices[i].mc_bit_price_ps : storagePrices[i].bit_price_ps);
          payment = payment * BigInt(delta);
        }
        upto = valid_until;
        total += payment;
      }
      return shr16ceil(total);
    }
    exports.computeStorageFees = computeStorageFees;
    function computeFwdFees(msgPrices, cells, bits) {
      return msgPrices.lumpPrice + shr16ceil(msgPrices.bitPrice * bits + msgPrices.cellPrice * cells);
    }
    exports.computeFwdFees = computeFwdFees;
    function computeGasPrices(gasUsed, prices) {
      if (gasUsed <= prices.flatLimit) {
        return prices.flatPrice;
      } else {
        return prices.flatPrice + (prices.price * (gasUsed - prices.flatLimit) >> 16n);
      }
    }
    exports.computeGasPrices = computeGasPrices;
    function computeExternalMessageFees(msgPrices, cell) {
      let storageStats = collectCellStats(cell);
      storageStats.bits -= cell.bits.length;
      storageStats.cells -= 1;
      return computeFwdFees(msgPrices, BigInt(storageStats.cells), BigInt(storageStats.bits));
    }
    exports.computeExternalMessageFees = computeExternalMessageFees;
    function computeMessageForwardFees(msgPrices, cell) {
      let msg = (0, core_1.loadMessageRelaxed)(cell.beginParse());
      let storageStats = { bits: 0, cells: 0 };
      if (msg.init) {
        const rawBuilder = new core_1.Cell().asBuilder();
        (0, core_1.storeStateInit)(msg.init)(rawBuilder);
        const raw = rawBuilder.endCell();
        let c = collectCellStats(raw);
        c.bits -= raw.bits.length;
        c.cells -= 1;
        storageStats.bits += c.bits;
        storageStats.cells += c.cells;
      }
      let bc = collectCellStats(msg.body);
      bc.bits -= msg.body.bits.length;
      bc.cells -= 1;
      storageStats.bits += bc.bits;
      storageStats.cells += bc.cells;
      let fees = computeFwdFees(msgPrices, BigInt(storageStats.cells), BigInt(storageStats.bits));
      let res = fees * BigInt(msgPrices.firstFrac) >> 16n;
      let remaining = fees - res;
      return { fees: res, remaining };
    }
    exports.computeMessageForwardFees = computeMessageForwardFees;
    function collectCellStats(cell) {
      let bits = cell.bits.length;
      let cells = 1;
      for (let ref of cell.refs) {
        let r = collectCellStats(ref);
        cells += r.cells;
        bits += r.bits;
      }
      return { bits, cells };
    }
    function shr16ceil(src) {
      let rem = src % 65536n;
      let res = src >> 16n;
      if (rem !== 0n) {
        res += 1n;
      }
      return res;
    }
  }
});

// node_modules/@ton/ton/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@ton/ton/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computeStorageFees = exports.computeMessageForwardFees = exports.computeGasPrices = exports.computeFwdFees = exports.computeExternalMessageFees = exports.loadConfigParamsAsSlice = exports.loadConfigParamById = exports.parseFullConfig = exports.parseVotingSetup = exports.parseValidatorSet = exports.parseProposalSetup = exports.parseBridge = exports.configParseWorkchainDescriptor = exports.configParseValidatorSet = exports.configParseMsgPrices = exports.configParseMasterAddressRequired = exports.configParseMasterAddress = exports.configParseGasLimitsPrices = exports.configParseBridge = exports.configParse40 = exports.configParse29 = exports.configParse28 = exports.configParse18 = exports.configParse17 = exports.configParse16 = exports.configParse15 = exports.configParse13 = exports.configParse12 = exports.configParse8 = exports.configParse5 = exports.ElectorContract = exports.MultisigWallet = exports.MultisigOrderBuilder = exports.MultisigOrder = exports.JettonWallet = exports.JettonMaster = exports.WalletContractV4 = exports.WalletContractV3R2 = exports.WalletContractV3R1 = exports.WalletContractV2R2 = exports.WalletContractV2R1 = exports.WalletContractV1R3 = exports.WalletContractV1R2 = exports.WalletContractV1R1 = exports.TonClient4 = exports.TonClient = exports.HttpApi = void 0;
    __exportStar(require_dist2(), exports);
    var HttpApi_1 = require_HttpApi();
    Object.defineProperty(exports, "HttpApi", { enumerable: true, get: function() {
      return HttpApi_1.HttpApi;
    } });
    var TonClient_1 = require_TonClient();
    Object.defineProperty(exports, "TonClient", { enumerable: true, get: function() {
      return TonClient_1.TonClient;
    } });
    var TonClient4_1 = require_TonClient4();
    Object.defineProperty(exports, "TonClient4", { enumerable: true, get: function() {
      return TonClient4_1.TonClient4;
    } });
    var WalletContractV1R1_1 = require_WalletContractV1R1();
    Object.defineProperty(exports, "WalletContractV1R1", { enumerable: true, get: function() {
      return WalletContractV1R1_1.WalletContractV1R1;
    } });
    var WalletContractV1R2_1 = require_WalletContractV1R2();
    Object.defineProperty(exports, "WalletContractV1R2", { enumerable: true, get: function() {
      return WalletContractV1R2_1.WalletContractV1R2;
    } });
    var WalletContractV1R3_1 = require_WalletContractV1R3();
    Object.defineProperty(exports, "WalletContractV1R3", { enumerable: true, get: function() {
      return WalletContractV1R3_1.WalletContractV1R3;
    } });
    var WalletContractV2R1_1 = require_WalletContractV2R1();
    Object.defineProperty(exports, "WalletContractV2R1", { enumerable: true, get: function() {
      return WalletContractV2R1_1.WalletContractV2R1;
    } });
    var WalletContractV2R2_1 = require_WalletContractV2R2();
    Object.defineProperty(exports, "WalletContractV2R2", { enumerable: true, get: function() {
      return WalletContractV2R2_1.WalletContractV2R2;
    } });
    var WalletContractV3R1_1 = require_WalletContractV3R1();
    Object.defineProperty(exports, "WalletContractV3R1", { enumerable: true, get: function() {
      return WalletContractV3R1_1.WalletContractV3R1;
    } });
    var WalletContractV3R2_1 = require_WalletContractV3R2();
    Object.defineProperty(exports, "WalletContractV3R2", { enumerable: true, get: function() {
      return WalletContractV3R2_1.WalletContractV3R2;
    } });
    var WalletContractV4_1 = require_WalletContractV4();
    Object.defineProperty(exports, "WalletContractV4", { enumerable: true, get: function() {
      return WalletContractV4_1.WalletContractV4;
    } });
    var JettonMaster_1 = require_JettonMaster();
    Object.defineProperty(exports, "JettonMaster", { enumerable: true, get: function() {
      return JettonMaster_1.JettonMaster;
    } });
    var JettonWallet_1 = require_JettonWallet();
    Object.defineProperty(exports, "JettonWallet", { enumerable: true, get: function() {
      return JettonWallet_1.JettonWallet;
    } });
    var MultisigOrder_1 = require_MultisigOrder();
    Object.defineProperty(exports, "MultisigOrder", { enumerable: true, get: function() {
      return MultisigOrder_1.MultisigOrder;
    } });
    var MultisigOrderBuilder_1 = require_MultisigOrderBuilder();
    Object.defineProperty(exports, "MultisigOrderBuilder", { enumerable: true, get: function() {
      return MultisigOrderBuilder_1.MultisigOrderBuilder;
    } });
    var MultisigWallet_1 = require_MultisigWallet();
    Object.defineProperty(exports, "MultisigWallet", { enumerable: true, get: function() {
      return MultisigWallet_1.MultisigWallet;
    } });
    var ElectorContract_1 = require_ElectorContract();
    Object.defineProperty(exports, "ElectorContract", { enumerable: true, get: function() {
      return ElectorContract_1.ElectorContract;
    } });
    var ConfigParser_1 = require_ConfigParser();
    Object.defineProperty(exports, "configParse5", { enumerable: true, get: function() {
      return ConfigParser_1.configParse5;
    } });
    Object.defineProperty(exports, "configParse8", { enumerable: true, get: function() {
      return ConfigParser_1.configParse8;
    } });
    Object.defineProperty(exports, "configParse12", { enumerable: true, get: function() {
      return ConfigParser_1.configParse12;
    } });
    Object.defineProperty(exports, "configParse13", { enumerable: true, get: function() {
      return ConfigParser_1.configParse13;
    } });
    Object.defineProperty(exports, "configParse15", { enumerable: true, get: function() {
      return ConfigParser_1.configParse15;
    } });
    Object.defineProperty(exports, "configParse16", { enumerable: true, get: function() {
      return ConfigParser_1.configParse16;
    } });
    Object.defineProperty(exports, "configParse17", { enumerable: true, get: function() {
      return ConfigParser_1.configParse17;
    } });
    Object.defineProperty(exports, "configParse18", { enumerable: true, get: function() {
      return ConfigParser_1.configParse18;
    } });
    Object.defineProperty(exports, "configParse28", { enumerable: true, get: function() {
      return ConfigParser_1.configParse28;
    } });
    Object.defineProperty(exports, "configParse29", { enumerable: true, get: function() {
      return ConfigParser_1.configParse29;
    } });
    Object.defineProperty(exports, "configParse40", { enumerable: true, get: function() {
      return ConfigParser_1.configParse40;
    } });
    Object.defineProperty(exports, "configParseBridge", { enumerable: true, get: function() {
      return ConfigParser_1.configParseBridge;
    } });
    Object.defineProperty(exports, "configParseGasLimitsPrices", { enumerable: true, get: function() {
      return ConfigParser_1.configParseGasLimitsPrices;
    } });
    Object.defineProperty(exports, "configParseMasterAddress", { enumerable: true, get: function() {
      return ConfigParser_1.configParseMasterAddress;
    } });
    Object.defineProperty(exports, "configParseMasterAddressRequired", { enumerable: true, get: function() {
      return ConfigParser_1.configParseMasterAddressRequired;
    } });
    Object.defineProperty(exports, "configParseMsgPrices", { enumerable: true, get: function() {
      return ConfigParser_1.configParseMsgPrices;
    } });
    Object.defineProperty(exports, "configParseValidatorSet", { enumerable: true, get: function() {
      return ConfigParser_1.configParseValidatorSet;
    } });
    Object.defineProperty(exports, "configParseWorkchainDescriptor", { enumerable: true, get: function() {
      return ConfigParser_1.configParseWorkchainDescriptor;
    } });
    Object.defineProperty(exports, "parseBridge", { enumerable: true, get: function() {
      return ConfigParser_1.parseBridge;
    } });
    Object.defineProperty(exports, "parseProposalSetup", { enumerable: true, get: function() {
      return ConfigParser_1.parseProposalSetup;
    } });
    Object.defineProperty(exports, "parseValidatorSet", { enumerable: true, get: function() {
      return ConfigParser_1.parseValidatorSet;
    } });
    Object.defineProperty(exports, "parseVotingSetup", { enumerable: true, get: function() {
      return ConfigParser_1.parseVotingSetup;
    } });
    Object.defineProperty(exports, "parseFullConfig", { enumerable: true, get: function() {
      return ConfigParser_1.parseFullConfig;
    } });
    Object.defineProperty(exports, "loadConfigParamById", { enumerable: true, get: function() {
      return ConfigParser_1.loadConfigParamById;
    } });
    Object.defineProperty(exports, "loadConfigParamsAsSlice", { enumerable: true, get: function() {
      return ConfigParser_1.loadConfigParamsAsSlice;
    } });
    var fees_1 = require_fees();
    Object.defineProperty(exports, "computeExternalMessageFees", { enumerable: true, get: function() {
      return fees_1.computeExternalMessageFees;
    } });
    Object.defineProperty(exports, "computeFwdFees", { enumerable: true, get: function() {
      return fees_1.computeFwdFees;
    } });
    Object.defineProperty(exports, "computeGasPrices", { enumerable: true, get: function() {
      return fees_1.computeGasPrices;
    } });
    Object.defineProperty(exports, "computeMessageForwardFees", { enumerable: true, get: function() {
      return fees_1.computeMessageForwardFees;
    } });
    Object.defineProperty(exports, "computeStorageFees", { enumerable: true, get: function() {
      return fees_1.computeStorageFees;
    } });
  }
});
export default require_dist3();
//# sourceMappingURL=@ton_ton.js.map
